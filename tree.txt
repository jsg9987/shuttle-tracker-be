● Sequential Thinking으로 계획을 점검한 결과, 몇 가지 중요한 문제점을 발견했습니다. 개선된 계획을 제시하겠습니다.

  ---
  🔍 Sequential Thinking 점검 결과

  ❌ 발견된 주요 문제점

  1. 개발 순서의 문제

  - 문제: 예외 처리, Security+JWT를 User 도메인보다 먼저 구현
  - 이유: 실제 도메인 로직 없이 추상적인 인프라만 만들면 테스트 불가능하고 학습 효과 낮음
  - 개선: 단순한 도메인부터 시작 → 필요성 체감 후 인프라 추가

  2. Redis의 시기상조

  - 문제: Phase 0에 Redis 설치하지만 실제 사용은 Phase 3, 6
  - 이유: MVP에서 Redis는 "성능 최적화"이지 필수가 아님
  - 개선: 일단 DB만으로 구현 → 나중에 Redis 추가 (또는 생략)

  3. 누락된 API

  - 문제: 프론트에서 "모든 친구의 위치"를 한번에 조회해야 하는데 API 없음
  - 개선: GET /api/location/friends 엔드포인트 추가 필요

  4. 비현실적인 일정

  - 문제: 2-3주 예상 (학습 시간 미포함, 디버깅 시간 미포함)
  - 개선: 현실적으로 4-5주 (주니어 + 학습 포함)

  5. CI/CD 우선순위

  - 문제: MVP 단계에서 CI/CD를 필수로 제안
  - 개선: 핵심 기능 완성 후 선택적으로 추가

  ---
  📋 개선된 개발 계획

  🎯 핵심 원칙 변경

  기존 계획 (Top-Down)

  인프라 구축 → 예외처리 → Security → 도메인

  개선된 계획 (Bottom-Up)

  단순 도메인 → 필요한 인프라 → 복잡한 기능 → 최적화

  이유: 주니어 개발자는 "동작하는 코드"를 빠르게 만들어보며 학습하는 것이 효과적

  ---
  🚀 새로운 개발 순서

  Phase 0: 환경 설정 (1-2일)

  목표: 최소한의 개발 환경 구축

  작업:
  1. Docker Compose로 MySQL만 구축 (Redis는 나중에)
  services:
    mysql:
      image: mysql:8.0
      ports: ["3306:3306"]
      environment:
        MYSQL_DATABASE: shuttle_tracker
  2. application.yml 기본 설정
  3. 프로젝트 실행 확인

  학습: Docker 기본, MySQL 연결

  ---
  Phase 1: Shuttle 도메인 (1-2일)

  목표: 가장 단순한 도메인으로 JPA 학습

  왜 먼저?
  - 다른 도메인과 독립적
  - 인증 불필요
  - CRUD 기본 학습에 최적

  작업:
  1. Entity 작성: ShuttleRoute, ShuttleStop
  2. Repository: @OneToMany 관계 학습
  3. Service: 기본 조회 로직
  4. Controller: REST API 작성
    - GET /api/shuttle/routes
    - GET /api/shuttle/routes/{id}/stops
    - GET /api/shuttle/routes/search?q={query}
  5. SQL로 초기 데이터 삽입

  학습:
  - JPA Entity, Repository 기본
  - @OneToMany 연관관계
  - Spring Web Controller
  - SQL 초기 데이터 로드

  결과: Postman으로 실제 동작하는 API 확인 가능!

  ---
  Phase 2: User 도메인 - 기본편 (2일)

  목표: 인증 없이 User CRUD 구현

  작업:
  1. Entity: User (email, password, name)
  2. Repository: 기본 메서드
  3. Service:
    - 회원가입 (비밀번호 BCrypt 암호화)
    - 이메일로 사용자 검색
    - 내 정보 조회
  4. Controller:
    - POST /api/users (회원가입)
    - GET /api/users/search?email={email} (검색)
    - GET /api/users/{id} (조회)

  학습:
  - BCryptPasswordEncoder
  - Bean Validation (@Email, @NotBlank)
  - DTO 패턴 (Request/Response 분리)

  보안은?: 일단 인증 없이 만들어봄 (학습용)

  ---
  Phase 3: 공통 인프라 구축 (1일)

  목표: 지금까지 개발하며 느낀 필요성을 해결

  작업:
  1. GlobalExceptionHandler
    - 지금까지 발생한 예외들을 한곳에서 처리
  2. ErrorCode Enum
  USER_NOT_FOUND(404, "U001", "사용자를 찾을 수 없습니다.")
  DUPLICATE_EMAIL(409, "U002", "이미 존재하는 이메일입니다.")
  3. ApiResponse 통일
  {
    "success": true,
    "data": {...},
    "error": null
  }
  4. BaseTimeEntity (createdAt, updatedAt)

  학습:
  - @ControllerAdvice
  - Custom Exception 설계

  왜 이제?: 실제 예외가 발생해봐야 필요성을 체감함

  ---
  Phase 4: Friend 도메인 (2일)

  목표: 연관관계 심화 학습

  작업:
  1. Entity: Friendship
    - @ManyToOne User requester
    - @ManyToOne User receiver
    - FriendshipStatus status
  2. Repository:
  @Query("SELECT f FROM Friendship f WHERE (f.requester.id = :userId OR f.receiver.id = :userId) AND f.status =
  'ACCEPTED'")
  List<Friendship> findMyFriends(@Param("userId") Long userId);
  3. Service: 친구 추가/수락/거절/삭제
  4. Controller:
    - GET /api/friends (내 친구 목록)
    - POST /api/friends/request
    - PUT /api/friends/{id}/accept
    - DELETE /api/friends/{id}

  학습:
  - 양방향 관계 처리
  - JPQL 작성
  - 복잡한 비즈니스 로직

  ---
  Phase 5: Location 도메인 (2일)

  목표: 위치 공유 로직 구현

  작업:
  1. Entity: LocationShare
  private LocalDateTime startTime;
  private LocalDateTime endTime; // startTime + 1시간
  private Boolean isActive;
  2. Service:
    - 위치 공유 시작/중지
    - 위치 업데이트
    - 중요: GET /api/location/friends (모든 친구 위치 한번에 조회)
    - 조회 시 endTime과 현재 시간 비교 (만료 검증)
  3. @Scheduled (1시간마다 만료된 데이터 정리)

  학습:
  - LocalDateTime 사용
  - @Scheduled 태스크
  - 효율적인 쿼리 (N+1 방지)

  ---
  Phase 6: Spring Security + JWT (3-4일)

  목표: 기존 API에 인증 추가

  왜 이제?:
  - User, Friend, Location이 모두 동작하는 상태
  - 이제 "보호"가 필요함을 체감

  작업:
  1. JWT 의존성 추가
  implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
  2. JwtTokenProvider 구현
  3. JwtAuthenticationFilter 구현
  4. SecurityConfig 작성
  .requestMatchers("/api/auth/**", "/api/shuttle/**").permitAll()
  .anyRequest().authenticated()
  5. 로그인 API 추가
    - POST /api/auth/login → JWT 발급
  6. 기존 API에 인증 적용

  학습:
  - Spring Security Architecture
  - JWT 토큰 생성/검증
  - Filter Chain

  Refresh Token은?:
  - 초기에는 Access Token만 (1일 TTL)
  - 나중에 필요하면 추가

  ---
  Phase 7: Arrival 도메인 (2-3일)

  목표: 도착 시간 예측

  작업:
  1. 카카오 API 조사
    - 비용 확인
    - API 명세 확인
    - 무료 대안 탐색
  2. WebClient 설정
  3. ArrivalTimeService 구현
  4. 대안: 초기에는 단순 거리 계산으로 mock
  // 하버사인 공식으로 직선거리 계산
  double distance = calculateDistance(friendLoc, myLoc);
  int estimatedMinutes = (int)(distance / 평균속도);

  학습:
  - WebClient 사용
  - 외부 API 연동
  - 에러 핸들링

  ---
  Phase 8: Redis 최적화 (선택, 1일)

  목표: 성능 개선

  Redis 도입 시점:
  - Refresh Token 저장
  - Location 데이터 캐싱 (TTL 1시간)

  작업:
  1. Docker Compose에 Redis 추가
  2. RedisUtil 구현
  3. LocationService에 캐싱 로직 추가

  왜 선택?: MVP에서 사용자가 많지 않으면 불필요

  ---
  Phase 9: CI/CD (선택, 1-2일)

  목표: 자동 배포

  작업:
  1. GitHub Actions 워크플로우
  2. Docker 이미지 빌드
  3. 서버 배포 자동화

  왜 선택?: 핵심 기능 완성이 우선

  ---
  📊 개선된 일정 예상

  | Phase | 내용             | 예상 소요 (주니어+학습) |
  |-------|----------------|----------------|
  | 0     | 환경 설정          | 1-2일           |
  | 1     | Shuttle 도메인    | 1-2일           |
  | 2     | User 도메인 기본    | 2일             |
  | 3     | 공통 인프라         | 1일             |
  | 4     | Friend 도메인     | 2일             |
  | 5     | Location 도메인   | 2일             |
  | 6     | Security + JWT | 3-4일           |
  | 7     | Arrival 도메인    | 2-3일           |
  | 8     | Redis (선택)     | 1일             |
  | 9     | CI/CD (선택)     | 1-2일           |
  | 버퍼    | 디버깅, 오류 수정     | 3-5일           |
  | 총계    |                | 4-5주 (현실적)     |

  ---
  ✅ MVP 필수 vs 선택

  필수 (3주 목표)

  - ✅ Phase 0-7 (Redis, CI/CD 제외)
  - ✅ JWT 인증
  - ✅ 핵심 도메인 기능
  - ✅ 예외 처리

  선택 (시간 여유 시)

  - ⭐ Redis 최적화
  - ⭐ CI/CD
  - ⭐ 실제 카카오 API 연동 (초기에는 mock 가능)
  - ⭐ WebSocket 실시간 업데이트

  ---
  📚 단계별 학습 자료

  Phase 1-2: JPA 기초

  - 김영한 - 자바 ORM 표준 JPA 프로그래밍 (인프런)
  - Spring Data JPA 공식 문서

  Phase 3: 예외 처리

  - Baeldung - Exception Handling in Spring
  - 우아한형제들 기술 블로그 - 예외 처리 전략

  Phase 4-5: JPA 심화

  - N+1 문제 해결
  - JPQL vs QueryDSL

  Phase 6: Spring Security

  - 김영한 - 스프링 시큐리티 (인프런)
  - JWT.io 공식 문서
  - Baeldung - Spring Security + JWT

  Phase 7: WebClient

  - Spring WebFlux 공식 문서
  - 카카오 모빌리티 API 문서

  ---
  💡 추가 개선 사항

  1. API 명세 보완

  // 추가 필요
  GET /api/location/friends          // 모든 친구 위치 한번에 조회
  GET /api/users/search?email={email} // 이메일로 사용자 검색

  2. Validation 강화

  // SignUpRequest에 추가
  private String passwordConfirm;

  // Service에서 검증
  if (!password.equals(passwordConfirm)) {
      throw new BusinessException(ErrorCode.PASSWORD_NOT_MATCH);
  }

  3. 위치 만료 로직 개선

  // 조회 시점에 검증 (Lazy Evaluation)
  public Optional<LocationShare> getActiveLocation(Long userId) {
      return locationShareRepository.findByUserId(userId)
          .filter(loc -> loc.getEndTime().isAfter(LocalDateTime.now()))
          .filter(LocationShare::getIsActive);
  }

  ---

✶ Cooking… (esc to interrupt)
  ⎿ Tip: Use /agents to create context-efficient experts for specific tasks. Eg. Code Reviewer, Software Architect, Data
     Scientist

────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
> 
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  ⏸ plan mode on (shift+tab to cycle)

╭─── Claude Code v2.0.26 ──────────────────────────────────────────────────────────────────────────────────────────────╮
│                                                    │ Tips for getting started                                        │
│               Welcome back jedo5000!               │ Run /install-github-app to tag @claude right from your Github … │
│                                                    │ √ Run /init to create a CLAUDE.md file with instructions for C… │
│                       ▐▛███▜▌                      │ ─────────────────────────────────────────────────────────────── │
│                      ▝▜█████▛▘                     │ Recent activity                                                 │
│                        ▘▘ ▝▝                       │ No recent activity                                              │
│                                                    │                                                                 │
│              Sonnet 4.5 · Claude Pro               │                                                                 │
│ C:\Users\SSAFY\projects\shuttle-tracker\shuttle-t… │                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

> # 백엔드

너는 java, Spring을 사용하는 우수기업의 10년차 시니어 백엔드 개발자야. 나는 아직 스프링에 대한 개념, 실력이 부족한
학생이고 프로젝트를 만들려해.

shuttle-tracker-be 프로젝트의 [CLAUDE.md](http://CLAUDE.md), DEVELOPMENT.md, FRONT_README.md, tree.txt를 읽고
프로젝트 파악을 해야함.

1. 프로젝트 세팅 → Springboot로 받고 gradle 설정했음. 코딩 컨벤션 숙지
2. Docker로 MySQL과 Redis Container 만들어서 사용하기, Docker 사용하는 법 공부해야함.
3. git action으로 CI/CD 구축하기
4. 구조 세팅 → domain 별 디렉토리 구조 채택 / 그리고 주니어 개발자로서 내가 백엔드를 어떤 순서대로 무엇을 설계하고
구현해야할지 잘 모르겠어. 알려줬으면 좋겠어.
    1. Entity 설계
    2. Spring security, redis + jwt 사용
    3. tree.txt의 과거 프로젝트 구조와 비슷한 구조로 프로젝트 진행 예정
    4. exceptionhandler, exception, validation 등등 필요한 것들을 넣고 학습할 예정(but MVP 프로젝트이고 바로
서비스해야하므로 과한건 빼고싶음. 추천 부탁함.)
    5. JPA 활용

너가 직접 코드를 짜는게 아닌 아키텍쳐를 어떻게 설계해야하는지, (너무 전 프로젝트를 무조건 따를 필요는 없어. ) 어떻게
 내가 이것들을 구현해 나가야하는지, 무엇을 공부하고 참고해야하는지를 계획 세운걸 받고싶어.

● 프로젝트 파악을 위해 관련 문서들을 먼저 읽어보겠습니다.

● Read(CLAUDE.md)
  ⎿  Read 141 lines

● Read(DEVELOPMENT.md)
  ⎿  Read 385 lines

● Read(FRONT_README.md)
  ⎿  Read 153 lines

● Read(tree.txt)
  ⎿  Read 138 lines

● 현재 프로젝트의 상태를 추가로 확인하겠습니다.

● Search(pattern: "**/*.gradle")
  ⎿  Found 2 files (ctrl+o to expand)

● Search(pattern: "**/application*.yml")
  ⎿  Found 2 files (ctrl+o to expand)

● Search(pattern: "**/application*.properties")
  ⎿  Found 0 files

● Read(build.gradle)
  ⎿  Read 45 lines

● Read(src\main\resources\application.yml)
  ⎿  Read 16 lines

● Search(pattern: "src/main/java/**/*.java")
  ⎿  Found 1 file (ctrl+o to expand)

● 좋습니다! 프로젝트 파악을 완료했습니다. 이제 SSAFY 셔틀 버스 위치 추적 서비스의 백엔드 아키텍처와 개발 계획을
  제시하겠습니다.

  ---
  🎯 SSAFY 셔틀 트래커 백엔드 아키텍처 & 개발 로드맵

  📊 프로젝트 현황 분석

  ✅ 완료된 것

  - Spring Boot 3.5.7 + Gradle 프로젝트 세팅
  - 기본 의존성: JPA, Security, Validation, MySQL, Lombok
  - application.yml 기본 구조 (주석 처리)

  🔧 진행 필요

  1. Docker를 통한 MySQL + Redis 인프라 구축
  2. 도메인별 계층 구조 설계 및 구현
  3. Spring Security + JWT + Redis 인증 시스템
  4. 핵심 비즈니스 로직 구현
  5. CI/CD (GitHub Actions)

  ---
  🏗️ 1. 아키텍처 설계

  1.1 계층 구조 (Layered Architecture)

  이전 프로젝트와 동일한 도메인 기반 구조를 채택하되, MVP에 맞게 단순화합니다.

  src/main/java/com/ssafy/shuttle_tracker/
  ├── domain/
  │   ├── user/                     # 사용자 도메인
  │   │   ├── controller/
  │   │   │   └── UserController.java
  │   │   ├── dto/
  │   │   │   ├── request/
  │   │   │   │   ├── SignUpRequest.java
  │   │   │   │   ├── LoginRequest.java
  │   │   │   │   └── PasswordChangeRequest.java
  │   │   │   └── response/
  │   │   │       └── UserInfoResponse.java
  │   │   ├── entity/
  │   │   │   └── User.java
  │   │   ├── repository/
  │   │   │   └── UserRepository.java
  │   │   └── service/
  │   │       └── UserService.java
  │   │
  │   ├── friend/                   # 친구 관계 도메인
  │   │   ├── controller/
  │   │   ├── dto/
  │   │   ├── entity/
  │   │   │   └── Friendship.java
  │   │   ├── repository/
  │   │   └── service/
  │   │
  │   ├── location/                 # 위치 공유 도메인
  │   │   ├── controller/
  │   │   ├── dto/
  │   │   ├── entity/
  │   │   │   └── LocationShare.java
  │   │   ├── repository/
  │   │   └── service/
  │   │
  │   ├── shuttle/                  # 셔틀 버스 도메인
  │   │   ├── controller/
  │   │   ├── dto/
  │   │   ├── entity/
  │   │   │   ├── ShuttleRoute.java
  │   │   │   └── ShuttleStop.java
  │   │   ├── repository/
  │   │   └── service/
  │   │
  │   └── arrival/                  # 도착 시간 예측 도메인
  │       ├── controller/
  │       ├── dto/
  │       └── service/
  │           └── ArrivalTimeService.java  # 카카오 API 호출
  │
  └── global/
      ├── config/
      │   ├── SecurityConfig.java
      │   ├── RedisConfig.java
      │   ├── WebConfig.java         # CORS 설정
      │   └── JpaConfig.java
      ├── security/
      │   ├── jwt/
      │   │   ├── JwtTokenProvider.java
      │   │   ├── JwtAuthenticationFilter.java
      │   │   └── JwtProperties.java
      │   └── auth/
      │       ├── CustomUserDetails.java
      │       └── CustomUserDetailsService.java
      ├── error/
      │   ├── exception/
      │   │   ├── BusinessException.java
      │   │   ├── ErrorCode.java
      │   │   └── (각 도메인별 커스텀 Exception)
      │   └── GlobalExceptionHandler.java
      ├── common/
      │   ├── response/
      │   │   ├── ApiResponse.java
      │   │   └── ErrorResponse.java
      │   └── constants/
      │       └── Constants.java
      └── util/
          └── RedisUtil.java

  1.2 핵심 설계 원칙

  1. 도메인 중심 설계: 각 도메인은 독립적으로 동작 가능
  2. 단방향 의존성: Controller → Service → Repository
  3. DTO 분리: Entity 직접 노출 금지, Request/Response DTO 사용
  4. 예외 처리 통일: GlobalExceptionHandler로 중앙 관리
  5. API 응답 통일: ApiResponse 래퍼 클래스 사용

  ---
  🗄️ 2. 데이터베이스 설계

  2.1 핵심 엔티티

  User (사용자)

  @Entity
  @Table(name = "users")
  public class User extends BaseTimeEntity {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(unique = true, nullable = false)
      private String email;

      @Column(nullable = false)
      private String password;  // BCrypt 암호화

      @Column(nullable = false)
      private String name;

      @Column(nullable = false)
      private Boolean locationShareAgree = false;

      @Enumerated(EnumType.STRING)
      private Role role;  // USER, ADMIN
  }

  Friendship (친구 관계)

  @Entity
  public class Friendship extends BaseTimeEntity {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "requester_id")
      private User requester;  // 요청 보낸 사람

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "receiver_id")
      private User receiver;  // 요청 받은 사람

      @Enumerated(EnumType.STRING)
      private FriendshipStatus status;  // PENDING, ACCEPTED, REJECTED
  }

  LocationShare (위치 공유)

  @Entity
  public class LocationShare {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "user_id")
      private User user;

      @Column(nullable = false)
      private Double latitude;

      @Column(nullable = false)
      private Double longitude;

      @Column(nullable = false)
      private LocalDateTime startTime;

      @Column(nullable = false)
      private LocalDateTime endTime;  // 1시간 후

      @Column(nullable = false)
      private Boolean isActive = true;
  }

  ShuttleRoute (셔틀 노선)

  @Entity
  public class ShuttleRoute extends BaseTimeEntity {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(nullable = false)
      private String name;  // "1호차", "2호차"

      @Column(length = 500)
      private String description;

      @OneToMany(mappedBy = "route", cascade = CascadeType.ALL)
      private List<ShuttleStop> stops = new ArrayList<>();
  }

  ShuttleStop (경유지)

  @Entity
  public class ShuttleStop {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "route_id")
      private ShuttleRoute route;

      @Column(nullable = false)
      private String name;  // "광주역", "광주송정역"

      @Column(nullable = false)
      private Double latitude;

      @Column(nullable = false)
      private Double longitude;

      @Column(nullable = false)
      private Integer stopOrder;  // 순서 (1, 2, 3...)
  }

  2.2 BaseTimeEntity (공통 시간 필드)

  @MappedSuperclass
  @EntityListeners(AuditingEntityListener.class)
  public abstract class BaseTimeEntity {
      @CreatedDate
      @Column(updatable = false)
      private LocalDateTime createdAt;

      @LastModifiedDate
      private LocalDateTime updatedAt;
  }

  ---
  🔐 3. Spring Security + JWT + Redis 인증 시스템

  3.1 JWT 기반 인증 플로우

  1. 로그인 → JWT Access Token (1시간) + Refresh Token (7일) 발급
  2. Access Token을 Authorization Header에 포함하여 요청
  3. JwtAuthenticationFilter에서 토큰 검증
  4. 토큰 만료 시 Refresh Token으로 재발급
  5. Refresh Token은 Redis에 저장 (TTL: 7일)

  3.2 필요한 의존성 추가

  dependencies {
      // JWT
      implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
      runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.3'
      runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.3'

      // Redis
      implementation 'org.springframework.boot:spring-boot-starter-data-redis'

      // 카카오 API 호출
      implementation 'org.springframework.boot:spring-boot-starter-webflux'

      // (선택) WebSocket (추후 실시간 위치 업데이트용)
      // implementation 'org.springframework.boot:spring-boot-starter-websocket'
  }

  3.3 SecurityConfig 구조

  @Configuration
  @EnableWebSecurity
  @EnableMethodSecurity
  public class SecurityConfig {

      @Bean
      public SecurityFilterChain filterChain(HttpSecurity http) {
          return http
              .csrf(csrf -> csrf.disable())
              .cors(cors -> cors.configurationSource(corsConfigurationSource()))
              .sessionManagement(session ->
                  session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
              .authorizeHttpRequests(auth -> auth
                  .requestMatchers("/api/auth/**").permitAll()
                  .anyRequest().authenticated()
              )
              .addFilterBefore(jwtAuthenticationFilter,
                  UsernamePasswordAuthenticationFilter.class)
              .exceptionHandling(exception -> exception
                  .authenticationEntryPoint(jwtAuthenticationEntryPoint)
              )
              .build();
      }
  }

  ---
  📝 4. 개발 순서 및 단계별 학습 가이드

  Phase 0: 인프라 구축 (1-2일)

  목표: Docker로 MySQL과 Redis 환경 구축

  작업 내용

  1. Docker Compose 작성
  # docker-compose.yml
  version: '3.8'
  services:
    mysql:
      image: mysql:8.0
      container_name: shuttle-mysql
      environment:
        MYSQL_ROOT_PASSWORD: root1234
        MYSQL_DATABASE: shuttle_tracker
      ports:
        - "3306:3306"
      volumes:
        - mysql-data:/var/lib/mysql

    redis:
      image: redis:7-alpine
      container_name: shuttle-redis
      ports:
        - "6379:6379"
      volumes:
        - redis-data:/data

  volumes:
    mysql-data:
    redis-data:

  2. application.yml 설정
  spring:
    datasource:
      url: jdbc:mysql://localhost:3306/shuttle_tracker
      username: root
      password: root1234
    jpa:
      hibernate:
        ddl-auto: create  # 개발: create, 운영: validate
      show-sql: true
      properties:
        hibernate:
          format_sql: true
    redis:
      host: localhost
      port: 6379

  학습 자료

  - Docker 기본 개념: https://docs.docker.com/get-started/
  - Docker Compose: https://docs.docker.com/compose/

  ---
  Phase 1: 프로젝트 기반 설정 (1일)

  목표: 공통 설정 및 구조 준비

  작업 내용

  1. 패키지 구조 생성 (위 1.1 구조 참고)
  2. Global 설정 클래스
    - WebConfig (CORS)
    - JpaConfig (Auditing)
  3. 공통 응답 DTO
    - ApiResponse
    - ErrorResponse
  4. BaseTimeEntity 작성

  학습 자료

  - Spring Boot 패키지 구조 Best Practice
  - JPA Auditing: https://docs.spring.io/spring-data/jpa/reference/auditing.html

  ---
  Phase 2: 예외 처리 시스템 구축 (1일)

  목표: 통일된 예외 처리 체계 구축

  작업 내용

  1. ErrorCode Enum
  @Getter
  @RequiredArgsConstructor
  public enum ErrorCode {
      // 공통
      INVALID_INPUT_VALUE(400, "C001", "잘못된 입력값입니다."),
      UNAUTHORIZED(401, "C002", "인증이 필요합니다."),

      // User
      USER_NOT_FOUND(404, "U001", "사용자를 찾을 수 없습니다."),
      DUPLICATE_EMAIL(409, "U002", "이미 존재하는 이메일입니다."),
      INVALID_PASSWORD(400, "U003", "비밀번호가 일치하지 않습니다."),

      // Friend
      FRIENDSHIP_NOT_FOUND(404, "F001", "친구 관계를 찾을 수 없습니다."),
      ALREADY_FRIENDS(409, "F002", "이미 친구 관계입니다."),

      // Location
      LOCATION_SHARE_NOT_ACTIVE(400, "L001", "위치 공유가 활성화되지 않았습니다.");

      private final int status;
      private final String code;
      private final String message;
  }

  2. BusinessException
  3. GlobalExceptionHandler

  학습 자료

  - Spring @ControllerAdvice: https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc
  - Custom Exception 설계 패턴

  ---
  Phase 3: Spring Security + JWT 구현 (2-3일)

  목표: 인증/인가 시스템 완성

  작업 순서

  1. JwtTokenProvider 구현
    - Access Token 생성 (1시간)
    - Refresh Token 생성 (7일)
    - 토큰 검증
    - 토큰에서 사용자 정보 추출
  2. RedisUtil 구현
    - Refresh Token 저장
    - Blacklist (로그아웃된 토큰) 관리
  3. JwtAuthenticationFilter 구현
    - Authorization 헤더에서 토큰 추출
    - 토큰 검증
    - SecurityContext에 인증 정보 저장
  4. CustomUserDetailsService 구현
  5. SecurityConfig 작성

  학습 자료

  - JWT 개념: https://jwt.io/introduction
  - Spring Security Architecture: https://spring.io/guides/topicals/spring-security-architecture
  - Redis 기본: https://redis.io/docs/getting-started/

  ---
  Phase 4: User 도메인 구현 (2일)

  목표: 회원가입, 로그인, 사용자 정보 관리

  작업 순서

  1. Entity 작성: User.java
  2. Repository 작성: UserRepository.java
  3. Service 작성: UserService.java
    - 회원가입 (비밀번호 BCrypt 암호화)
    - 로그인 (JWT 발급)
    - 내 정보 조회
    - 비밀번호 변경
    - 위치 공유 동의 설정
  4. Controller 작성: UserController.java
    - POST /api/auth/signup
    - POST /api/auth/login
    - GET /api/auth/me
    - PUT /api/auth/password
    - PUT /api/auth/location-share-agree

  DTO 예시

  // Request
  @Getter
  @NoArgsConstructor
  public class SignUpRequest {
      @Email(message = "이메일 형식이 올바르지 않습니다.")
      @NotBlank
      private String email;

      @NotBlank
      @Pattern(regexp = "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,}$",
               message = "비밀번호는 8자 이상, 영문과 숫자를 포함해야 합니다.")
      private String password;

      @NotBlank
      private String name;
  }

  // Response
  @Getter
  @Builder
  public class LoginResponse {
      private String accessToken;
      private String refreshToken;
      private UserInfoResponse user;
  }

  학습 자료

  - Spring Data JPA: https://spring.io/projects/spring-data-jpa
  - Bean Validation: https://beanvalidation.org/
  - BCrypt 암호화: BCryptPasswordEncoder

  ---
  Phase 5: Friend 도메인 구현 (1-2일)

  목표: 친구 추가, 수락, 거절, 삭제

  작업 순서

  1. Entity: Friendship.java
  2. Repository: FriendshipRepository.java
    - 쿼리 메서드: findByRequesterAndReceiver, findAllByStatus 등
  3. Service: FriendshipService.java
  4. Controller: FriendshipController.java
    - GET /api/friends (ACCEPTED만)
    - POST /api/friends/request
    - PUT /api/friends/{id}/accept
    - PUT /api/friends/{id}/reject
    - DELETE /api/friends/{id}
    - GET /api/friends/pending

  학습 자료

  - JPA 연관관계 매핑: @ManyToOne, @OneToMany
  - JPQL 쿼리 작성

  ---
  Phase 6: Location 도메인 구현 (2일)

  목표: 위치 공유 시작/중지, 실시간 위치 업데이트

  작업 순서

  1. Entity: LocationShare.java
  2. Repository: LocationShareRepository.java
  3. Service: LocationService.java
    - 위치 공유 시작 (1시간 TTL 설정)
    - 위치 공유 중지
    - 내 위치 업데이트 (Redis에도 캐싱)
    - 친구 위치 조회
    - 스케줄러: 만료된 위치 공유 자동 비활성화
  4. Controller: LocationController.java

  중요 로직

  // 위치 공유 시작
  public void startSharing(Long userId, Double lat, Double lng) {
      LocalDateTime now = LocalDateTime.now();
      LocationShare locationShare = LocationShare.builder()
          .user(userRepository.findById(userId).orElseThrow())
          .latitude(lat)
          .longitude(lng)
          .startTime(now)
          .endTime(now.plusHours(1))  // 1시간 후 만료
          .isActive(true)
          .build();

      locationShareRepository.save(locationShare);

      // Redis에도 캐싱 (TTL: 1시간)
      redisUtil.setDataExpire("location:" + userId, locationShare, 3600);
  }

  학습 자료

  - Spring @Scheduled: https://spring.io/guides/gs/scheduling-tasks/
  - Redis TTL 설정

  ---
  Phase 7: Shuttle 도메인 구현 (1일)

  목표: 셔틀 노선 및 경유지 관리

  작업 순서

  1. Entity: ShuttleRoute.java, ShuttleStop.java
  2. Repository: ShuttleRouteRepository.java, ShuttleStopRepository.java
  3. Service: ShuttleService.java
    - 모든 노선 조회
    - 특정 노선의 경유지 조회 (stopOrder 순서대로)
    - 노선 검색
  4. Controller: ShuttleController.java

  초기 데이터 삽입

  -- sql/init-data.sql
  INSERT INTO shuttle_route (name, description) VALUES
  ('1호차', 'SSAFY 광주 1호차'),
  ('2호차', 'SSAFY 광주 2호차');

  INSERT INTO shuttle_stop (route_id, name, latitude, longitude, stop_order) VALUES
  (1, '광주역', 35.1160, 126.9172, 1),
  (1, '광주송정역', 35.1390, 126.7938, 2),
  (1, 'SSAFY 광주캠퍼스', 35.2019, 126.8095, 3);

  학습 자료

  - JPA @OneToMany 관계 설정
  - SQL 초기 데이터 로드: data.sql

  ---
  Phase 8: Arrival 도메인 구현 (2-3일)

  목표: 카카오 모빌리티 API 연동 및 도착 시간 예측

  작업 순서

  1. ArrivalTimeService 구현
    - 카카오 모빌리티 API 호출 (WebClient 사용)
    - 친구 위치 → 경유지 → 내 위치 경로 계산
    - 도착 시간 예측
  2. Controller: ArrivalController.java
    - POST /api/shuttle/arrival-time

  카카오 API 호출 예시

  @Service
  @RequiredArgsConstructor
  public class ArrivalTimeService {

      private final WebClient kakaoWebClient;

      @Value("${kakao.mobility.api-key}")
      private String kakaoApiKey;

      public ArrivalTimeResponse calculateArrivalTime(
          Long friendId,
          Location myLocation,
          List<Long> stopIds
      ) {
          // 1. 친구 위치 조회
          LocationShare friendLocation = locationShareRepository
              .findActiveByUserId(friendId)
              .orElseThrow(() -> new BusinessException(ErrorCode.LOCATION_SHARE_NOT_ACTIVE));

          // 2. 경유지 좌표 조회
          List<ShuttleStop> stops = shuttleStopRepository.findAllById(stopIds);

          // 3. 카카오 API로 경로 및 시간 계산
          String origin = friendLocation.getLatitude() + "," + friendLocation.getLongitude();
          String destination = myLocation.getLat() + "," + myLocation.getLng();
          String waypoints = stops.stream()
              .map(s -> s.getLatitude() + "," + s.getLongitude())
              .collect(Collectors.joining("|"));

          KakaoRouteResponse kakaoResponse = kakaoWebClient.get()
              .uri(uriBuilder -> uriBuilder
                  .path("/v1/waypoints/directions")
                  .queryParam("origin", origin)
                  .queryParam("destination", destination)
                  .queryParam("waypoints", waypoints)
                  .build())
              .header("Authorization", "KakaoAK " + kakaoApiKey)
              .retrieve()
              .bodyToMono(KakaoRouteResponse.class)
              .block();

          // 4. 응답 가공
          int durationMinutes = kakaoResponse.getDuration() / 60;
          LocalDateTime estimatedArrival = LocalDateTime.now().plusMinutes(durationMinutes);

          return ArrivalTimeResponse.builder()
              .routeName(stops.get(0).getRoute().getName())
              .estimatedMinutes(durationMinutes)
              .estimatedArrivalTime(estimatedArrival)
              .routePath(kakaoResponse.getCoordinates())
              .build();
      }
  }

  학습 자료

  - Spring WebClient: https://docs.spring.io/spring-framework/reference/web/webflux-webclient.html
  - 카카오 모빌리티 API: https://developers.kakaomobility.com/

  ---
  Phase 9: CI/CD 구축 (1-2일)

  목표: GitHub Actions로 자동 빌드 및 배포

  GitHub Actions Workflow

  # .github/workflows/deploy.yml
  name: Deploy to Server

  on:
    push:
      branches: [ main ]

  jobs:
    build-and-deploy:
      runs-on: ubuntu-latest

      steps:
      - uses: actions/checkout@v3

      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build with Gradle
        run: ./gradlew clean build -x test

      - name: Build Docker image
        run: docker build -t shuttle-tracker-be .

      - name: Push to Docker Hub (선택)
        # Docker Hub에 푸시하는 단계

      - name: Deploy to Server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            cd /app/shuttle-tracker
            docker-compose down
            docker-compose pull
            docker-compose up -d

  Dockerfile

  FROM openjdk:21-jdk-slim
  ARG JAR_FILE=build/libs/*.jar
  COPY ${JAR_FILE} app.jar
  EXPOSE 8080
  ENTRYPOINT ["java", "-jar", "/app.jar"]

  학습 자료

  - GitHub Actions: https://docs.github.com/en/actions
  - Docker 이미지 빌드: https://docs.docker.com/engine/reference/builder/

  ---
  🎯 5. MVP에서 제외할 것 (과한 것들)

  ❌ 제외 추천

  1. WebSocket 실시간 업데이트
    - 이유: 프론트가 새로고침 방식 채택
    - 나중에 추가 가능
  2. Admin 기능
    - 이유: 초기에는 직접 DB 관리
    - 노선/경유지는 SQL로 직접 삽입
  3. 소셜 로그인 (OAuth2)
    - 이유: 이메일/비밀번호 방식으로 충분
    - 나중에 추가 가능
  4. 이메일 인증
    - 이유: 내부 서비스 (SSAFY 교육생 대상)
  5. 복잡한 로깅 시스템 (ELK Stack)
    - 이유: 초기에는 Spring Boot 기본 로깅으로 충분
  6. 다중 프로필 환경 분리 (dev/prod/local)
    - 이유: 초기에는 application.yml 하나로 시작
    - 필요시 application-prod.yml 추가
  7. 복잡한 테스트 코드
    - 이유: MVP는 핵심 기능 위주 단위 테스트만
    - 통합 테스트는 시간 여유 있을 때

  ✅ 꼭 포함해야 할 것

  1. JWT + Redis 인증 (보안 기본)
  2. GlobalExceptionHandler (에러 처리 통일)
  3. Validation (입력값 검증)
  4. CORS 설정 (프론트 연동 필수)
  5. Docker Compose (개발 환경 통일)
  6. 기본 CI/CD (자동 배포)

  ---
  📚 6. 학습 자료 총정리

  필수 학습

  1. Spring Boot 기본
    - 공식 문서: https://spring.io/projects/spring-boot
    - 인프런 - 김영한의 스프링 부트 (추천)
  2. Spring Data JPA
    - 공식 문서: https://spring.io/projects/spring-data-jpa
    - 연관관계 매핑, JPQL
  3. Spring Security + JWT
    - Spring Security 공식 문서
    - JWT.io 이해하기
    - 블로그: "Spring Boot 3 + JWT 인증 구현"
  4. Docker
    - Docker 공식 튜토리얼
    - Docker Compose 사용법
  5. Redis
    - Redis 공식 문서 - Getting Started
    - Spring Data Redis 사용법

  참고 자료

  - 우아한형제들 기술 블로그
  - 카카오 기술 블로그
  - Baeldung (Spring 관련 튜토리얼)

  ---
  🚀 7. 개발 일정 (예상)

  | Phase | 내용                    | 예상 소요 시간 |
  |-------|-----------------------|----------|
  | 0     | Docker 인프라 구축         | 1-2일     |
  | 1     | 프로젝트 기반 설정            | 1일       |
  | 2     | 예외 처리 시스템             | 1일       |
  | 3     | Spring Security + JWT | 2-3일     |
  | 4     | User 도메인              | 2일       |
  | 5     | Friend 도메인            | 1-2일     |
  | 6     | Location 도메인          | 2일       |
  | 7     | Shuttle 도메인           | 1일       |
  | 8     | Arrival 도메인 (카카오 API) | 2-3일     |
  | 9     | CI/CD 구축              | 1-2일     |
  | 총계    |                       | 약 2-3주   |

  ---
  💡 8. 개발 팁

  8.1 코딩 컨벤션

  - 클래스명: PascalCase (UserService)
  - 메서드명: camelCase (findUserById)
  - 상수: UPPER_SNAKE_CASE (MAX_LOGIN_ATTEMPTS)
  - 패키지: 소문자 (com.ssafy.shuttle_tracker)

  8.2 Git Commit 메시지

  feat: 새로운 기능 추가
  fix: 버그 수정
  refactor: 코드 리팩토링
  docs: 문서 수정
  test: 테스트 코드 추가
  chore: 빌드 설정 등

  예시: feat: User 도메인 회원가입 API 구현

  8.3 디버깅 팁

  - Postman으로 API 테스트
  - H2 Console로 개발 초기 DB 확인
  - Spring Boot Actuator (선택)

  ---
  ⎿  User rejected Claude's plan:
     ╭───────────────────────────────────────────────────────────────────────────────────╮
     │ SSAFY 셔틀 트래커 백엔드 개발 계획                                                │
     │                                                                                   │
     │ 📋 아키텍처 설계                                                                  │
     │                                                                                   │
     │ - 도메인 중심 계층 구조: User, Friend, Location, Shuttle, Arrival 도메인으로 분리 │
     │ - 이전 프로젝트와 유사한 구조: controller/dto/entity/repository/service 패턴 채택 │
     │ - MVP 원칙: 필수 기능만 구현 (WebSocket, Admin, OAuth2 제외)                      │
     │                                                                                   │
     │ 🛠️ 기술 스택                                                                     │
     │                                                                                   │
     │ - Spring Boot 3.5.7 + JPA + Spring Security                                       │
     │ - MySQL (Docker) + Redis (Docker)                                                 │
     │ - JWT 인증 (Access Token 1시간, Refresh Token 7일)                                │
     │ - 카카오 모빌리티 API (도착 시간 예측)                                            │
     │ - GitHub Actions (CI/CD)                                                          │
     │                                                                                   │
     │ 📝 개발 순서 (총 2-3주 예상)                                                      │
     │                                                                                   │
     │ Phase 0-2: 기반 구축 (3-4일)                                                      │
     │                                                                                   │
     │ 1. Docker Compose로 MySQL + Redis 구축                                            │
     │ 2. 패키지 구조 생성 (domain별 계층 분리)                                          │
     │ 3. GlobalExceptionHandler, ErrorCode, ApiResponse 등 공통 설정                    │
     │                                                                                   │
     │ Phase 3: 인증 시스템 (2-3일)                                                      │
     │                                                                                   │
     │ - Spring Security + JWT + Redis 구현                                              │
     │ - JwtTokenProvider, JwtAuthenticationFilter, SecurityConfig                       │
     │                                                                                   │
     │ Phase 4-7: 핵심 도메인 구현 (6-7일)                                               │
     │                                                                                   │
     │ - User: 회원가입, 로그인, 정보 수정                                               │
     │ - Friend: 친구 추가/수락/거절/삭제                                                │
     │ - Location: 위치 공유 시작/중지, 1시간 자동 만료                                  │
     │ - Shuttle: 노선 및 경유지 조회                                                    │
     │                                                                                   │
     │ Phase 8: 카카오 API 연동 (2-3일)                                                  │
     │                                                                                   │
     │ - WebClient로 카카오 모빌리티 API 호출                                            │
     │ - 도착 시간 예측 로직 구현                                                        │
     │                                                                                   │
     │ Phase 9: CI/CD (1-2일)                                                            │
     │                                                                                   │
     │ - GitHub Actions Workflow 설정                                                    │
     │ - Docker 이미지 빌드 및 자동 배포                                                 │
     │                                                                                   │
     │ 📚 학습 필요 항목                                                                 │
     │                                                                                   │
     │ - Docker & Docker Compose 기본                                                    │
     │ - Spring Security + JWT 인증 구조                                                 │
     │ - Spring Data JPA 연관관계 매핑                                                   │
     │ - Redis 기본 사용법 (TTL, 캐싱)                                                   │
     │ - WebClient를 통한 외부 API 호출                                                  │
     │                                                                                   │
     │ ✅ MVP에 포함                                                                      │
     │                                                                                   │
     │ - JWT + Redis 인증, 예외 처리, Validation, CORS, Docker, 기본 CI/CD               │
     │                                                                                   │
     │ ❌ MVP에서 제외                                                                    │
     │                                                                                   │
     │ - WebSocket, Admin 기능, 소셜 로그인, 이메일 인증, ELK Stack, 복잡한 테스트       │
     │                                                                                   │
     │ ---                                                                               │
     │ 이 계획으로 진행해도 될까요? 구체적인 질문이나 수정 사항이 있으면 말씀해주세요!   │
     ╰───────────────────────────────────────────────────────────────────────────────────╯

> 아 깜빡했다. 지금 세우고 있는 계획 Sequential Thinking MCP 사용해서 한 번 더 점검해줘.

● Sequential Thinking으로 계획을 점검하겠습니다.

● sequential-thinking - sequentialthinking (MCP)(thought: "SSAFY 셔틀 트래커 백엔드 프로젝트의 요구사항을
                                                정리해보자.\n\n핵심 기능:\n1. 사용자 인증 (회원가입, 로그인, JWT)\n2.
                                                친구 관리 (추가, 수락, 거절, 삭제)\n3. 위치 공유 (1시간 자동 만료,
                                                ON/OFF)\n4. 셔틀 노선 및 경유지 조회\n5. 도착 시간 예측 (카카오 API
                                                연동)\n\n기술 스택:\n- Spring Boot 3.5.7, JPA, Spring Security\n- MySQL
                                                + Redis (Docker)\n- JWT 인증\n- 카카오 모 il리티 API\n\n프로젝트
                                                특징:\n- MVP 프로젝트 (빠른 서비스 출시 필요)\n- 주니어 개발자 대상\n-
                                                이전 프로젝트 구조 참고 (domain별 계층 구조)\n\n계획 검증을 위해
                                                고려해야 할 관점:\n1. 개발 순서의 적절성\n2. 학습 곡선 고려\n3. MVP
                                                범위의 적절성\n4. 기술 스택의 타당성\n5. 놓친 요구사항은 없는지",
                                                thoughtNumber: 1, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 1,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Phase 0 (Docker 인프라 구축)부터 검토해보자.\n\n제안한 순서:
                                                Docker MySQL + Redis 구축 → application.yml 설정\n\n검토:\n✅ 장점: 개발
                                                 환경을 먼저 갖추는 것은 합리적\n⚠️ 우려: 주니어 개발자가 Docker를 처음
                                                접하면 1-2일로는 부족할 수 있음\n⚠️ 우려: Docker 없이도 로컬 MySQL로
                                                시작할 수 있는데, 필수로 Docker를 강제하는 것이 맞나?\n\n개선 방안:\n-
                                                Docker는 \"권장\"이지만 선택사항으로 두기\n- 또는 Docker Compose 파일을
                                                미리 완성해서 제공하고, `docker-compose up -d` 한 번만 실행하면
                                                되도록\n- 로컬 MySQL 설치 옵션도 함께 제시\n\n결론: Docker 구축 단계를
                                                더 명확하게 하거나, 대안 제시 필요", thoughtNumber: 2, totalThoughts:
                                                15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 2,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Phase 1-2 (프로젝트 기반 설정 + 예외 처리)를
                                                검토해보자.\n\n제안 순서:\n1. 패키지 구조 생성\n2. WebConfig, JpaConfig
                                                등 공통 설정\n3. ApiResponse, ErrorResponse\n4. BaseTimeEntity\n5.
                                                ErrorCode, BusinessException, GlobalExceptionHandler\n\n검토:\n✅ 장점:
                                                공통 인프라를 먼저 구축하는 것은 좋은 접근\n❌ 문제점: 주니어 개발자
                                                입장에서 \"추상적인 것\"부터 시작하면 동기부여가 떨어질 수 있음\n❌
                                                문제점: 예외 처리 시스템을 먼저 만들어도, 실제 도메인 로직이 없으면
                                                테스트할 수 없음\n\n대안:\n- 먼저 가장 단순한 도메인(User
                                                회원가입/로그인)을 만들어보고\n- 그 과정에서 필요한 예외 처리를
                                                점진적으로 추가하는 방식\n- \"동작하는 코드\"를 빨리 만들어보는 것이
                                                학습에 더 효과적\n\n이것은 \"Top-down vs Bottom-up\" 접근의 차이인데,
                                                주니어에게는 Bottom-up이 더 나을 수 있음", thoughtNumber: 3,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 3,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Phase 3 (Spring Security + JWT) 시점을 검토해보자.\n\n제안
                                                순서: User 도메인보다 먼저 Security + JWT를 구현\n\n검토:\n❌ 큰 문제:
                                                Spring Security와 JWT는 매우 복잡한 주제\n❌ 주니어가 User Entity도 없는
                                                 상태에서 CustomUserDetailsService를 만들 수 없음\n❌ 로그인 로직도
                                                없는데 JWT를 먼저 구현하면 테스트 불가능\n❌ 학습 곡선: Security는
                                                Spring에서 가장 어려운 부분 중 하나\n\n올바른 순서:\n1. 먼저 User
                                                도메인을 Security 없이 구현 (회원가입, 조회)\n2. 간단한 로그인 API를
                                                만들어보기 (Security 없이)\n3. 그 다음에 Spring Security를 적용하면서
                                                점진적으로 개선\n4. 마지막으로 JWT 추가\n\n이유:\n- \"동작하는 코드\"를
                                                먼저 만들고 점진적으로 보안을 강화하는 것이 학습에 효과적\n- Spring
                                                Security의 필요성을 체감한 후에 적용해야 이해도가 높아짐",
                                                thoughtNumber: 4, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 4,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "도메인 간 의존성을 검토해보자.\n\n제안된 도메인 구현 순서:
                                                User → Friend → Location → Shuttle → Arrival\n\n의존성 분석:\n- Friend는
                                                 User에 의존 (Friendship이 User를 참조)\n- Location은 User에 의존
                                                (LocationShare가 User를 참조)\n- Shuttle은 독립적 (ShuttleRoute,
                                                ShuttleStop)\n- Arrival은 Location + Shuttle + Friend에 모두
                                                의존\n\n검토:\n✅ User를 먼저 하는 것은 맞음\n⚠️ Friend와 Location은
                                                병렬로 개발 가능한데 순차적으로 제안됨\n⚠️ Shuttle은 다른 도메인과
                                                독립적이므로 더 일찍 할 수 있음\n\n개선된 순서:\n1. User (기본 CRUD)\n2.
                                                 Shuttle (독립적이므로 병렬 가능)\n3. Friend + Location (병렬 가능)\n4.
                                                Arrival (모든 도메인이 준비된 후)\n\n또는 학습 관점에서:\n1. Shuttle
                                                (가장 단순, JPA 연습용)\n2. User (인증 제외한 기본 기능)\n3. Friend
                                                (연관관계 학습)\n4. Location (스케줄러, Redis 학습)\n5. 인증 시스템
                                                (Security + JWT)\n6. Arrival (외부 API 연동)\n\n후자가 학습 곡선
                                                측면에서 더 나을 수 있음", thoughtNumber: 5, totalThoughts: 15,
                                                nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 5,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Redis 사용 시점을 검토해보자.\n\n제안에서 Redis 사용처:\n1.
                                                JWT Refresh Token 저장\n2. 로그아웃 토큰 Blacklist\n3. Location 데이터
                                                캐싱\n\n검토:\n⚠️ 문제: Redis를 Phase 0에 설치하지만, 실제 사용은 Phase
                                                3 (JWT), Phase 6 (Location)\n⚠️ 문제: 주니어가 Redis를 언제 왜 쓰는지
                                                모르는 채로 설치만 해두면 혼란\n⚠️ 문제: MVP에서 Redis가 정말
                                                필수인가?\n\n대안 검토:\n1. JWT Refresh Token → 초기에는 DB에 저장해도
                                                됨 (성능은 떨어지지만 동작함)\n2. Blacklist → 초기 MVP에서는 생략 가능
                                                (토큰 만료 시간만으로도 충분)\n3. Location 캐싱 → DB만으로도 충분히 빠름
                                                 (사용자 수가 많지 않으면)\n\n결론:\n- Redis는 \"성능 최적화\" 단계에서
                                                추가하는 것이 학습 관점에서 더 나을 수 있음\n- 또는 Redis를 쓴다면, 왜
                                                필요한지 명확히 설명하고 실제 사용 시점에 도입", thoughtNumber: 6,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 6,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "build.gradle의 의존성을 다시 확인해보자.\n\n현재 설정된
                                                의존성:\n- spring-boot-starter-validation ✅\n-
                                                spring-boot-starter-data-jpa ✅\n- spring-boot-starter-security ✅\n-
                                                spring-boot-starter-web ✅\n- lombok ✅\n- mysql-connector-j ✅\n- h2
                                                (테스트용) ✅\n\n제안에서 추가하려는 것:\n- JWT 라이브러리 (jjwt)\n-
                                                Redis (spring-boot-starter-data-redis)\n- WebFlux (카카오 API
                                                호출용)\n\n검토:\n✅ JWT는 필수\n⚠️ Redis는 앞서 검토했듯이 선택적\n✅
                                                WebFlux (WebClient)는 카카오 API 호출에 필요\n\n추가 고려사항:\n-
                                                RestTemplate vs WebClient: WebClient가 최신이지만 주니어에게는
                                                RestTemplate이 더 직관적일 수 있음\n- 하지만 RestTemplate은 deprecated
                                                예정이므로 WebClient 학습이 장기적으로 유리\n\n결론: 의존성 추가 계획은
                                                적절함", thoughtNumber: 7, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 7,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Location 도메인의 1시간 자동 만료 로직을
                                                검토해보자.\n\n제안된 구현:\n- LocationShare Entity에 startTime, endTime
                                                 저장\n- @Scheduled로 만료된 항목을 주기적으로 isActive = false로
                                                변경\n- Redis에도 TTL 1시간으로 캐싱\n\n검토:\n✅ startTime, endTime을
                                                DB에 저장하는 것은 좋음\n⚠️ @Scheduled로 배치 처리하는 방식의 문제점:\n
                                                 - 스케줄러가 5분마다 돌면, 만료 후 최대 5분 지연 발생\n  - 만료 시점이
                                                정확하지 않음\n  \n대안:\n1. 조회 시점에 endTime과 현재 시간을 비교
                                                (Lazy Evaluation)\n   - 장점: 정확함, 추가 스케줄러 불필요\n   - 단점:
                                                매번 시간 비교 필요\n   \n2. Redis TTL만 사용하고 DB는 로그용\n   -
                                                장점: Redis가 자동으로 만료 처리\n   - 단점: Redis 장애 시 데이터
                                                손실\n\nMVP 추천: \n- 방안 1 (조회 시점 검증)이 가장 단순하고 안정적\n-
                                                추가로 @Scheduled (1시간마다)로 정리하는 정도면 충분", thoughtNumber: 8,
                                                 totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 8,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "카카오 모빌리티 API 연동 부분을 검토해보자.\n\n제안된
                                                구현:\n- WebClient로 카카오 경로 API 호출\n- origin (친구 위치) →
                                                waypoints (경유지들) → destination (내 위치)\n- 결과로 소요 시간 및 경로
                                                 좌표 반환\n\n검토:\n✅ WebClient 사용은 적절함\n⚠️ 복잡도: 카카오 API는
                                                 여러 종류가 있고 문서가 복잡함\n⚠️ 비용: 카카오 모빌리티 API는 유료일
                                                수 있음\n\n확인 필요사항:\n1. 카카오 모빌리티 API vs 카카오맵 API
                                                차이\n2. 무료 티어 존재 여부\n3. Waypoints를 지원하는 API가
                                                맞는지\n\n대안:\n- 초기 MVP에서는 단순 직선거리 계산으로 시작\n- 나중에
                                                실제 API 연동\n- 또는 구글 Directions API 고려 (월 $200 무료
                                                크레딧)\n\n추천:\n- 일단 카카오 API 명세를 먼저 확인하고 계획 수정\n-
                                                MVP에서는 mock 데이터나 단순 계산으로 시작하는 것도 고려",
                                                thoughtNumber: 9, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 9,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "CI/CD 계획을 검토해보자.\n\n제안: GitHub Actions로 자동 빌드
                                                및 배포\n\n제안된 워크플로우:\n1. main 브랜치 push 시 트리거\n2. Gradle
                                                빌드\n3. Docker 이미지 빌드\n4. 서버로 SSH 접속하여 배포\n\n검토:\n⚠️
                                                문제: MVP 단계에서 CI/CD가 우선순위가 높은가?\n⚠️ 문제: SSH 키, 서버
                                                호스트 등의 인프라가 준비되어 있는가?\n⚠️ 문제: 주니어가 GitHub
                                                Actions를 처음 다룬다면 시간이 많이 소요될 수 있음\n\n대안:\n1. 초기에는
                                                 수동 배포 (jar 파일 빌드 후 서버에 업로드)\n2. 핵심 기능 완성 후 CI/CD
                                                추가\n3. 또는 더 간단한 방식: GitHub Actions로 빌드만 자동화 (배포는
                                                수동)\n\n우선순위 재조정:\n- Phase 1-8: 핵심 기능 구현\n- Phase 9: CI/CD
                                                 (선택사항, 시간 여유 있을 때)\n\n결론: CI/CD는 \"좋으면 하는 것\"이지
                                                MVP 필수는 아님", thoughtNumber: 10, totalThoughts: 15,
                                                nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 10,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "CLAUDE.md에서 프론트엔드 요구사항을 다시 확인해보자.\n\n핵심
                                                API 엔드포인트 (프론트에서 필요한 것):\n1. POST /api/auth/login,
                                                /api/auth/signup\n2. POST /api/location/start, /api/location/stop, PUT
                                                /api/location/update\n3. GET /api/friends, POST /api/friends/request,
                                                PUT /api/friends/:id/accept/reject\n4. GET /api/shuttle/routes, GET
                                                /api/shuttle/routes/:id/stops\n5. POST /api/shuttle/arrival-time\n6.
                                                검색 API: GET /api/shuttle/routes/search, GET
                                                /api/friends/search\n\n추가 필요한 API (제안에서 누락):\n❌ 친구 이름
                                                검색 API가 명시되어 있지만, 실제로는 \"이메일로 검색\"이 필요\n❌ GET
                                                /api/location/friends - 모든 친구들의 위치를 한번에 조회하는 API 필요\n
                                                  (현재는 GET /api/location/friend/:friendId로 한명씩만 조회
                                                가능)\n\n검토:\n- 프론트엔드 요구사항: \"친구 관계인 모든 유저의 위치
                                                마커 표시\"\n- 이를 위해서는 친구 목록 조회 → 각 친구의 위치 조회 (N+1
                                                문제 발생)\n- 더 나은 방법: GET /api/location/friends 엔드포인트로
                                                한번에 조회\n\n결론: Location API 설계에 보완 필요", thoughtNumber: 11,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 11,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Entity 설계를 다시 검토해보자.\n\nFriendship Entity:\n-
                                                requester (요청 보낸 사람)\n- receiver (요청 받은 사람)\n- status
                                                (PENDING, ACCEPTED, REJECTED)\n\n검토:\n✅ 기본 설계는 괜찮음\n⚠️ 쿼리
                                                복잡도: \"내 친구 목록\"을 조회하려면?\n  - WHERE (requester_id = 나 OR
                                                receiver_id = 나) AND status = ACCEPTED\n  - 양방향 관계 때문에 쿼리가
                                                복잡해짐\n\n대안:\n1. 현재 설계 유지 + Repository에서 복잡한 쿼리
                                                작성\n2. ACCEPTED 상태가 되면 양방향 레코드 2개 생성 (더 단순한 쿼리)\n
                                                  - (A→B, ACCEPTED), (B→A, ACCEPTED)\n   - 단점: 데이터 중복\n\n추천:\n-
                                                 방안 1 유지 (정규화)\n- JPA 쿼리 메서드 예시 제공 필요:\n  ```java\n
                                                @Query(\"SELECT f FROM Friendship f WHERE (f.requester.id = :userId OR
                                                f.receiver.id = :userId) AND f.status = 'ACCEPTED'\")\n
                                                List<Friendship> findMyFriends(@Param(\"userId\") Long userId);\n
                                                ```\n\n결론: Entity 설계는 괜찮지만 Repository 쿼리 예시 추가 필요",
                                                thoughtNumber: 12, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 12,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Validation 전략을 검토해보자.\n\n제안에서 Validation:\n-
                                                @Email, @NotBlank, @Pattern 등 Bean Validation 사용\n- SignUpRequest에서
                                                 비밀번호 정규식 검증\n\n검토:\n✅ Bean Validation 사용은 좋은 접근\n⚠️
                                                주의: 비밀번호 확인(password, passwordConfirm) 검증은?\n⚠️ 주의: 이메일
                                                중복 체크는 어디서?\n\n필요한 Validation 레이어:\n1. DTO 레벨: @Valid로
                                                기본 형식 검증\n2. Service 레벨: 비즈니스 로직 검증 (중복 체크 등)\n3.
                                                Custom Validator: 복잡한 검증 (비밀번호 일치 등)\n\n예시:\n```java\n//
                                                DTO\n@Getter\npublic class SignUpRequest {\n    @Email\n    private
                                                String email;\n    \n    @Pattern(regexp =
                                                \"^(?=.*[A-Za-z])(?=.*\\\\d)[A-Za-z\\\\d]{8,}$\")\n    private String
                                                password;\n    \n    private String passwordConfirm;\n}\n\n//
                                                Service\npublic void signUp(SignUpRequest request) {\n    // 비밀번호
                                                일치 검증\n    if
                                                (!request.getPassword().equals(request.getPasswordConfirm())) {\n
                                                 throw new BusinessException(ErrorCode.PASSWORD_NOT_MATCH);\n    }\n
                                                \n    // 이메일 중복 검증\n    if
                                                (userRepository.existsByEmail(request.getEmail())) {\n        throw new
                                                BusinessException(ErrorCode.DUPLICATE_EMAIL);\n    }\n
                                                ...\n}\n```\n\n결론: Validation 전략은 괜찮지만 더 구체적인 예시 필요",
                                                thoughtNumber: 13, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 13,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "학습 자료와 시간 예상을 검토해보자.\n\n제안된 총 소요 시간:
                                                2-3주\n\nPhase별 소요 시간:\n- Phase 0 (Docker): 1-2일\n- Phase 1
                                                (기반): 1일\n- Phase 2 (예외처리): 1일\n- Phase 3 (Security+JWT):
                                                2-3일\n- Phase 4-7 (도메인): 6-7일\n- Phase 8 (카카오 API): 2-3일\n-
                                                Phase 9 (CI/CD): 1-2일\n합계: 14-21일\n\n검토:\n⚠️ 문제: 주니어 개발자가
                                                 처음 Spring을 배우면서 진행한다면 2-3주는 매우 빡빡함\n⚠️ 문제: 학습
                                                시간이 고려되지 않음 (순수 개발 시간만 계산)\n⚠️ 문제: 디버깅, 오류 수정
                                                 시간 미포함\n\n현실적인 예상:\n- 학습하면서 개발: 3-4주\n- 오류 해결
                                                버퍼: +1주\n- 총 4-5주가 더 현실적\n\n또한:\n- 매일 풀타임으로 개발할 수
                                                 있는가?\n- SSAFY 교육 중이라면 병행해야 하므로 더 길어질 수
                                                있음\n\n결론: 시간 예상을 더 보수적으로 조정 필요", thoughtNumber: 14,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 14,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "전체 계획을 종합하여 개선안을 정리해보자.\n\n발견한 주요
                                                문제점:\n1. 개발 순서: 추상적인 것(예외처리, Security)을 먼저 하면 학습
                                                곡선이 가파름\n2. Redis: MVP에서 필수가 아닌데 초기부터 도입\n3.
                                                Security+JWT: User 도메인보다 먼저 구현할 수 없음\n4. API 누락: 친구들의
                                                 위치를 한번에 조회하는 API\n5. 시간 예상: 너무 낙관적 (학습 시간
                                                미포함)\n6. CI/CD: MVP 우선순위가 아님\n7. 카카오 API: 비용/복잡도 고려
                                                필요\n\n개선된 개발 순서 제안:\n1. **환경 설정** (1-2일): Docker MySQL
                                                (Redis는 나중에)\n2. **Shuttle 도메인** (1-2일): 가장 단순, JPA
                                                학습용\n3. **User 도메인 (인증 제외)** (2일): 기본 CRUD\n4. **공통
                                                인프라** (1일): 예외처리, Validation (필요성을 체감한 후)\n5. **Friend
                                                도메인** (2일): 연관관계 학습\n6. **Location 도메인** (2일): 위치 공유
                                                기본\n7. **Spring Security + JWT** (3-4일): 이제 적용\n8. **Arrival
                                                도메인** (2-3일): 카카오 API (또는 mock)\n9. **Redis 최적화** (1일):
                                                선택사항\n10. **CI/CD** (1-2일): 선택사항\n\n이 순서의 장점:\n- 단순한
                                                것부터 복잡한 것으로\n- 각 단계에서 동작하는 코드를 만들며 학습\n- 필수
                                                기능 우선, 최적화는 나중에", thoughtNumber: 15, totalThoughts: 15,
                                                nextThoughtNeeded: false)
  ⎿  {
       "thoughtNumber": 15,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● Sequential Thinking으로 계획을 점검한 결과, 몇 가지 중요한 문제점을 발견했습니다. 개선된 계획을 제시하겠습니다.

  ---
  🔍 Sequential Thinking 점검 결과

  ❌ 발견된 주요 문제점

  1. 개발 순서의 문제

  - 문제: 예외 처리, Security+JWT를 User 도메인보다 먼저 구현
  - 이유: 실제 도메인 로직 없이 추상적인 인프라만 만들면 테스트 불가능하고 학습 효과 낮음
  - 개선: 단순한 도메인부터 시작 → 필요성 체감 후 인프라 추가

  2. Redis의 시기상조

  - 문제: Phase 0에 Redis 설치하지만 실제 사용은 Phase 3, 6
  - 이유: MVP에서 Redis는 "성능 최적화"이지 필수가 아님
  - 개선: 일단 DB만으로 구현 → 나중에 Redis 추가 (또는 생략)

  3. 누락된 API

  - 문제: 프론트에서 "모든 친구의 위치"를 한번에 조회해야 하는데 API 없음
  - 개선: GET /api/location/friends 엔드포인트 추가 필요

  4. 비현실적인 일정

  - 문제: 2-3주 예상 (학습 시간 미포함, 디버깅 시간 미포함)
  - 개선: 현실적으로 4-5주 (주니어 + 학습 포함)

  5. CI/CD 우선순위

  - 문제: MVP 단계에서 CI/CD를 필수로 제안
  - 개선: 핵심 기능 완성 후 선택적으로 추가

  ---
  📋 개선된 개발 계획

  🎯 핵심 원칙 변경

  기존 계획 (Top-Down)

  인프라 구축 → 예외처리 → Security → 도메인

  개선된 계획 (Bottom-Up)

  단순 도메인 → 필요한 인프라 → 복잡한 기능 → 최적화

  이유: 주니어 개발자는 "동작하는 코드"를 빠르게 만들어보며 학습하는 것이 효과적

  ---
  🚀 새로운 개발 순서

  Phase 0: 환경 설정 (1-2일)

  목표: 최소한의 개발 환경 구축

  작업:
  1. Docker Compose로 MySQL만 구축 (Redis는 나중에)
  services:
    mysql:
      image: mysql:8.0
      ports: ["3306:3306"]
      environment:
        MYSQL_DATABASE: shuttle_tracker
  2. application.yml 기본 설정
  3. 프로젝트 실행 확인

  학습: Docker 기본, MySQL 연결

  ---
  Phase 1: Shuttle 도메인 (1-2일)

  목표: 가장 단순한 도메인으로 JPA 학습

  왜 먼저?
  - 다른 도메인과 독립적
  - 인증 불필요
  - CRUD 기본 학습에 최적

  작업:
  1. Entity 작성: ShuttleRoute, ShuttleStop
  2. Repository: @OneToMany 관계 학습
  3. Service: 기본 조회 로직
  4. Controller: REST API 작성
    - GET /api/shuttle/routes
    - GET /api/shuttle/routes/{id}/stops
    - GET /api/shuttle/routes/search?q={query}
  5. SQL로 초기 데이터 삽입

  학습:
  - JPA Entity, Repository 기본
  - @OneToMany 연관관계
  - Spring Web Controller
  - SQL 초기 데이터 로드

  결과: Postman으로 실제 동작하는 API 확인 가능!

  ---
  Phase 2: User 도메인 - 기본편 (2일)

  목표: 인증 없이 User CRUD 구현

  작업:
  1. Entity: User (email, password, name)
  2. Repository: 기본 메서드
  3. Service:
    - 회원가입 (비밀번호 BCrypt 암호화)
    - 이메일로 사용자 검색
    - 내 정보 조회
  4. Controller:
    - POST /api/users (회원가입)
    - GET /api/users/search?email={email} (검색)
    - GET /api/users/{id} (조회)

  학습:
  - BCryptPasswordEncoder
  - Bean Validation (@Email, @NotBlank)
  - DTO 패턴 (Request/Response 분리)

  보안은?: 일단 인증 없이 만들어봄 (학습용)

  ---
  Phase 3: 공통 인프라 구축 (1일)

  목표: 지금까지 개발하며 느낀 필요성을 해결

  작업:
  1. GlobalExceptionHandler
    - 지금까지 발생한 예외들을 한곳에서 처리
  2. ErrorCode Enum
  USER_NOT_FOUND(404, "U001", "사용자를 찾을 수 없습니다.")
  DUPLICATE_EMAIL(409, "U002", "이미 존재하는 이메일입니다.")
  3. ApiResponse 통일
  {
    "success": true,
    "data": {...},
    "error": null
  }
  4. BaseTimeEntity (createdAt, updatedAt)

  학습:
  - @ControllerAdvice
  - Custom Exception 설계

  왜 이제?: 실제 예외가 발생해봐야 필요성을 체감함

  ---
  Phase 4: Friend 도메인 (2일)

  목표: 연관관계 심화 학습

  작업:
  1. Entity: Friendship
    - @ManyToOne User requester
    - @ManyToOne User receiver
    - FriendshipStatus status
  2. Repository:
  @Query("SELECT f FROM Friendship f WHERE (f.requester.id = :userId OR f.receiver.id = :userId) AND f.status =
  'ACCEPTED'")
  List<Friendship> findMyFriends(@Param("userId") Long userId);
  3. Service: 친구 추가/수락/거절/삭제
  4. Controller:
    - GET /api/friends (내 친구 목록)
    - POST /api/friends/request
    - PUT /api/friends/{id}/accept
    - DELETE /api/friends/{id}

  학습:
  - 양방향 관계 처리
  - JPQL 작성
  - 복잡한 비즈니스 로직

  ---
  Phase 5: Location 도메인 (2일)

  목표: 위치 공유 로직 구현

  작업:
  1. Entity: LocationShare
  private LocalDateTime startTime;
  private LocalDateTime endTime; // startTime + 1시간
  private Boolean isActive;
  2. Service:
    - 위치 공유 시작/중지
    - 위치 업데이트
    - 중요: GET /api/location/friends (모든 친구 위치 한번에 조회)
    - 조회 시 endTime과 현재 시간 비교 (만료 검증)
  3. @Scheduled (1시간마다 만료된 데이터 정리)

  학습:
  - LocalDateTime 사용
  - @Scheduled 태스크
  - 효율적인 쿼리 (N+1 방지)

  ---
  Phase 6: Spring Security + JWT (3-4일)

  목표: 기존 API에 인증 추가

  왜 이제?:
  - User, Friend, Location이 모두 동작하는 상태
  - 이제 "보호"가 필요함을 체감

  작업:
  1. JWT 의존성 추가
  implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
  2. JwtTokenProvider 구현
  3. JwtAuthenticationFilter 구현
  4. SecurityConfig 작성
  .requestMatchers("/api/auth/**", "/api/shuttle/**").permitAll()
  .anyRequest().authenticated()
  5. 로그인 API 추가
    - POST /api/auth/login → JWT 발급
  6. 기존 API에 인증 적용

  학습:
  - Spring Security Architecture
  - JWT 토큰 생성/검증
  - Filter Chain

  Refresh Token은?:
  - 초기에는 Access Token만 (1일 TTL)
  - 나중에 필요하면 추가

  ---
  Phase 7: Arrival 도메인 (2-3일)

  목표: 도착 시간 예측

  작업:
  1. 카카오 API 조사
    - 비용 확인
    - API 명세 확인
    - 무료 대안 탐색
  2. WebClient 설정
  3. ArrivalTimeService 구현
  4. 대안: 초기에는 단순 거리 계산으로 mock
  // 하버사인 공식으로 직선거리 계산
  double distance = calculateDistance(friendLoc, myLoc);
  int estimatedMinutes = (int)(distance / 평균속도);

  학습:
  - WebClient 사용
  - 외부 API 연동
  - 에러 핸들링

  ---
  Phase 8: Redis 최적화 (선택, 1일)

  목표: 성능 개선

  Redis 도입 시점:
  - Refresh Token 저장
  - Location 데이터 캐싱 (TTL 1시간)

  작업:
  1. Docker Compose에 Redis 추가
  2. RedisUtil 구현
  3. LocationService에 캐싱 로직 추가

  왜 선택?: MVP에서 사용자가 많지 않으면 불필요

  ---
  Phase 9: CI/CD (선택, 1-2일)

  목표: 자동 배포

  작업:
  1. GitHub Actions 워크플로우
  2. Docker 이미지 빌드
  3. 서버 배포 자동화

  왜 선택?: 핵심 기능 완성이 우선

  ---
  📊 개선된 일정 예상

  | Phase | 내용             | 예상 소요 (주니어+학습) |
  |-------|----------------|----------------|
  | 0     | 환경 설정          | 1-2일           |
  | 1     | Shuttle 도메인    | 1-2일           |
  | 2     | User 도메인 기본    | 2일             |
  | 3     | 공통 인프라         | 1일             |
  | 4     | Friend 도메인     | 2일             |
  | 5     | Location 도메인   | 2일             |
  | 6     | Security + JWT | 3-4일           |
  | 7     | Arrival 도메인    | 2-3일           |
  | 8     | Redis (선택)     | 1일             |
  | 9     | CI/CD (선택)     | 1-2일           |
  | 버퍼    | 디버깅, 오류 수정     | 3-5일           |
  | 총계    |                | 4-5주 (현실적)     |

  ---
  ✅ MVP 필수 vs 선택

  필수 (3주 목표)

  - ✅ Phase 0-7 (Redis, CI/CD 제외)
  - ✅ JWT 인증
  - ✅ 핵심 도메인 기능
  - ✅ 예외 처리

  선택 (시간 여유 시)

  - ⭐ Redis 최적화
  - ⭐ CI/CD
  - ⭐ 실제 카카오 API 연동 (초기에는 mock 가능)
  - ⭐ WebSocket 실시간 업데이트

  ---
  📚 단계별 학습 자료

  Phase 1-2: JPA 기초

  - 김영한 - 자바 ORM 표준 JPA 프로그래밍 (인프런)
  - Spring Data JPA 공식 문서

  Phase 3: 예외 처리

  - Baeldung - Exception Handling in Spring
  - 우아한형제들 기술 블로그 - 예외 처리 전략

  Phase 4-5: JPA 심화

  - N+1 문제 해결
  - JPQL vs QueryDSL

  Phase 6: Spring Security

  - 김영한 - 스프링 시큐리티 (인프런)
  - JWT.io 공식 문서
  - Baeldung - Spring Security + JWT

  Phase 7: WebClient

  - Spring WebFlux 공식 문서
  - 카카오 모빌리티 API 문서

  ---
  💡 추가 개선 사항

  1. API 명세 보완

  // 추가 필요
  GET /api/location/friends          // 모든 친구 위치 한번에 조회
  GET /api/users/search?email={email} // 이메일로 사용자 검색

  2. Validation 강화

  // SignUpRequest에 추가
  private String passwordConfirm;

  // Service에서 검증
  if (!password.equals(passwordConfirm)) {
      throw new BusinessException(ErrorCode.PASSWORD_NOT_MATCH);
  }

  3. 위치 만료 로직 개선

  // 조회 시점에 검증 (Lazy Evaluation)
  public Optional<LocationShare> getActiveLocation(Long userId) {
      return locationShareRepository.findByUserId(userId)
          .filter(loc -> loc.getEndTime().isAfter(LocalDateTime.now()))
          .filter(LocationShare::getIsActive);
  }

  ---

╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Ready to code?                                                                                                       │
│                                                                                                                      │
│ Here is Claude's plan:                                                                                               │
│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │
│ │ Sequential Thinking 점검 완료 - 개선된 백엔드 개발 계획                                                          │ │
│ │                                                                                                                  │ │
│ │ 🔍 주요 개선 사항                                                                                                │ │
│ │                                                                                                                  │ │
│ │ 1. 개발 순서 대폭 수정 (Bottom-Up 접근)                                                                          │ │
│ │                                                                                                                  │ │
│ │ 기존: 인프라 → Security → 도메인개선: 단순 도메인 → 필요 인프라 → 복잡 기능                                      │ │
│ │                                                                                                                  │ │
│ │ 새로운 순서:                                                                                                     │ │
│ │ 1. Shuttle 도메인 (가장 단순, JPA 학습)                                                                          │ │
│ │ 2. User 도메인 기본 (인증 제외)                                                                                  │ │
│ │ 3. 공통 인프라 (필요성 체감 후)                                                                                  │ │
│ │ 4. Friend 도메인 (연관관계)                                                                                      │ │
│ │ 5. Location 도메인 (스케줄러)                                                                                    │ │
│ │ 6. Spring Security + JWT (이제 적용)                                                                             │ │
│ │ 7. Arrival 도메인 (카카오 API)                                                                                   │ │
│ │                                                                                                                  │ │
│ │ 이유: 주니어는 "동작하는 코드"를 빠르게 만들며 학습하는 것이 효과적                                              │ │
│ │                                                                                                                  │ │
│ │ 2. Redis를 선택사항으로 변경                                                                                     │ │
│ │                                                                                                                  │ │
│ │ - MVP에서 Redis는 "최적화"이지 필수 아님                                                                         │ │
│ │ - 초기에는 DB만으로 충분                                                                                         │ │
│ │ - Phase 8에서 선택적으로 추가                                                                                    │ │
│ │                                                                                                                  │ │
│ │ 3. CI/CD 우선순위 하향                                                                                           │ │
│ │                                                                                                                  │ │
│ │ - 핵심 기능 완성이 우선                                                                                          │ │
│ │ - Phase 9에서 선택사항으로                                                                                       │ │
│ │                                                                                                                  │ │
│ │ 4. 누락된 API 추가                                                                                               │ │
│ │                                                                                                                  │ │
│ │ - GET /api/location/friends (모든 친구 위치 한번에)                                                              │ │
│ │ - GET /api/users/search?email={email} (이메일 검색)                                                              │ │
│ │                                                                                                                  │ │
│ │ 5. 현실적인 일정 조정                                                                                            │ │
│ │                                                                                                                  │ │
│ │ 기존: 2-3주개선: 4-5주 (학습 시간 + 디버깅 버퍼 포함)                                                            │ │
│ │                                                                                                                  │ │
│ │ 📋 최종 개발 순서 (3주 MVP 목표)                                                                                 │ │
│ │                                                                                                                  │ │
│ │ Week 1: 기초 다지기                                                                                              │ │
│ │                                                                                                                  │ │
│ │ - Phase 0-2: 환경 + Shuttle + User 기본                                                                          │ │
│ │                                                                                                                  │ │
│ │ Week 2: 핵심 도메인                                                                                              │ │
│ │                                                                                                                  │ │
│ │ - Phase 3-5: 인프라 + Friend + Location                                                                          │ │
│ │                                                                                                                  │ │
│ │ Week 3: 인증 & 통합                                                                                              │ │
│ │                                                                                                                  │ │
│ │ - Phase 6-7: Security + JWT + Arrival                                                                            │ │
│ │                                                                                                                  │ │
│ │ Week 4-5: 여유분 (선택)                                                                                          │ │
│ │                                                                                                                  │ │
│ │ - Redis, CI/CD, 디버깅, 개선                                                                                     │ │
│ │                                                                                                                  │ │
│ │ 📚 학습 로드맵 명확화                                                                                            │ │
│ │                                                                                                                  │ │
│ │ 각 Phase마다 구체적인 학습 자료와 실습 목표 제시                                                                 │ │
│ │                                                                                                                  │ │
│ │ 이 개선된 계획으로 진행하시겠습니까?                                                                             │ │
│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │
│                                                                                                                      │
│ Would you like to proceed?                                                                                           │
│                                                                                                                      │
│ > 1. Yes, and auto-accept edits                                                                                      │
│   2. Yes, and manually approve edits                                                                                 │
│   3. No, keep planning                                                                                               │
│                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
ctrl-g to edit plan in start

╭─── Claude Code v2.0.26 ──────────────────────────────────────────────────────────────────────────────────────────────╮
│                                                    │ Tips for getting started                                        │
│               Welcome back jedo5000!               │ Run /install-github-app to tag @claude right from your Github … │
│                                                    │ √ Run /init to create a CLAUDE.md file with instructions for C… │
│                       ▐▛███▜▌                      │ ─────────────────────────────────────────────────────────────── │
│                      ▝▜█████▛▘                     │ Recent activity                                                 │
│                        ▘▘ ▝▝                       │ No recent activity                                              │
│                                                    │                                                                 │
│              Sonnet 4.5 · Claude Pro               │                                                                 │
│ C:\Users\SSAFY\projects\shuttle-tracker\shuttle-t… │                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

> # 백엔드

너는 java, Spring을 사용하는 우수기업의 10년차 시니어 백엔드 개발자야. 나는 아직 스프링에 대한 개념, 실력이 부족한
학생이고 프로젝트를 만들려해.

shuttle-tracker-be 프로젝트의 [CLAUDE.md](http://CLAUDE.md), DEVELOPMENT.md, FRONT_README.md, tree.txt를 읽고
프로젝트 파악을 해야함.

1. 프로젝트 세팅 → Springboot로 받고 gradle 설정했음. 코딩 컨벤션 숙지
2. Docker로 MySQL과 Redis Container 만들어서 사용하기, Docker 사용하는 법 공부해야함.
3. git action으로 CI/CD 구축하기
4. 구조 세팅 → domain 별 디렉토리 구조 채택 / 그리고 주니어 개발자로서 내가 백엔드를 어떤 순서대로 무엇을 설계하고
구현해야할지 잘 모르겠어. 알려줬으면 좋겠어.
    1. Entity 설계
    2. Spring security, redis + jwt 사용
    3. tree.txt의 과거 프로젝트 구조와 비슷한 구조로 프로젝트 진행 예정
    4. exceptionhandler, exception, validation 등등 필요한 것들을 넣고 학습할 예정(but MVP 프로젝트이고 바로
서비스해야하므로 과한건 빼고싶음. 추천 부탁함.)
    5. JPA 활용

너가 직접 코드를 짜는게 아닌 아키텍쳐를 어떻게 설계해야하는지, (너무 전 프로젝트를 무조건 따를 필요는 없어. ) 어떻게
 내가 이것들을 구현해 나가야하는지, 무엇을 공부하고 참고해야하는지를 계획 세운걸 받고싶어.

● 프로젝트 파악을 위해 관련 문서들을 먼저 읽어보겠습니다.

● Read(CLAUDE.md)
  ⎿  Read 141 lines

● Read(DEVELOPMENT.md)
  ⎿  Read 385 lines

● Read(FRONT_README.md)
  ⎿  Read 153 lines

● Read(tree.txt)
  ⎿  Read 138 lines

● 현재 프로젝트의 상태를 추가로 확인하겠습니다.

● Search(pattern: "**/*.gradle")
  ⎿  Found 2 files (ctrl+o to expand)

● Search(pattern: "**/application*.yml")
  ⎿  Found 2 files (ctrl+o to expand)

● Search(pattern: "**/application*.properties")
  ⎿  Found 0 files

● Read(build.gradle)
  ⎿  Read 45 lines

● Read(src\main\resources\application.yml)
  ⎿  Read 16 lines

● Search(pattern: "src/main/java/**/*.java")
  ⎿  Found 1 file (ctrl+o to expand)

● 좋습니다! 프로젝트 파악을 완료했습니다. 이제 SSAFY 셔틀 버스 위치 추적 서비스의 백엔드 아키텍처와 개발 계획을
  제시하겠습니다.

  ---
  🎯 SSAFY 셔틀 트래커 백엔드 아키텍처 & 개발 로드맵

  📊 프로젝트 현황 분석

  ✅ 완료된 것

  - Spring Boot 3.5.7 + Gradle 프로젝트 세팅
  - 기본 의존성: JPA, Security, Validation, MySQL, Lombok
  - application.yml 기본 구조 (주석 처리)

  🔧 진행 필요

  1. Docker를 통한 MySQL + Redis 인프라 구축
  2. 도메인별 계층 구조 설계 및 구현
  3. Spring Security + JWT + Redis 인증 시스템
  4. 핵심 비즈니스 로직 구현
  5. CI/CD (GitHub Actions)

  ---
  🏗️ 1. 아키텍처 설계

  1.1 계층 구조 (Layered Architecture)

  이전 프로젝트와 동일한 도메인 기반 구조를 채택하되, MVP에 맞게 단순화합니다.

  src/main/java/com/ssafy/shuttle_tracker/
  ├── domain/
  │   ├── user/                     # 사용자 도메인
  │   │   ├── controller/
  │   │   │   └── UserController.java
  │   │   ├── dto/
  │   │   │   ├── request/
  │   │   │   │   ├── SignUpRequest.java
  │   │   │   │   ├── LoginRequest.java
  │   │   │   │   └── PasswordChangeRequest.java
  │   │   │   └── response/
  │   │   │       └── UserInfoResponse.java
  │   │   ├── entity/
  │   │   │   └── User.java
  │   │   ├── repository/
  │   │   │   └── UserRepository.java
  │   │   └── service/
  │   │       └── UserService.java
  │   │
  │   ├── friend/                   # 친구 관계 도메인
  │   │   ├── controller/
  │   │   ├── dto/
  │   │   ├── entity/
  │   │   │   └── Friendship.java
  │   │   ├── repository/
  │   │   └── service/
  │   │
  │   ├── location/                 # 위치 공유 도메인
  │   │   ├── controller/
  │   │   ├── dto/
  │   │   ├── entity/
  │   │   │   └── LocationShare.java
  │   │   ├── repository/
  │   │   └── service/
  │   │
  │   ├── shuttle/                  # 셔틀 버스 도메인
  │   │   ├── controller/
  │   │   ├── dto/
  │   │   ├── entity/
  │   │   │   ├── ShuttleRoute.java
  │   │   │   └── ShuttleStop.java
  │   │   ├── repository/
  │   │   └── service/
  │   │
  │   └── arrival/                  # 도착 시간 예측 도메인
  │       ├── controller/
  │       ├── dto/
  │       └── service/
  │           └── ArrivalTimeService.java  # 카카오 API 호출
  │
  └── global/
      ├── config/
      │   ├── SecurityConfig.java
      │   ├── RedisConfig.java
      │   ├── WebConfig.java         # CORS 설정
      │   └── JpaConfig.java
      ├── security/
      │   ├── jwt/
      │   │   ├── JwtTokenProvider.java
      │   │   ├── JwtAuthenticationFilter.java
      │   │   └── JwtProperties.java
      │   └── auth/
      │       ├── CustomUserDetails.java
      │       └── CustomUserDetailsService.java
      ├── error/
      │   ├── exception/
      │   │   ├── BusinessException.java
      │   │   ├── ErrorCode.java
      │   │   └── (각 도메인별 커스텀 Exception)
      │   └── GlobalExceptionHandler.java
      ├── common/
      │   ├── response/
      │   │   ├── ApiResponse.java
      │   │   └── ErrorResponse.java
      │   └── constants/
      │       └── Constants.java
      └── util/
          └── RedisUtil.java

  1.2 핵심 설계 원칙

  1. 도메인 중심 설계: 각 도메인은 독립적으로 동작 가능
  2. 단방향 의존성: Controller → Service → Repository
  3. DTO 분리: Entity 직접 노출 금지, Request/Response DTO 사용
  4. 예외 처리 통일: GlobalExceptionHandler로 중앙 관리
  5. API 응답 통일: ApiResponse 래퍼 클래스 사용

  ---
  🗄️ 2. 데이터베이스 설계

  2.1 핵심 엔티티

  User (사용자)

  @Entity
  @Table(name = "users")
  public class User extends BaseTimeEntity {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(unique = true, nullable = false)
      private String email;

      @Column(nullable = false)
      private String password;  // BCrypt 암호화

      @Column(nullable = false)
      private String name;

      @Column(nullable = false)
      private Boolean locationShareAgree = false;

      @Enumerated(EnumType.STRING)
      private Role role;  // USER, ADMIN
  }

  Friendship (친구 관계)

  @Entity
  public class Friendship extends BaseTimeEntity {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "requester_id")
      private User requester;  // 요청 보낸 사람

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "receiver_id")
      private User receiver;  // 요청 받은 사람

      @Enumerated(EnumType.STRING)
      private FriendshipStatus status;  // PENDING, ACCEPTED, REJECTED
  }

  LocationShare (위치 공유)

  @Entity
  public class LocationShare {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "user_id")
      private User user;

      @Column(nullable = false)
      private Double latitude;

      @Column(nullable = false)
      private Double longitude;

      @Column(nullable = false)
      private LocalDateTime startTime;

      @Column(nullable = false)
      private LocalDateTime endTime;  // 1시간 후

      @Column(nullable = false)
      private Boolean isActive = true;
  }

  ShuttleRoute (셔틀 노선)

  @Entity
  public class ShuttleRoute extends BaseTimeEntity {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(nullable = false)
      private String name;  // "1호차", "2호차"

      @Column(length = 500)
      private String description;

      @OneToMany(mappedBy = "route", cascade = CascadeType.ALL)
      private List<ShuttleStop> stops = new ArrayList<>();
  }

  ShuttleStop (경유지)

  @Entity
  public class ShuttleStop {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "route_id")
      private ShuttleRoute route;

      @Column(nullable = false)
      private String name;  // "광주역", "광주송정역"

      @Column(nullable = false)
      private Double latitude;

      @Column(nullable = false)
      private Double longitude;

      @Column(nullable = false)
      private Integer stopOrder;  // 순서 (1, 2, 3...)
  }

  2.2 BaseTimeEntity (공통 시간 필드)

  @MappedSuperclass
  @EntityListeners(AuditingEntityListener.class)
  public abstract class BaseTimeEntity {
      @CreatedDate
      @Column(updatable = false)
      private LocalDateTime createdAt;

      @LastModifiedDate
      private LocalDateTime updatedAt;
  }

  ---
  🔐 3. Spring Security + JWT + Redis 인증 시스템

  3.1 JWT 기반 인증 플로우

  1. 로그인 → JWT Access Token (1시간) + Refresh Token (7일) 발급
  2. Access Token을 Authorization Header에 포함하여 요청
  3. JwtAuthenticationFilter에서 토큰 검증
  4. 토큰 만료 시 Refresh Token으로 재발급
  5. Refresh Token은 Redis에 저장 (TTL: 7일)

  3.2 필요한 의존성 추가

  dependencies {
      // JWT
      implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
      runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.3'
      runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.3'

      // Redis
      implementation 'org.springframework.boot:spring-boot-starter-data-redis'

      // 카카오 API 호출
      implementation 'org.springframework.boot:spring-boot-starter-webflux'

      // (선택) WebSocket (추후 실시간 위치 업데이트용)
      // implementation 'org.springframework.boot:spring-boot-starter-websocket'
  }

  3.3 SecurityConfig 구조

  @Configuration
  @EnableWebSecurity
  @EnableMethodSecurity
  public class SecurityConfig {

      @Bean
      public SecurityFilterChain filterChain(HttpSecurity http) {
          return http
              .csrf(csrf -> csrf.disable())
              .cors(cors -> cors.configurationSource(corsConfigurationSource()))
              .sessionManagement(session ->
                  session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
              .authorizeHttpRequests(auth -> auth
                  .requestMatchers("/api/auth/**").permitAll()
                  .anyRequest().authenticated()
              )
              .addFilterBefore(jwtAuthenticationFilter,
                  UsernamePasswordAuthenticationFilter.class)
              .exceptionHandling(exception -> exception
                  .authenticationEntryPoint(jwtAuthenticationEntryPoint)
              )
              .build();
      }
  }

  ---
  📝 4. 개발 순서 및 단계별 학습 가이드

  Phase 0: 인프라 구축 (1-2일)

  목표: Docker로 MySQL과 Redis 환경 구축

  작업 내용

  1. Docker Compose 작성
  # docker-compose.yml
  version: '3.8'
  services:
    mysql:
      image: mysql:8.0
      container_name: shuttle-mysql
      environment:
        MYSQL_ROOT_PASSWORD: root1234
        MYSQL_DATABASE: shuttle_tracker
      ports:
        - "3306:3306"
      volumes:
        - mysql-data:/var/lib/mysql

    redis:
      image: redis:7-alpine
      container_name: shuttle-redis
      ports:
        - "6379:6379"
      volumes:
        - redis-data:/data

  volumes:
    mysql-data:
    redis-data:

  2. application.yml 설정
  spring:
    datasource:
      url: jdbc:mysql://localhost:3306/shuttle_tracker
      username: root
      password: root1234
    jpa:
      hibernate:
        ddl-auto: create  # 개발: create, 운영: validate
      show-sql: true
      properties:
        hibernate:
          format_sql: true
    redis:
      host: localhost
      port: 6379

  학습 자료

  - Docker 기본 개념: https://docs.docker.com/get-started/
  - Docker Compose: https://docs.docker.com/compose/

  ---
  Phase 1: 프로젝트 기반 설정 (1일)

  목표: 공통 설정 및 구조 준비

  작업 내용

  1. 패키지 구조 생성 (위 1.1 구조 참고)
  2. Global 설정 클래스
    - WebConfig (CORS)
    - JpaConfig (Auditing)
  3. 공통 응답 DTO
    - ApiResponse
    - ErrorResponse
  4. BaseTimeEntity 작성

  학습 자료

  - Spring Boot 패키지 구조 Best Practice
  - JPA Auditing: https://docs.spring.io/spring-data/jpa/reference/auditing.html

  ---
  Phase 2: 예외 처리 시스템 구축 (1일)

  목표: 통일된 예외 처리 체계 구축

  작업 내용

  1. ErrorCode Enum
  @Getter
  @RequiredArgsConstructor
  public enum ErrorCode {
      // 공통
      INVALID_INPUT_VALUE(400, "C001", "잘못된 입력값입니다."),
      UNAUTHORIZED(401, "C002", "인증이 필요합니다."),

      // User
      USER_NOT_FOUND(404, "U001", "사용자를 찾을 수 없습니다."),
      DUPLICATE_EMAIL(409, "U002", "이미 존재하는 이메일입니다."),
      INVALID_PASSWORD(400, "U003", "비밀번호가 일치하지 않습니다."),

      // Friend
      FRIENDSHIP_NOT_FOUND(404, "F001", "친구 관계를 찾을 수 없습니다."),
      ALREADY_FRIENDS(409, "F002", "이미 친구 관계입니다."),

      // Location
      LOCATION_SHARE_NOT_ACTIVE(400, "L001", "위치 공유가 활성화되지 않았습니다.");

      private final int status;
      private final String code;
      private final String message;
  }

  2. BusinessException
  3. GlobalExceptionHandler

  학습 자료

  - Spring @ControllerAdvice: https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc
  - Custom Exception 설계 패턴

  ---
  Phase 3: Spring Security + JWT 구현 (2-3일)

  목표: 인증/인가 시스템 완성

  작업 순서

  1. JwtTokenProvider 구현
    - Access Token 생성 (1시간)
    - Refresh Token 생성 (7일)
    - 토큰 검증
    - 토큰에서 사용자 정보 추출
  2. RedisUtil 구현
    - Refresh Token 저장
    - Blacklist (로그아웃된 토큰) 관리
  3. JwtAuthenticationFilter 구현
    - Authorization 헤더에서 토큰 추출
    - 토큰 검증
    - SecurityContext에 인증 정보 저장
  4. CustomUserDetailsService 구현
  5. SecurityConfig 작성

  학습 자료

  - JWT 개념: https://jwt.io/introduction
  - Spring Security Architecture: https://spring.io/guides/topicals/spring-security-architecture
  - Redis 기본: https://redis.io/docs/getting-started/

  ---
  Phase 4: User 도메인 구현 (2일)

  목표: 회원가입, 로그인, 사용자 정보 관리

  작업 순서

  1. Entity 작성: User.java
  2. Repository 작성: UserRepository.java
  3. Service 작성: UserService.java
    - 회원가입 (비밀번호 BCrypt 암호화)
    - 로그인 (JWT 발급)
    - 내 정보 조회
    - 비밀번호 변경
    - 위치 공유 동의 설정
  4. Controller 작성: UserController.java
    - POST /api/auth/signup
    - POST /api/auth/login
    - GET /api/auth/me
    - PUT /api/auth/password
    - PUT /api/auth/location-share-agree

  DTO 예시

  // Request
  @Getter
  @NoArgsConstructor
  public class SignUpRequest {
      @Email(message = "이메일 형식이 올바르지 않습니다.")
      @NotBlank
      private String email;

      @NotBlank
      @Pattern(regexp = "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,}$",
               message = "비밀번호는 8자 이상, 영문과 숫자를 포함해야 합니다.")
      private String password;

      @NotBlank
      private String name;
  }

  // Response
  @Getter
  @Builder
  public class LoginResponse {
      private String accessToken;
      private String refreshToken;
      private UserInfoResponse user;
  }

  학습 자료

  - Spring Data JPA: https://spring.io/projects/spring-data-jpa
  - Bean Validation: https://beanvalidation.org/
  - BCrypt 암호화: BCryptPasswordEncoder

  ---
  Phase 5: Friend 도메인 구현 (1-2일)

  목표: 친구 추가, 수락, 거절, 삭제

  작업 순서

  1. Entity: Friendship.java
  2. Repository: FriendshipRepository.java
    - 쿼리 메서드: findByRequesterAndReceiver, findAllByStatus 등
  3. Service: FriendshipService.java
  4. Controller: FriendshipController.java
    - GET /api/friends (ACCEPTED만)
    - POST /api/friends/request
    - PUT /api/friends/{id}/accept
    - PUT /api/friends/{id}/reject
    - DELETE /api/friends/{id}
    - GET /api/friends/pending

  학습 자료

  - JPA 연관관계 매핑: @ManyToOne, @OneToMany
  - JPQL 쿼리 작성

  ---
  Phase 6: Location 도메인 구현 (2일)

  목표: 위치 공유 시작/중지, 실시간 위치 업데이트

  작업 순서

  1. Entity: LocationShare.java
  2. Repository: LocationShareRepository.java
  3. Service: LocationService.java
    - 위치 공유 시작 (1시간 TTL 설정)
    - 위치 공유 중지
    - 내 위치 업데이트 (Redis에도 캐싱)
    - 친구 위치 조회
    - 스케줄러: 만료된 위치 공유 자동 비활성화
  4. Controller: LocationController.java

  중요 로직

  // 위치 공유 시작
  public void startSharing(Long userId, Double lat, Double lng) {
      LocalDateTime now = LocalDateTime.now();
      LocationShare locationShare = LocationShare.builder()
          .user(userRepository.findById(userId).orElseThrow())
          .latitude(lat)
          .longitude(lng)
          .startTime(now)
          .endTime(now.plusHours(1))  // 1시간 후 만료
          .isActive(true)
          .build();

      locationShareRepository.save(locationShare);

      // Redis에도 캐싱 (TTL: 1시간)
      redisUtil.setDataExpire("location:" + userId, locationShare, 3600);
  }

  학습 자료

  - Spring @Scheduled: https://spring.io/guides/gs/scheduling-tasks/
  - Redis TTL 설정

  ---
  Phase 7: Shuttle 도메인 구현 (1일)

  목표: 셔틀 노선 및 경유지 관리

  작업 순서

  1. Entity: ShuttleRoute.java, ShuttleStop.java
  2. Repository: ShuttleRouteRepository.java, ShuttleStopRepository.java
  3. Service: ShuttleService.java
    - 모든 노선 조회
    - 특정 노선의 경유지 조회 (stopOrder 순서대로)
    - 노선 검색
  4. Controller: ShuttleController.java

  초기 데이터 삽입

  -- sql/init-data.sql
  INSERT INTO shuttle_route (name, description) VALUES
  ('1호차', 'SSAFY 광주 1호차'),
  ('2호차', 'SSAFY 광주 2호차');

  INSERT INTO shuttle_stop (route_id, name, latitude, longitude, stop_order) VALUES
  (1, '광주역', 35.1160, 126.9172, 1),
  (1, '광주송정역', 35.1390, 126.7938, 2),
  (1, 'SSAFY 광주캠퍼스', 35.2019, 126.8095, 3);

  학습 자료

  - JPA @OneToMany 관계 설정
  - SQL 초기 데이터 로드: data.sql

  ---
  Phase 8: Arrival 도메인 구현 (2-3일)

  목표: 카카오 모빌리티 API 연동 및 도착 시간 예측

  작업 순서

  1. ArrivalTimeService 구현
    - 카카오 모빌리티 API 호출 (WebClient 사용)
    - 친구 위치 → 경유지 → 내 위치 경로 계산
    - 도착 시간 예측
  2. Controller: ArrivalController.java
    - POST /api/shuttle/arrival-time

  카카오 API 호출 예시

  @Service
  @RequiredArgsConstructor
  public class ArrivalTimeService {

      private final WebClient kakaoWebClient;

      @Value("${kakao.mobility.api-key}")
      private String kakaoApiKey;

      public ArrivalTimeResponse calculateArrivalTime(
          Long friendId,
          Location myLocation,
          List<Long> stopIds
      ) {
          // 1. 친구 위치 조회
          LocationShare friendLocation = locationShareRepository
              .findActiveByUserId(friendId)
              .orElseThrow(() -> new BusinessException(ErrorCode.LOCATION_SHARE_NOT_ACTIVE));

          // 2. 경유지 좌표 조회
          List<ShuttleStop> stops = shuttleStopRepository.findAllById(stopIds);

          // 3. 카카오 API로 경로 및 시간 계산
          String origin = friendLocation.getLatitude() + "," + friendLocation.getLongitude();
          String destination = myLocation.getLat() + "," + myLocation.getLng();
          String waypoints = stops.stream()
              .map(s -> s.getLatitude() + "," + s.getLongitude())
              .collect(Collectors.joining("|"));

          KakaoRouteResponse kakaoResponse = kakaoWebClient.get()
              .uri(uriBuilder -> uriBuilder
                  .path("/v1/waypoints/directions")
                  .queryParam("origin", origin)
                  .queryParam("destination", destination)
                  .queryParam("waypoints", waypoints)
                  .build())
              .header("Authorization", "KakaoAK " + kakaoApiKey)
              .retrieve()
              .bodyToMono(KakaoRouteResponse.class)
              .block();

          // 4. 응답 가공
          int durationMinutes = kakaoResponse.getDuration() / 60;
          LocalDateTime estimatedArrival = LocalDateTime.now().plusMinutes(durationMinutes);

          return ArrivalTimeResponse.builder()
              .routeName(stops.get(0).getRoute().getName())
              .estimatedMinutes(durationMinutes)
              .estimatedArrivalTime(estimatedArrival)
              .routePath(kakaoResponse.getCoordinates())
              .build();
      }
  }

  학습 자료

  - Spring WebClient: https://docs.spring.io/spring-framework/reference/web/webflux-webclient.html
  - 카카오 모빌리티 API: https://developers.kakaomobility.com/

  ---
  Phase 9: CI/CD 구축 (1-2일)

  목표: GitHub Actions로 자동 빌드 및 배포

  GitHub Actions Workflow

  # .github/workflows/deploy.yml
  name: Deploy to Server

  on:
    push:
      branches: [ main ]

  jobs:
    build-and-deploy:
      runs-on: ubuntu-latest

      steps:
      - uses: actions/checkout@v3

      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build with Gradle
        run: ./gradlew clean build -x test

      - name: Build Docker image
        run: docker build -t shuttle-tracker-be .

      - name: Push to Docker Hub (선택)
        # Docker Hub에 푸시하는 단계

      - name: Deploy to Server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            cd /app/shuttle-tracker
            docker-compose down
            docker-compose pull
            docker-compose up -d

  Dockerfile

  FROM openjdk:21-jdk-slim
  ARG JAR_FILE=build/libs/*.jar
  COPY ${JAR_FILE} app.jar
  EXPOSE 8080
  ENTRYPOINT ["java", "-jar", "/app.jar"]

  학습 자료

  - GitHub Actions: https://docs.github.com/en/actions
  - Docker 이미지 빌드: https://docs.docker.com/engine/reference/builder/

  ---
  🎯 5. MVP에서 제외할 것 (과한 것들)

  ❌ 제외 추천

  1. WebSocket 실시간 업데이트
    - 이유: 프론트가 새로고침 방식 채택
    - 나중에 추가 가능
  2. Admin 기능
    - 이유: 초기에는 직접 DB 관리
    - 노선/경유지는 SQL로 직접 삽입
  3. 소셜 로그인 (OAuth2)
    - 이유: 이메일/비밀번호 방식으로 충분
    - 나중에 추가 가능
  4. 이메일 인증
    - 이유: 내부 서비스 (SSAFY 교육생 대상)
  5. 복잡한 로깅 시스템 (ELK Stack)
    - 이유: 초기에는 Spring Boot 기본 로깅으로 충분
  6. 다중 프로필 환경 분리 (dev/prod/local)
    - 이유: 초기에는 application.yml 하나로 시작
    - 필요시 application-prod.yml 추가
  7. 복잡한 테스트 코드
    - 이유: MVP는 핵심 기능 위주 단위 테스트만
    - 통합 테스트는 시간 여유 있을 때

  ✅ 꼭 포함해야 할 것

  1. JWT + Redis 인증 (보안 기본)
  2. GlobalExceptionHandler (에러 처리 통일)
  3. Validation (입력값 검증)
  4. CORS 설정 (프론트 연동 필수)
  5. Docker Compose (개발 환경 통일)
  6. 기본 CI/CD (자동 배포)

  ---
  📚 6. 학습 자료 총정리

  필수 학습

  1. Spring Boot 기본
    - 공식 문서: https://spring.io/projects/spring-boot
    - 인프런 - 김영한의 스프링 부트 (추천)
  2. Spring Data JPA
    - 공식 문서: https://spring.io/projects/spring-data-jpa
    - 연관관계 매핑, JPQL
  3. Spring Security + JWT
    - Spring Security 공식 문서
    - JWT.io 이해하기
    - 블로그: "Spring Boot 3 + JWT 인증 구현"
  4. Docker
    - Docker 공식 튜토리얼
    - Docker Compose 사용법
  5. Redis
    - Redis 공식 문서 - Getting Started
    - Spring Data Redis 사용법

  참고 자료

  - 우아한형제들 기술 블로그
  - 카카오 기술 블로그
  - Baeldung (Spring 관련 튜토리얼)

  ---
  🚀 7. 개발 일정 (예상)

  | Phase | 내용                    | 예상 소요 시간 |
  |-------|-----------------------|----------|
  | 0     | Docker 인프라 구축         | 1-2일     |
  | 1     | 프로젝트 기반 설정            | 1일       |
  | 2     | 예외 처리 시스템             | 1일       |
  | 3     | Spring Security + JWT | 2-3일     |
  | 4     | User 도메인              | 2일       |
  | 5     | Friend 도메인            | 1-2일     |
  | 6     | Location 도메인          | 2일       |
  | 7     | Shuttle 도메인           | 1일       |
  | 8     | Arrival 도메인 (카카오 API) | 2-3일     |
  | 9     | CI/CD 구축              | 1-2일     |
  | 총계    |                       | 약 2-3주   |

  ---
  💡 8. 개발 팁

  8.1 코딩 컨벤션

  - 클래스명: PascalCase (UserService)
  - 메서드명: camelCase (findUserById)
  - 상수: UPPER_SNAKE_CASE (MAX_LOGIN_ATTEMPTS)
  - 패키지: 소문자 (com.ssafy.shuttle_tracker)

  8.2 Git Commit 메시지

  feat: 새로운 기능 추가
  fix: 버그 수정
  refactor: 코드 리팩토링
  docs: 문서 수정
  test: 테스트 코드 추가
  chore: 빌드 설정 등

  예시: feat: User 도메인 회원가입 API 구현

  8.3 디버깅 팁

  - Postman으로 API 테스트
  - H2 Console로 개발 초기 DB 확인
  - Spring Boot Actuator (선택)

  ---
  ⎿  User rejected Claude's plan:
     ╭───────────────────────────────────────────────────────────────────────────────────╮
     │ SSAFY 셔틀 트래커 백엔드 개발 계획                                                │
     │                                                                                   │
     │ 📋 아키텍처 설계                                                                  │
     │                                                                                   │
     │ - 도메인 중심 계층 구조: User, Friend, Location, Shuttle, Arrival 도메인으로 분리 │
     │ - 이전 프로젝트와 유사한 구조: controller/dto/entity/repository/service 패턴 채택 │
     │ - MVP 원칙: 필수 기능만 구현 (WebSocket, Admin, OAuth2 제외)                      │
     │                                                                                   │
     │ 🛠️ 기술 스택                                                                     │
     │                                                                                   │
     │ - Spring Boot 3.5.7 + JPA + Spring Security                                       │
     │ - MySQL (Docker) + Redis (Docker)                                                 │
     │ - JWT 인증 (Access Token 1시간, Refresh Token 7일)                                │
     │ - 카카오 모빌리티 API (도착 시간 예측)                                            │
     │ - GitHub Actions (CI/CD)                                                          │
     │                                                                                   │
     │ 📝 개발 순서 (총 2-3주 예상)                                                      │
     │                                                                                   │
     │ Phase 0-2: 기반 구축 (3-4일)                                                      │
     │                                                                                   │
     │ 1. Docker Compose로 MySQL + Redis 구축                                            │
     │ 2. 패키지 구조 생성 (domain별 계층 분리)                                          │
     │ 3. GlobalExceptionHandler, ErrorCode, ApiResponse 등 공통 설정                    │
     │                                                                                   │
     │ Phase 3: 인증 시스템 (2-3일)                                                      │
     │                                                                                   │
     │ - Spring Security + JWT + Redis 구현                                              │
     │ - JwtTokenProvider, JwtAuthenticationFilter, SecurityConfig                       │
     │                                                                                   │
     │ Phase 4-7: 핵심 도메인 구현 (6-7일)                                               │
     │                                                                                   │
     │ - User: 회원가입, 로그인, 정보 수정                                               │
     │ - Friend: 친구 추가/수락/거절/삭제                                                │
     │ - Location: 위치 공유 시작/중지, 1시간 자동 만료                                  │
     │ - Shuttle: 노선 및 경유지 조회                                                    │
     │                                                                                   │
     │ Phase 8: 카카오 API 연동 (2-3일)                                                  │
     │                                                                                   │
     │ - WebClient로 카카오 모빌리티 API 호출                                            │
     │ - 도착 시간 예측 로직 구현                                                        │
     │                                                                                   │
     │ Phase 9: CI/CD (1-2일)                                                            │
     │                                                                                   │
     │ - GitHub Actions Workflow 설정                                                    │
     │ - Docker 이미지 빌드 및 자동 배포                                                 │
     │                                                                                   │
     │ 📚 학습 필요 항목                                                                 │
     │                                                                                   │
     │ - Docker & Docker Compose 기본                                                    │
     │ - Spring Security + JWT 인증 구조                                                 │
     │ - Spring Data JPA 연관관계 매핑                                                   │
     │ - Redis 기본 사용법 (TTL, 캐싱)                                                   │
     │ - WebClient를 통한 외부 API 호출                                                  │
     │                                                                                   │
     │ ✅ MVP에 포함                                                                      │
     │                                                                                   │
     │ - JWT + Redis 인증, 예외 처리, Validation, CORS, Docker, 기본 CI/CD               │
     │                                                                                   │
     │ ❌ MVP에서 제외                                                                    │
     │                                                                                   │
     │ - WebSocket, Admin 기능, 소셜 로그인, 이메일 인증, ELK Stack, 복잡한 테스트       │
     │                                                                                   │
     │ ---                                                                               │
     │ 이 계획으로 진행해도 될까요? 구체적인 질문이나 수정 사항이 있으면 말씀해주세요!   │
     ╰───────────────────────────────────────────────────────────────────────────────────╯

> 아 깜빡했다. 지금 세우고 있는 계획 Sequential Thinking MCP 사용해서 한 번 더 점검해줘.

● Sequential Thinking으로 계획을 점검하겠습니다.

● sequential-thinking - sequentialthinking (MCP)(thought: "SSAFY 셔틀 트래커 백엔드 프로젝트의 요구사항을
                                                정리해보자.\n\n핵심 기능:\n1. 사용자 인증 (회원가입, 로그인, JWT)\n2.
                                                친구 관리 (추가, 수락, 거절, 삭제)\n3. 위치 공유 (1시간 자동 만료,
                                                ON/OFF)\n4. 셔틀 노선 및 경유지 조회\n5. 도착 시간 예측 (카카오 API
                                                연동)\n\n기술 스택:\n- Spring Boot 3.5.7, JPA, Spring Security\n- MySQL
                                                + Redis (Docker)\n- JWT 인증\n- 카카오 모 il리티 API\n\n프로젝트
                                                특징:\n- MVP 프로젝트 (빠른 서비스 출시 필요)\n- 주니어 개발자 대상\n-
                                                이전 프로젝트 구조 참고 (domain별 계층 구조)\n\n계획 검증을 위해
                                                고려해야 할 관점:\n1. 개발 순서의 적절성\n2. 학습 곡선 고려\n3. MVP
                                                범위의 적절성\n4. 기술 스택의 타당성\n5. 놓친 요구사항은 없는지",
                                                thoughtNumber: 1, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 1,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Phase 0 (Docker 인프라 구축)부터 검토해보자.\n\n제안한 순서:
                                                Docker MySQL + Redis 구축 → application.yml 설정\n\n검토:\n✅ 장점: 개발
                                                 환경을 먼저 갖추는 것은 합리적\n⚠️ 우려: 주니어 개발자가 Docker를 처음
                                                접하면 1-2일로는 부족할 수 있음\n⚠️ 우려: Docker 없이도 로컬 MySQL로
                                                시작할 수 있는데, 필수로 Docker를 강제하는 것이 맞나?\n\n개선 방안:\n-
                                                Docker는 \"권장\"이지만 선택사항으로 두기\n- 또는 Docker Compose 파일을
                                                미리 완성해서 제공하고, `docker-compose up -d` 한 번만 실행하면
                                                되도록\n- 로컬 MySQL 설치 옵션도 함께 제시\n\n결론: Docker 구축 단계를
                                                더 명확하게 하거나, 대안 제시 필요", thoughtNumber: 2, totalThoughts:
                                                15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 2,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Phase 1-2 (프로젝트 기반 설정 + 예외 처리)를
                                                검토해보자.\n\n제안 순서:\n1. 패키지 구조 생성\n2. WebConfig, JpaConfig
                                                등 공통 설정\n3. ApiResponse, ErrorResponse\n4. BaseTimeEntity\n5.
                                                ErrorCode, BusinessException, GlobalExceptionHandler\n\n검토:\n✅ 장점:
                                                공통 인프라를 먼저 구축하는 것은 좋은 접근\n❌ 문제점: 주니어 개발자
                                                입장에서 \"추상적인 것\"부터 시작하면 동기부여가 떨어질 수 있음\n❌
                                                문제점: 예외 처리 시스템을 먼저 만들어도, 실제 도메인 로직이 없으면
                                                테스트할 수 없음\n\n대안:\n- 먼저 가장 단순한 도메인(User
                                                회원가입/로그인)을 만들어보고\n- 그 과정에서 필요한 예외 처리를
                                                점진적으로 추가하는 방식\n- \"동작하는 코드\"를 빨리 만들어보는 것이
                                                학습에 더 효과적\n\n이것은 \"Top-down vs Bottom-up\" 접근의 차이인데,
                                                주니어에게는 Bottom-up이 더 나을 수 있음", thoughtNumber: 3,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 3,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Phase 3 (Spring Security + JWT) 시점을 검토해보자.\n\n제안
                                                순서: User 도메인보다 먼저 Security + JWT를 구현\n\n검토:\n❌ 큰 문제:
                                                Spring Security와 JWT는 매우 복잡한 주제\n❌ 주니어가 User Entity도 없는
                                                 상태에서 CustomUserDetailsService를 만들 수 없음\n❌ 로그인 로직도
                                                없는데 JWT를 먼저 구현하면 테스트 불가능\n❌ 학습 곡선: Security는
                                                Spring에서 가장 어려운 부분 중 하나\n\n올바른 순서:\n1. 먼저 User
                                                도메인을 Security 없이 구현 (회원가입, 조회)\n2. 간단한 로그인 API를
                                                만들어보기 (Security 없이)\n3. 그 다음에 Spring Security를 적용하면서
                                                점진적으로 개선\n4. 마지막으로 JWT 추가\n\n이유:\n- \"동작하는 코드\"를
                                                먼저 만들고 점진적으로 보안을 강화하는 것이 학습에 효과적\n- Spring
                                                Security의 필요성을 체감한 후에 적용해야 이해도가 높아짐",
                                                thoughtNumber: 4, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 4,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "도메인 간 의존성을 검토해보자.\n\n제안된 도메인 구현 순서:
                                                User → Friend → Location → Shuttle → Arrival\n\n의존성 분석:\n- Friend는
                                                 User에 의존 (Friendship이 User를 참조)\n- Location은 User에 의존
                                                (LocationShare가 User를 참조)\n- Shuttle은 독립적 (ShuttleRoute,
                                                ShuttleStop)\n- Arrival은 Location + Shuttle + Friend에 모두
                                                의존\n\n검토:\n✅ User를 먼저 하는 것은 맞음\n⚠️ Friend와 Location은
                                                병렬로 개발 가능한데 순차적으로 제안됨\n⚠️ Shuttle은 다른 도메인과
                                                독립적이므로 더 일찍 할 수 있음\n\n개선된 순서:\n1. User (기본 CRUD)\n2.
                                                 Shuttle (독립적이므로 병렬 가능)\n3. Friend + Location (병렬 가능)\n4.
                                                Arrival (모든 도메인이 준비된 후)\n\n또는 학습 관점에서:\n1. Shuttle
                                                (가장 단순, JPA 연습용)\n2. User (인증 제외한 기본 기능)\n3. Friend
                                                (연관관계 학습)\n4. Location (스케줄러, Redis 학습)\n5. 인증 시스템
                                                (Security + JWT)\n6. Arrival (외부 API 연동)\n\n후자가 학습 곡선
                                                측면에서 더 나을 수 있음", thoughtNumber: 5, totalThoughts: 15,
                                                nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 5,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Redis 사용 시점을 검토해보자.\n\n제안에서 Redis 사용처:\n1.
                                                JWT Refresh Token 저장\n2. 로그아웃 토큰 Blacklist\n3. Location 데이터
                                                캐싱\n\n검토:\n⚠️ 문제: Redis를 Phase 0에 설치하지만, 실제 사용은 Phase
                                                3 (JWT), Phase 6 (Location)\n⚠️ 문제: 주니어가 Redis를 언제 왜 쓰는지
                                                모르는 채로 설치만 해두면 혼란\n⚠️ 문제: MVP에서 Redis가 정말
                                                필수인가?\n\n대안 검토:\n1. JWT Refresh Token → 초기에는 DB에 저장해도
                                                됨 (성능은 떨어지지만 동작함)\n2. Blacklist → 초기 MVP에서는 생략 가능
                                                (토큰 만료 시간만으로도 충분)\n3. Location 캐싱 → DB만으로도 충분히 빠름
                                                 (사용자 수가 많지 않으면)\n\n결론:\n- Redis는 \"성능 최적화\" 단계에서
                                                추가하는 것이 학습 관점에서 더 나을 수 있음\n- 또는 Redis를 쓴다면, 왜
                                                필요한지 명확히 설명하고 실제 사용 시점에 도입", thoughtNumber: 6,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 6,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "build.gradle의 의존성을 다시 확인해보자.\n\n현재 설정된
                                                의존성:\n- spring-boot-starter-validation ✅\n-
                                                spring-boot-starter-data-jpa ✅\n- spring-boot-starter-security ✅\n-
                                                spring-boot-starter-web ✅\n- lombok ✅\n- mysql-connector-j ✅\n- h2
                                                (테스트용) ✅\n\n제안에서 추가하려는 것:\n- JWT 라이브러리 (jjwt)\n-
                                                Redis (spring-boot-starter-data-redis)\n- WebFlux (카카오 API
                                                호출용)\n\n검토:\n✅ JWT는 필수\n⚠️ Redis는 앞서 검토했듯이 선택적\n✅
                                                WebFlux (WebClient)는 카카오 API 호출에 필요\n\n추가 고려사항:\n-
                                                RestTemplate vs WebClient: WebClient가 최신이지만 주니어에게는
                                                RestTemplate이 더 직관적일 수 있음\n- 하지만 RestTemplate은 deprecated
                                                예정이므로 WebClient 학습이 장기적으로 유리\n\n결론: 의존성 추가 계획은
                                                적절함", thoughtNumber: 7, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 7,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Location 도메인의 1시간 자동 만료 로직을
                                                검토해보자.\n\n제안된 구현:\n- LocationShare Entity에 startTime, endTime
                                                 저장\n- @Scheduled로 만료된 항목을 주기적으로 isActive = false로
                                                변경\n- Redis에도 TTL 1시간으로 캐싱\n\n검토:\n✅ startTime, endTime을
                                                DB에 저장하는 것은 좋음\n⚠️ @Scheduled로 배치 처리하는 방식의 문제점:\n
                                                 - 스케줄러가 5분마다 돌면, 만료 후 최대 5분 지연 발생\n  - 만료 시점이
                                                정확하지 않음\n  \n대안:\n1. 조회 시점에 endTime과 현재 시간을 비교
                                                (Lazy Evaluation)\n   - 장점: 정확함, 추가 스케줄러 불필요\n   - 단점:
                                                매번 시간 비교 필요\n   \n2. Redis TTL만 사용하고 DB는 로그용\n   -
                                                장점: Redis가 자동으로 만료 처리\n   - 단점: Redis 장애 시 데이터
                                                손실\n\nMVP 추천: \n- 방안 1 (조회 시점 검증)이 가장 단순하고 안정적\n-
                                                추가로 @Scheduled (1시간마다)로 정리하는 정도면 충분", thoughtNumber: 8,
                                                 totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 8,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "카카오 모빌리티 API 연동 부분을 검토해보자.\n\n제안된
                                                구현:\n- WebClient로 카카오 경로 API 호출\n- origin (친구 위치) →
                                                waypoints (경유지들) → destination (내 위치)\n- 결과로 소요 시간 및 경로
                                                 좌표 반환\n\n검토:\n✅ WebClient 사용은 적절함\n⚠️ 복잡도: 카카오 API는
                                                 여러 종류가 있고 문서가 복잡함\n⚠️ 비용: 카카오 모빌리티 API는 유료일
                                                수 있음\n\n확인 필요사항:\n1. 카카오 모빌리티 API vs 카카오맵 API
                                                차이\n2. 무료 티어 존재 여부\n3. Waypoints를 지원하는 API가
                                                맞는지\n\n대안:\n- 초기 MVP에서는 단순 직선거리 계산으로 시작\n- 나중에
                                                실제 API 연동\n- 또는 구글 Directions API 고려 (월 $200 무료
                                                크레딧)\n\n추천:\n- 일단 카카오 API 명세를 먼저 확인하고 계획 수정\n-
                                                MVP에서는 mock 데이터나 단순 계산으로 시작하는 것도 고려",
                                                thoughtNumber: 9, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 9,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "CI/CD 계획을 검토해보자.\n\n제안: GitHub Actions로 자동 빌드
                                                및 배포\n\n제안된 워크플로우:\n1. main 브랜치 push 시 트리거\n2. Gradle
                                                빌드\n3. Docker 이미지 빌드\n4. 서버로 SSH 접속하여 배포\n\n검토:\n⚠️
                                                문제: MVP 단계에서 CI/CD가 우선순위가 높은가?\n⚠️ 문제: SSH 키, 서버
                                                호스트 등의 인프라가 준비되어 있는가?\n⚠️ 문제: 주니어가 GitHub
                                                Actions를 처음 다룬다면 시간이 많이 소요될 수 있음\n\n대안:\n1. 초기에는
                                                 수동 배포 (jar 파일 빌드 후 서버에 업로드)\n2. 핵심 기능 완성 후 CI/CD
                                                추가\n3. 또는 더 간단한 방식: GitHub Actions로 빌드만 자동화 (배포는
                                                수동)\n\n우선순위 재조정:\n- Phase 1-8: 핵심 기능 구현\n- Phase 9: CI/CD
                                                 (선택사항, 시간 여유 있을 때)\n\n결론: CI/CD는 \"좋으면 하는 것\"이지
                                                MVP 필수는 아님", thoughtNumber: 10, totalThoughts: 15,
                                                nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 10,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "CLAUDE.md에서 프론트엔드 요구사항을 다시 확인해보자.\n\n핵심
                                                API 엔드포인트 (프론트에서 필요한 것):\n1. POST /api/auth/login,
                                                /api/auth/signup\n2. POST /api/location/start, /api/location/stop, PUT
                                                /api/location/update\n3. GET /api/friends, POST /api/friends/request,
                                                PUT /api/friends/:id/accept/reject\n4. GET /api/shuttle/routes, GET
                                                /api/shuttle/routes/:id/stops\n5. POST /api/shuttle/arrival-time\n6.
                                                검색 API: GET /api/shuttle/routes/search, GET
                                                /api/friends/search\n\n추가 필요한 API (제안에서 누락):\n❌ 친구 이름
                                                검색 API가 명시되어 있지만, 실제로는 \"이메일로 검색\"이 필요\n❌ GET
                                                /api/location/friends - 모든 친구들의 위치를 한번에 조회하는 API 필요\n
                                                  (현재는 GET /api/location/friend/:friendId로 한명씩만 조회
                                                가능)\n\n검토:\n- 프론트엔드 요구사항: \"친구 관계인 모든 유저의 위치
                                                마커 표시\"\n- 이를 위해서는 친구 목록 조회 → 각 친구의 위치 조회 (N+1
                                                문제 발생)\n- 더 나은 방법: GET /api/location/friends 엔드포인트로
                                                한번에 조회\n\n결론: Location API 설계에 보완 필요", thoughtNumber: 11,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 11,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Entity 설계를 다시 검토해보자.\n\nFriendship Entity:\n-
                                                requester (요청 보낸 사람)\n- receiver (요청 받은 사람)\n- status
                                                (PENDING, ACCEPTED, REJECTED)\n\n검토:\n✅ 기본 설계는 괜찮음\n⚠️ 쿼리
                                                복잡도: \"내 친구 목록\"을 조회하려면?\n  - WHERE (requester_id = 나 OR
                                                receiver_id = 나) AND status = ACCEPTED\n  - 양방향 관계 때문에 쿼리가
                                                복잡해짐\n\n대안:\n1. 현재 설계 유지 + Repository에서 복잡한 쿼리
                                                작성\n2. ACCEPTED 상태가 되면 양방향 레코드 2개 생성 (더 단순한 쿼리)\n
                                                  - (A→B, ACCEPTED), (B→A, ACCEPTED)\n   - 단점: 데이터 중복\n\n추천:\n-
                                                 방안 1 유지 (정규화)\n- JPA 쿼리 메서드 예시 제공 필요:\n  ```java\n
                                                @Query(\"SELECT f FROM Friendship f WHERE (f.requester.id = :userId OR
                                                f.receiver.id = :userId) AND f.status = 'ACCEPTED'\")\n
                                                List<Friendship> findMyFriends(@Param(\"userId\") Long userId);\n
                                                ```\n\n결론: Entity 설계는 괜찮지만 Repository 쿼리 예시 추가 필요",
                                                thoughtNumber: 12, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 12,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Validation 전략을 검토해보자.\n\n제안에서 Validation:\n-
                                                @Email, @NotBlank, @Pattern 등 Bean Validation 사용\n- SignUpRequest에서
                                                 비밀번호 정규식 검증\n\n검토:\n✅ Bean Validation 사용은 좋은 접근\n⚠️
                                                주의: 비밀번호 확인(password, passwordConfirm) 검증은?\n⚠️ 주의: 이메일
                                                중복 체크는 어디서?\n\n필요한 Validation 레이어:\n1. DTO 레벨: @Valid로
                                                기본 형식 검증\n2. Service 레벨: 비즈니스 로직 검증 (중복 체크 등)\n3.
                                                Custom Validator: 복잡한 검증 (비밀번호 일치 등)\n\n예시:\n```java\n//
                                                DTO\n@Getter\npublic class SignUpRequest {\n    @Email\n    private
                                                String email;\n    \n    @Pattern(regexp =
                                                \"^(?=.*[A-Za-z])(?=.*\\\\d)[A-Za-z\\\\d]{8,}$\")\n    private String
                                                password;\n    \n    private String passwordConfirm;\n}\n\n//
                                                Service\npublic void signUp(SignUpRequest request) {\n    // 비밀번호
                                                일치 검증\n    if
                                                (!request.getPassword().equals(request.getPasswordConfirm())) {\n
                                                 throw new BusinessException(ErrorCode.PASSWORD_NOT_MATCH);\n    }\n
                                                \n    // 이메일 중복 검증\n    if
                                                (userRepository.existsByEmail(request.getEmail())) {\n        throw new
                                                BusinessException(ErrorCode.DUPLICATE_EMAIL);\n    }\n
                                                ...\n}\n```\n\n결론: Validation 전략은 괜찮지만 더 구체적인 예시 필요",
                                                thoughtNumber: 13, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 13,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "학습 자료와 시간 예상을 검토해보자.\n\n제안된 총 소요 시간:
                                                2-3주\n\nPhase별 소요 시간:\n- Phase 0 (Docker): 1-2일\n- Phase 1
                                                (기반): 1일\n- Phase 2 (예외처리): 1일\n- Phase 3 (Security+JWT):
                                                2-3일\n- Phase 4-7 (도메인): 6-7일\n- Phase 8 (카카오 API): 2-3일\n-
                                                Phase 9 (CI/CD): 1-2일\n합계: 14-21일\n\n검토:\n⚠️ 문제: 주니어 개발자가
                                                 처음 Spring을 배우면서 진행한다면 2-3주는 매우 빡빡함\n⚠️ 문제: 학습
                                                시간이 고려되지 않음 (순수 개발 시간만 계산)\n⚠️ 문제: 디버깅, 오류 수정
                                                 시간 미포함\n\n현실적인 예상:\n- 학습하면서 개발: 3-4주\n- 오류 해결
                                                버퍼: +1주\n- 총 4-5주가 더 현실적\n\n또한:\n- 매일 풀타임으로 개발할 수
                                                 있는가?\n- SSAFY 교육 중이라면 병행해야 하므로 더 길어질 수
                                                있음\n\n결론: 시간 예상을 더 보수적으로 조정 필요", thoughtNumber: 14,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 14,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "전체 계획을 종합하여 개선안을 정리해보자.\n\n발견한 주요
                                                문제점:\n1. 개발 순서: 추상적인 것(예외처리, Security)을 먼저 하면 학습
                                                곡선이 가파름\n2. Redis: MVP에서 필수가 아닌데 초기부터 도입\n3.
                                                Security+JWT: User 도메인보다 먼저 구현할 수 없음\n4. API 누락: 친구들의
                                                 위치를 한번에 조회하는 API\n5. 시간 예상: 너무 낙관적 (학습 시간
                                                미포함)\n6. CI/CD: MVP 우선순위가 아님\n7. 카카오 API: 비용/복잡도 고려
                                                필요\n\n개선된 개발 순서 제안:\n1. **환경 설정** (1-2일): Docker MySQL
                                                (Redis는 나중에)\n2. **Shuttle 도메인** (1-2일): 가장 단순, JPA
                                                학습용\n3. **User 도메인 (인증 제외)** (2일): 기본 CRUD\n4. **공통
                                                인프라** (1일): 예외처리, Validation (필요성을 체감한 후)\n5. **Friend
                                                도메인** (2일): 연관관계 학습\n6. **Location 도메인** (2일): 위치 공유
                                                기본\n7. **Spring Security + JWT** (3-4일): 이제 적용\n8. **Arrival
                                                도메인** (2-3일): 카카오 API (또는 mock)\n9. **Redis 최적화** (1일):
                                                선택사항\n10. **CI/CD** (1-2일): 선택사항\n\n이 순서의 장점:\n- 단순한
                                                것부터 복잡한 것으로\n- 각 단계에서 동작하는 코드를 만들며 학습\n- 필수
                                                기능 우선, 최적화는 나중에", thoughtNumber: 15, totalThoughts: 15,
                                                nextThoughtNeeded: false)
  ⎿  {
       "thoughtNumber": 15,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● Sequential Thinking으로 계획을 점검한 결과, 몇 가지 중요한 문제점을 발견했습니다. 개선된 계획을 제시하겠습니다.

  ---
  🔍 Sequential Thinking 점검 결과

  ❌ 발견된 주요 문제점

  1. 개발 순서의 문제

  - 문제: 예외 처리, Security+JWT를 User 도메인보다 먼저 구현
  - 이유: 실제 도메인 로직 없이 추상적인 인프라만 만들면 테스트 불가능하고 학습 효과 낮음
  - 개선: 단순한 도메인부터 시작 → 필요성 체감 후 인프라 추가

  2. Redis의 시기상조

  - 문제: Phase 0에 Redis 설치하지만 실제 사용은 Phase 3, 6
  - 이유: MVP에서 Redis는 "성능 최적화"이지 필수가 아님
  - 개선: 일단 DB만으로 구현 → 나중에 Redis 추가 (또는 생략)

  3. 누락된 API

  - 문제: 프론트에서 "모든 친구의 위치"를 한번에 조회해야 하는데 API 없음
  - 개선: GET /api/location/friends 엔드포인트 추가 필요

  4. 비현실적인 일정

  - 문제: 2-3주 예상 (학습 시간 미포함, 디버깅 시간 미포함)
  - 개선: 현실적으로 4-5주 (주니어 + 학습 포함)

  5. CI/CD 우선순위

  - 문제: MVP 단계에서 CI/CD를 필수로 제안
  - 개선: 핵심 기능 완성 후 선택적으로 추가

  ---
  📋 개선된 개발 계획

  🎯 핵심 원칙 변경

  기존 계획 (Top-Down)

  인프라 구축 → 예외처리 → Security → 도메인

  개선된 계획 (Bottom-Up)

  단순 도메인 → 필요한 인프라 → 복잡한 기능 → 최적화

  이유: 주니어 개발자는 "동작하는 코드"를 빠르게 만들어보며 학습하는 것이 효과적

  ---
  🚀 새로운 개발 순서

  Phase 0: 환경 설정 (1-2일)

  목표: 최소한의 개발 환경 구축

  작업:
  1. Docker Compose로 MySQL만 구축 (Redis는 나중에)
  services:
    mysql:
      image: mysql:8.0
      ports: ["3306:3306"]
      environment:
        MYSQL_DATABASE: shuttle_tracker
  2. application.yml 기본 설정
  3. 프로젝트 실행 확인

  학습: Docker 기본, MySQL 연결

  ---
  Phase 1: Shuttle 도메인 (1-2일)

  목표: 가장 단순한 도메인으로 JPA 학습

  왜 먼저?
  - 다른 도메인과 독립적
  - 인증 불필요
  - CRUD 기본 학습에 최적

  작업:
  1. Entity 작성: ShuttleRoute, ShuttleStop
  2. Repository: @OneToMany 관계 학습
  3. Service: 기본 조회 로직
  4. Controller: REST API 작성
    - GET /api/shuttle/routes
    - GET /api/shuttle/routes/{id}/stops
    - GET /api/shuttle/routes/search?q={query}
  5. SQL로 초기 데이터 삽입

  학습:
  - JPA Entity, Repository 기본
  - @OneToMany 연관관계
  - Spring Web Controller
  - SQL 초기 데이터 로드

  결과: Postman으로 실제 동작하는 API 확인 가능!

  ---
  Phase 2: User 도메인 - 기본편 (2일)

  목표: 인증 없이 User CRUD 구현

  작업:
  1. Entity: User (email, password, name)
  2. Repository: 기본 메서드
  3. Service:
    - 회원가입 (비밀번호 BCrypt 암호화)
    - 이메일로 사용자 검색
    - 내 정보 조회
  4. Controller:
    - POST /api/users (회원가입)
    - GET /api/users/search?email={email} (검색)
    - GET /api/users/{id} (조회)

  학습:
  - BCryptPasswordEncoder
  - Bean Validation (@Email, @NotBlank)
  - DTO 패턴 (Request/Response 분리)

  보안은?: 일단 인증 없이 만들어봄 (학습용)

  ---
  Phase 3: 공통 인프라 구축 (1일)

  목표: 지금까지 개발하며 느낀 필요성을 해결

  작업:
  1. GlobalExceptionHandler
    - 지금까지 발생한 예외들을 한곳에서 처리
  2. ErrorCode Enum
  USER_NOT_FOUND(404, "U001", "사용자를 찾을 수 없습니다.")
  DUPLICATE_EMAIL(409, "U002", "이미 존재하는 이메일입니다.")
  3. ApiResponse 통일
  {
    "success": true,
    "data": {...},
    "error": null
  }
  4. BaseTimeEntity (createdAt, updatedAt)

  학습:
  - @ControllerAdvice
  - Custom Exception 설계

  왜 이제?: 실제 예외가 발생해봐야 필요성을 체감함

  ---
  Phase 4: Friend 도메인 (2일)

  목표: 연관관계 심화 학습

  작업:
  1. Entity: Friendship
    - @ManyToOne User requester
    - @ManyToOne User receiver
    - FriendshipStatus status
  2. Repository:
  @Query("SELECT f FROM Friendship f WHERE (f.requester.id = :userId OR f.receiver.id = :userId) AND f.status =
  'ACCEPTED'")
  List<Friendship> findMyFriends(@Param("userId") Long userId);
  3. Service: 친구 추가/수락/거절/삭제
  4. Controller:
    - GET /api/friends (내 친구 목록)
    - POST /api/friends/request
    - PUT /api/friends/{id}/accept
    - DELETE /api/friends/{id}

  학습:
  - 양방향 관계 처리
  - JPQL 작성
  - 복잡한 비즈니스 로직

  ---
  Phase 5: Location 도메인 (2일)

  목표: 위치 공유 로직 구현

  작업:
  1. Entity: LocationShare
  private LocalDateTime startTime;
  private LocalDateTime endTime; // startTime + 1시간
  private Boolean isActive;
  2. Service:
    - 위치 공유 시작/중지
    - 위치 업데이트
    - 중요: GET /api/location/friends (모든 친구 위치 한번에 조회)
    - 조회 시 endTime과 현재 시간 비교 (만료 검증)
  3. @Scheduled (1시간마다 만료된 데이터 정리)

  학습:
  - LocalDateTime 사용
  - @Scheduled 태스크
  - 효율적인 쿼리 (N+1 방지)

  ---
  Phase 6: Spring Security + JWT (3-4일)

  목표: 기존 API에 인증 추가

  왜 이제?:
  - User, Friend, Location이 모두 동작하는 상태
  - 이제 "보호"가 필요함을 체감

  작업:
  1. JWT 의존성 추가
  implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
  2. JwtTokenProvider 구현
  3. JwtAuthenticationFilter 구현
  4. SecurityConfig 작성
  .requestMatchers("/api/auth/**", "/api/shuttle/**").permitAll()
  .anyRequest().authenticated()
  5. 로그인 API 추가
    - POST /api/auth/login → JWT 발급
  6. 기존 API에 인증 적용

  학습:
  - Spring Security Architecture
  - JWT 토큰 생성/검증
  - Filter Chain

  Refresh Token은?:
  - 초기에는 Access Token만 (1일 TTL)
  - 나중에 필요하면 추가

  ---
  Phase 7: Arrival 도메인 (2-3일)

  목표: 도착 시간 예측

  작업:
  1. 카카오 API 조사
    - 비용 확인
    - API 명세 확인
    - 무료 대안 탐색
  2. WebClient 설정
  3. ArrivalTimeService 구현
  4. 대안: 초기에는 단순 거리 계산으로 mock
  // 하버사인 공식으로 직선거리 계산
  double distance = calculateDistance(friendLoc, myLoc);
  int estimatedMinutes = (int)(distance / 평균속도);

  학습:
  - WebClient 사용
  - 외부 API 연동
  - 에러 핸들링

  ---
  Phase 8: Redis 최적화 (선택, 1일)

  목표: 성능 개선

  Redis 도입 시점:
  - Refresh Token 저장
  - Location 데이터 캐싱 (TTL 1시간)

  작업:
  1. Docker Compose에 Redis 추가
  2. RedisUtil 구현
  3. LocationService에 캐싱 로직 추가

  왜 선택?: MVP에서 사용자가 많지 않으면 불필요

  ---
  Phase 9: CI/CD (선택, 1-2일)

  목표: 자동 배포

  작업:
  1. GitHub Actions 워크플로우
  2. Docker 이미지 빌드
  3. 서버 배포 자동화

  왜 선택?: 핵심 기능 완성이 우선

  ---
  📊 개선된 일정 예상

  | Phase | 내용             | 예상 소요 (주니어+학습) |
  |-------|----------------|----------------|
  | 0     | 환경 설정          | 1-2일           |
  | 1     | Shuttle 도메인    | 1-2일           |
  | 2     | User 도메인 기본    | 2일             |
  | 3     | 공통 인프라         | 1일             |
  | 4     | Friend 도메인     | 2일             |
  | 5     | Location 도메인   | 2일             |
  | 6     | Security + JWT | 3-4일           |
  | 7     | Arrival 도메인    | 2-3일           |
  | 8     | Redis (선택)     | 1일             |
  | 9     | CI/CD (선택)     | 1-2일           |
  | 버퍼    | 디버깅, 오류 수정     | 3-5일           |
  | 총계    |                | 4-5주 (현실적)     |

  ---
  ✅ MVP 필수 vs 선택

  필수 (3주 목표)

  - ✅ Phase 0-7 (Redis, CI/CD 제외)
  - ✅ JWT 인증
  - ✅ 핵심 도메인 기능
  - ✅ 예외 처리

  선택 (시간 여유 시)

  - ⭐ Redis 최적화
  - ⭐ CI/CD
  - ⭐ 실제 카카오 API 연동 (초기에는 mock 가능)
  - ⭐ WebSocket 실시간 업데이트

  ---
  📚 단계별 학습 자료

  Phase 1-2: JPA 기초

  - 김영한 - 자바 ORM 표준 JPA 프로그래밍 (인프런)
  - Spring Data JPA 공식 문서

  Phase 3: 예외 처리

  - Baeldung - Exception Handling in Spring
  - 우아한형제들 기술 블로그 - 예외 처리 전략

  Phase 4-5: JPA 심화

  - N+1 문제 해결
  - JPQL vs QueryDSL

  Phase 6: Spring Security

  - 김영한 - 스프링 시큐리티 (인프런)
  - JWT.io 공식 문서
  - Baeldung - Spring Security + JWT

  Phase 7: WebClient

  - Spring WebFlux 공식 문서
  - 카카오 모빌리티 API 문서

  ---
  💡 추가 개선 사항

  1. API 명세 보완

  // 추가 필요
  GET /api/location/friends          // 모든 친구 위치 한번에 조회
  GET /api/users/search?email={email} // 이메일로 사용자 검색

  2. Validation 강화

  // SignUpRequest에 추가
  private String passwordConfirm;

  // Service에서 검증
  if (!password.equals(passwordConfirm)) {
      throw new BusinessException(ErrorCode.PASSWORD_NOT_MATCH);
  }

  3. 위치 만료 로직 개선

  // 조회 시점에 검증 (Lazy Evaluation)
  public Optional<LocationShare> getActiveLocation(Long userId) {
      return locationShareRepository.findByUserId(userId)
          .filter(loc -> loc.getEndTime().isAfter(LocalDateTime.now()))
          .filter(LocationShare::getIsActive);
  }

  ---

╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Ready to code?                                                                                                       │
│                                                                                                                      │
│ Here is Claude's plan:                                                                                               │
│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │
│ │ Sequential Thinking 점검 완료 - 개선된 백엔드 개발 계획                                                          │ │
│ │                                                                                                                  │ │
│ │ 🔍 주요 개선 사항                                                                                                │ │
│ │                                                                                                                  │ │
│ │ 1. 개발 순서 대폭 수정 (Bottom-Up 접근)                                                                          │ │
│ │                                                                                                                  │ │
│ │ 기존: 인프라 → Security → 도메인개선: 단순 도메인 → 필요 인프라 → 복잡 기능                                      │ │
│ │                                                                                                                  │ │
│ │ 새로운 순서:                                                                                                     │ │
│ │ 1. Shuttle 도메인 (가장 단순, JPA 학습)                                                                          │ │
│ │ 2. User 도메인 기본 (인증 제외)                                                                                  │ │
│ │ 3. 공통 인프라 (필요성 체감 후)                                                                                  │ │
│ │ 4. Friend 도메인 (연관관계)                                                                                      │ │
│ │ 5. Location 도메인 (스케줄러)                                                                                    │ │
│ │ 6. Spring Security + JWT (이제 적용)                                                                             │ │
│ │ 7. Arrival 도메인 (카카오 API)                                                                                   │ │
│ │                                                                                                                  │ │
│ │ 이유: 주니어는 "동작하는 코드"를 빠르게 만들며 학습하는 것이 효과적                                              │ │
│ │                                                                                                                  │ │
│ │ 2. Redis를 선택사항으로 변경                                                                                     │ │
│ │                                                                                                                  │ │
│ │ - MVP에서 Redis는 "최적화"이지 필수 아님                                                                         │ │
│ │ - 초기에는 DB만으로 충분                                                                                         │ │
│ │ - Phase 8에서 선택적으로 추가                                                                                    │ │
│ │                                                                                                                  │ │
│ │ 3. CI/CD 우선순위 하향                                                                                           │ │
│ │                                                                                                                  │ │
│ │ - 핵심 기능 완성이 우선                                                                                          │ │
│ │ - Phase 9에서 선택사항으로                                                                                       │ │
│ │                                                                                                                  │ │
│ │ 4. 누락된 API 추가                                                                                               │ │
│ │                                                                                                                  │ │
│ │ - GET /api/location/friends (모든 친구 위치 한번에)                                                              │ │
│ │ - GET /api/users/search?email={email} (이메일 검색)                                                              │ │
│ │                                                                                                                  │ │
│ │ 5. 현실적인 일정 조정                                                                                            │ │
│ │                                                                                                                  │ │
│ │ 기존: 2-3주개선: 4-5주 (학습 시간 + 디버깅 버퍼 포함)                                                            │ │
│ │                                                                                                                  │ │
│ │ 📋 최종 개발 순서 (3주 MVP 목표)                                                                                 │ │
│ │                                                                                                                  │ │
│ │ Week 1: 기초 다지기                                                                                              │ │
│ │                                                                                                                  │ │
│ │ - Phase 0-2: 환경 + Shuttle + User 기본                                                                          │ │
│ │                                                                                                                  │ │
│ │ Week 2: 핵심 도메인                                                                                              │ │
│ │                                                                                                                  │ │
│ │ - Phase 3-5: 인프라 + Friend + Location                                                                          │ │
│ │                                                                                                                  │ │
│ │ Week 3: 인증 & 통합                                                                                              │ │
│ │                                                                                                                  │ │
│ │ - Phase 6-7: Security + JWT + Arrival                                                                            │ │
│ │                                                                                                                  │ │
│ │ Week 4-5: 여유분 (선택)                                                                                          │ │
│ │                                                                                                                  │ │
│ │ - Redis, CI/CD, 디버깅, 개선                                                                                     │ │
│ │                                                                                                                  │ │
│ │ 📚 학습 로드맵 명확화                                                                                            │ │
│ │                                                                                                                  │ │
│ │ 각 Phase마다 구체적인 학습 자료와 실습 목표 제시                                                                 │ │
│ │                                                                                                                  │ │
│ │ 이 개선된 계획으로 진행하시겠습니까?                                                                             │ │
│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │
│                                                                                                                      │
│ Would you like to proceed?                                                                                           │
│                                                                                                                      │
│ > 1. Yes, and auto-accept edits                                                                                      │
│   2. Yes, and manually approve edits                                                                                 │
│   3. No, keep planning                                                                                               │
│                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
ctrl-g to edit plan in start

╭─── Claude Code v2.0.26 ──────────────────────────────────────────────────────────────────────────────────────────────╮
│                                                    │ Tips for getting started                                        │
│               Welcome back jedo5000!               │ Run /install-github-app to tag @claude right from your Github … │
│                                                    │ √ Run /init to create a CLAUDE.md file with instructions for C… │
│                       ▐▛███▜▌                      │ ─────────────────────────────────────────────────────────────── │
│                      ▝▜█████▛▘                     │ Recent activity                                                 │
│                        ▘▘ ▝▝                       │ No recent activity                                              │
│                                                    │                                                                 │
│              Sonnet 4.5 · Claude Pro               │                                                                 │
│ C:\Users\SSAFY\projects\shuttle-tracker\shuttle-t… │                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

> # 백엔드

너는 java, Spring을 사용하는 우수기업의 10년차 시니어 백엔드 개발자야. 나는 아직 스프링에 대한 개념, 실력이 부족한
학생이고 프로젝트를 만들려해.

shuttle-tracker-be 프로젝트의 [CLAUDE.md](http://CLAUDE.md), DEVELOPMENT.md, FRONT_README.md, tree.txt를 읽고
프로젝트 파악을 해야함.

1. 프로젝트 세팅 → Springboot로 받고 gradle 설정했음. 코딩 컨벤션 숙지
2. Docker로 MySQL과 Redis Container 만들어서 사용하기, Docker 사용하는 법 공부해야함.
3. git action으로 CI/CD 구축하기
4. 구조 세팅 → domain 별 디렉토리 구조 채택 / 그리고 주니어 개발자로서 내가 백엔드를 어떤 순서대로 무엇을 설계하고
구현해야할지 잘 모르겠어. 알려줬으면 좋겠어.
    1. Entity 설계
    2. Spring security, redis + jwt 사용
    3. tree.txt의 과거 프로젝트 구조와 비슷한 구조로 프로젝트 진행 예정
    4. exceptionhandler, exception, validation 등등 필요한 것들을 넣고 학습할 예정(but MVP 프로젝트이고 바로
서비스해야하므로 과한건 빼고싶음. 추천 부탁함.)
    5. JPA 활용

너가 직접 코드를 짜는게 아닌 아키텍쳐를 어떻게 설계해야하는지, (너무 전 프로젝트를 무조건 따를 필요는 없어. ) 어떻게
 내가 이것들을 구현해 나가야하는지, 무엇을 공부하고 참고해야하는지를 계획 세운걸 받고싶어.

● 프로젝트 파악을 위해 관련 문서들을 먼저 읽어보겠습니다.

● Read(CLAUDE.md)
  ⎿  Read 141 lines

● Read(DEVELOPMENT.md)
  ⎿  Read 385 lines

● Read(FRONT_README.md)
  ⎿  Read 153 lines

● Read(tree.txt)
  ⎿  Read 138 lines

● 현재 프로젝트의 상태를 추가로 확인하겠습니다.

● Search(pattern: "**/*.gradle")
  ⎿  Found 2 files (ctrl+o to expand)

● Search(pattern: "**/application*.yml")
  ⎿  Found 2 files (ctrl+o to expand)

● Search(pattern: "**/application*.properties")
  ⎿  Found 0 files

● Read(build.gradle)
  ⎿  Read 45 lines

● Read(src\main\resources\application.yml)
  ⎿  Read 16 lines

● Search(pattern: "src/main/java/**/*.java")
  ⎿  Found 1 file (ctrl+o to expand)

● 좋습니다! 프로젝트 파악을 완료했습니다. 이제 SSAFY 셔틀 버스 위치 추적 서비스의 백엔드 아키텍처와 개발 계획을
  제시하겠습니다.

  ---
  🎯 SSAFY 셔틀 트래커 백엔드 아키텍처 & 개발 로드맵

  📊 프로젝트 현황 분석

  ✅ 완료된 것

  - Spring Boot 3.5.7 + Gradle 프로젝트 세팅
  - 기본 의존성: JPA, Security, Validation, MySQL, Lombok
  - application.yml 기본 구조 (주석 처리)

  🔧 진행 필요

  1. Docker를 통한 MySQL + Redis 인프라 구축
  2. 도메인별 계층 구조 설계 및 구현
  3. Spring Security + JWT + Redis 인증 시스템
  4. 핵심 비즈니스 로직 구현
  5. CI/CD (GitHub Actions)

  ---
  🏗️ 1. 아키텍처 설계

  1.1 계층 구조 (Layered Architecture)

  이전 프로젝트와 동일한 도메인 기반 구조를 채택하되, MVP에 맞게 단순화합니다.

  src/main/java/com/ssafy/shuttle_tracker/
  ├── domain/
  │   ├── user/                     # 사용자 도메인
  │   │   ├── controller/
  │   │   │   └── UserController.java
  │   │   ├── dto/
  │   │   │   ├── request/
  │   │   │   │   ├── SignUpRequest.java
  │   │   │   │   ├── LoginRequest.java
  │   │   │   │   └── PasswordChangeRequest.java
  │   │   │   └── response/
  │   │   │       └── UserInfoResponse.java
  │   │   ├── entity/
  │   │   │   └── User.java
  │   │   ├── repository/
  │   │   │   └── UserRepository.java
  │   │   └── service/
  │   │       └── UserService.java
  │   │
  │   ├── friend/                   # 친구 관계 도메인
  │   │   ├── controller/
  │   │   ├── dto/
  │   │   ├── entity/
  │   │   │   └── Friendship.java
  │   │   ├── repository/
  │   │   └── service/
  │   │
  │   ├── location/                 # 위치 공유 도메인
  │   │   ├── controller/
  │   │   ├── dto/
  │   │   ├── entity/
  │   │   │   └── LocationShare.java
  │   │   ├── repository/
  │   │   └── service/
  │   │
  │   ├── shuttle/                  # 셔틀 버스 도메인
  │   │   ├── controller/
  │   │   ├── dto/
  │   │   ├── entity/
  │   │   │   ├── ShuttleRoute.java
  │   │   │   └── ShuttleStop.java
  │   │   ├── repository/
  │   │   └── service/
  │   │
  │   └── arrival/                  # 도착 시간 예측 도메인
  │       ├── controller/
  │       ├── dto/
  │       └── service/
  │           └── ArrivalTimeService.java  # 카카오 API 호출
  │
  └── global/
      ├── config/
      │   ├── SecurityConfig.java
      │   ├── RedisConfig.java
      │   ├── WebConfig.java         # CORS 설정
      │   └── JpaConfig.java
      ├── security/
      │   ├── jwt/
      │   │   ├── JwtTokenProvider.java
      │   │   ├── JwtAuthenticationFilter.java
      │   │   └── JwtProperties.java
      │   └── auth/
      │       ├── CustomUserDetails.java
      │       └── CustomUserDetailsService.java
      ├── error/
      │   ├── exception/
      │   │   ├── BusinessException.java
      │   │   ├── ErrorCode.java
      │   │   └── (각 도메인별 커스텀 Exception)
      │   └── GlobalExceptionHandler.java
      ├── common/
      │   ├── response/
      │   │   ├── ApiResponse.java
      │   │   └── ErrorResponse.java
      │   └── constants/
      │       └── Constants.java
      └── util/
          └── RedisUtil.java

  1.2 핵심 설계 원칙

  1. 도메인 중심 설계: 각 도메인은 독립적으로 동작 가능
  2. 단방향 의존성: Controller → Service → Repository
  3. DTO 분리: Entity 직접 노출 금지, Request/Response DTO 사용
  4. 예외 처리 통일: GlobalExceptionHandler로 중앙 관리
  5. API 응답 통일: ApiResponse 래퍼 클래스 사용

  ---
  🗄️ 2. 데이터베이스 설계

  2.1 핵심 엔티티

  User (사용자)

  @Entity
  @Table(name = "users")
  public class User extends BaseTimeEntity {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(unique = true, nullable = false)
      private String email;

      @Column(nullable = false)
      private String password;  // BCrypt 암호화

      @Column(nullable = false)
      private String name;

      @Column(nullable = false)
      private Boolean locationShareAgree = false;

      @Enumerated(EnumType.STRING)
      private Role role;  // USER, ADMIN
  }

  Friendship (친구 관계)

  @Entity
  public class Friendship extends BaseTimeEntity {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "requester_id")
      private User requester;  // 요청 보낸 사람

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "receiver_id")
      private User receiver;  // 요청 받은 사람

      @Enumerated(EnumType.STRING)
      private FriendshipStatus status;  // PENDING, ACCEPTED, REJECTED
  }

  LocationShare (위치 공유)

  @Entity
  public class LocationShare {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "user_id")
      private User user;

      @Column(nullable = false)
      private Double latitude;

      @Column(nullable = false)
      private Double longitude;

      @Column(nullable = false)
      private LocalDateTime startTime;

      @Column(nullable = false)
      private LocalDateTime endTime;  // 1시간 후

      @Column(nullable = false)
      private Boolean isActive = true;
  }

  ShuttleRoute (셔틀 노선)

  @Entity
  public class ShuttleRoute extends BaseTimeEntity {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(nullable = false)
      private String name;  // "1호차", "2호차"

      @Column(length = 500)
      private String description;

      @OneToMany(mappedBy = "route", cascade = CascadeType.ALL)
      private List<ShuttleStop> stops = new ArrayList<>();
  }

  ShuttleStop (경유지)

  @Entity
  public class ShuttleStop {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "route_id")
      private ShuttleRoute route;

      @Column(nullable = false)
      private String name;  // "광주역", "광주송정역"

      @Column(nullable = false)
      private Double latitude;

      @Column(nullable = false)
      private Double longitude;

      @Column(nullable = false)
      private Integer stopOrder;  // 순서 (1, 2, 3...)
  }

  2.2 BaseTimeEntity (공통 시간 필드)

  @MappedSuperclass
  @EntityListeners(AuditingEntityListener.class)
  public abstract class BaseTimeEntity {
      @CreatedDate
      @Column(updatable = false)
      private LocalDateTime createdAt;

      @LastModifiedDate
      private LocalDateTime updatedAt;
  }

  ---
  🔐 3. Spring Security + JWT + Redis 인증 시스템

  3.1 JWT 기반 인증 플로우

  1. 로그인 → JWT Access Token (1시간) + Refresh Token (7일) 발급
  2. Access Token을 Authorization Header에 포함하여 요청
  3. JwtAuthenticationFilter에서 토큰 검증
  4. 토큰 만료 시 Refresh Token으로 재발급
  5. Refresh Token은 Redis에 저장 (TTL: 7일)

  3.2 필요한 의존성 추가

  dependencies {
      // JWT
      implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
      runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.3'
      runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.3'

      // Redis
      implementation 'org.springframework.boot:spring-boot-starter-data-redis'

      // 카카오 API 호출
      implementation 'org.springframework.boot:spring-boot-starter-webflux'

      // (선택) WebSocket (추후 실시간 위치 업데이트용)
      // implementation 'org.springframework.boot:spring-boot-starter-websocket'
  }

  3.3 SecurityConfig 구조

  @Configuration
  @EnableWebSecurity
  @EnableMethodSecurity
  public class SecurityConfig {

      @Bean
      public SecurityFilterChain filterChain(HttpSecurity http) {
          return http
              .csrf(csrf -> csrf.disable())
              .cors(cors -> cors.configurationSource(corsConfigurationSource()))
              .sessionManagement(session ->
                  session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
              .authorizeHttpRequests(auth -> auth
                  .requestMatchers("/api/auth/**").permitAll()
                  .anyRequest().authenticated()
              )
              .addFilterBefore(jwtAuthenticationFilter,
                  UsernamePasswordAuthenticationFilter.class)
              .exceptionHandling(exception -> exception
                  .authenticationEntryPoint(jwtAuthenticationEntryPoint)
              )
              .build();
      }
  }

  ---
  📝 4. 개발 순서 및 단계별 학습 가이드

  Phase 0: 인프라 구축 (1-2일)

  목표: Docker로 MySQL과 Redis 환경 구축

  작업 내용

  1. Docker Compose 작성
  # docker-compose.yml
  version: '3.8'
  services:
    mysql:
      image: mysql:8.0
      container_name: shuttle-mysql
      environment:
        MYSQL_ROOT_PASSWORD: root1234
        MYSQL_DATABASE: shuttle_tracker
      ports:
        - "3306:3306"
      volumes:
        - mysql-data:/var/lib/mysql

    redis:
      image: redis:7-alpine
      container_name: shuttle-redis
      ports:
        - "6379:6379"
      volumes:
        - redis-data:/data

  volumes:
    mysql-data:
    redis-data:

  2. application.yml 설정
  spring:
    datasource:
      url: jdbc:mysql://localhost:3306/shuttle_tracker
      username: root
      password: root1234
    jpa:
      hibernate:
        ddl-auto: create  # 개발: create, 운영: validate
      show-sql: true
      properties:
        hibernate:
          format_sql: true
    redis:
      host: localhost
      port: 6379

  학습 자료

  - Docker 기본 개념: https://docs.docker.com/get-started/
  - Docker Compose: https://docs.docker.com/compose/

  ---
  Phase 1: 프로젝트 기반 설정 (1일)

  목표: 공통 설정 및 구조 준비

  작업 내용

  1. 패키지 구조 생성 (위 1.1 구조 참고)
  2. Global 설정 클래스
    - WebConfig (CORS)
    - JpaConfig (Auditing)
  3. 공통 응답 DTO
    - ApiResponse
    - ErrorResponse
  4. BaseTimeEntity 작성

  학습 자료

  - Spring Boot 패키지 구조 Best Practice
  - JPA Auditing: https://docs.spring.io/spring-data/jpa/reference/auditing.html

  ---
  Phase 2: 예외 처리 시스템 구축 (1일)

  목표: 통일된 예외 처리 체계 구축

  작업 내용

  1. ErrorCode Enum
  @Getter
  @RequiredArgsConstructor
  public enum ErrorCode {
      // 공통
      INVALID_INPUT_VALUE(400, "C001", "잘못된 입력값입니다."),
      UNAUTHORIZED(401, "C002", "인증이 필요합니다."),

      // User
      USER_NOT_FOUND(404, "U001", "사용자를 찾을 수 없습니다."),
      DUPLICATE_EMAIL(409, "U002", "이미 존재하는 이메일입니다."),
      INVALID_PASSWORD(400, "U003", "비밀번호가 일치하지 않습니다."),

      // Friend
      FRIENDSHIP_NOT_FOUND(404, "F001", "친구 관계를 찾을 수 없습니다."),
      ALREADY_FRIENDS(409, "F002", "이미 친구 관계입니다."),

      // Location
      LOCATION_SHARE_NOT_ACTIVE(400, "L001", "위치 공유가 활성화되지 않았습니다.");

      private final int status;
      private final String code;
      private final String message;
  }

  2. BusinessException
  3. GlobalExceptionHandler

  학습 자료

  - Spring @ControllerAdvice: https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc
  - Custom Exception 설계 패턴

  ---
  Phase 3: Spring Security + JWT 구현 (2-3일)

  목표: 인증/인가 시스템 완성

  작업 순서

  1. JwtTokenProvider 구현
    - Access Token 생성 (1시간)
    - Refresh Token 생성 (7일)
    - 토큰 검증
    - 토큰에서 사용자 정보 추출
  2. RedisUtil 구현
    - Refresh Token 저장
    - Blacklist (로그아웃된 토큰) 관리
  3. JwtAuthenticationFilter 구현
    - Authorization 헤더에서 토큰 추출
    - 토큰 검증
    - SecurityContext에 인증 정보 저장
  4. CustomUserDetailsService 구현
  5. SecurityConfig 작성

  학습 자료

  - JWT 개념: https://jwt.io/introduction
  - Spring Security Architecture: https://spring.io/guides/topicals/spring-security-architecture
  - Redis 기본: https://redis.io/docs/getting-started/

  ---
  Phase 4: User 도메인 구현 (2일)

  목표: 회원가입, 로그인, 사용자 정보 관리

  작업 순서

  1. Entity 작성: User.java
  2. Repository 작성: UserRepository.java
  3. Service 작성: UserService.java
    - 회원가입 (비밀번호 BCrypt 암호화)
    - 로그인 (JWT 발급)
    - 내 정보 조회
    - 비밀번호 변경
    - 위치 공유 동의 설정
  4. Controller 작성: UserController.java
    - POST /api/auth/signup
    - POST /api/auth/login
    - GET /api/auth/me
    - PUT /api/auth/password
    - PUT /api/auth/location-share-agree

  DTO 예시

  // Request
  @Getter
  @NoArgsConstructor
  public class SignUpRequest {
      @Email(message = "이메일 형식이 올바르지 않습니다.")
      @NotBlank
      private String email;

      @NotBlank
      @Pattern(regexp = "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,}$",
               message = "비밀번호는 8자 이상, 영문과 숫자를 포함해야 합니다.")
      private String password;

      @NotBlank
      private String name;
  }

  // Response
  @Getter
  @Builder
  public class LoginResponse {
      private String accessToken;
      private String refreshToken;
      private UserInfoResponse user;
  }

  학습 자료

  - Spring Data JPA: https://spring.io/projects/spring-data-jpa
  - Bean Validation: https://beanvalidation.org/
  - BCrypt 암호화: BCryptPasswordEncoder

  ---
  Phase 5: Friend 도메인 구현 (1-2일)

  목표: 친구 추가, 수락, 거절, 삭제

  작업 순서

  1. Entity: Friendship.java
  2. Repository: FriendshipRepository.java
    - 쿼리 메서드: findByRequesterAndReceiver, findAllByStatus 등
  3. Service: FriendshipService.java
  4. Controller: FriendshipController.java
    - GET /api/friends (ACCEPTED만)
    - POST /api/friends/request
    - PUT /api/friends/{id}/accept
    - PUT /api/friends/{id}/reject
    - DELETE /api/friends/{id}
    - GET /api/friends/pending

  학습 자료

  - JPA 연관관계 매핑: @ManyToOne, @OneToMany
  - JPQL 쿼리 작성

  ---
  Phase 6: Location 도메인 구현 (2일)

  목표: 위치 공유 시작/중지, 실시간 위치 업데이트

  작업 순서

  1. Entity: LocationShare.java
  2. Repository: LocationShareRepository.java
  3. Service: LocationService.java
    - 위치 공유 시작 (1시간 TTL 설정)
    - 위치 공유 중지
    - 내 위치 업데이트 (Redis에도 캐싱)
    - 친구 위치 조회
    - 스케줄러: 만료된 위치 공유 자동 비활성화
  4. Controller: LocationController.java

  중요 로직

  // 위치 공유 시작
  public void startSharing(Long userId, Double lat, Double lng) {
      LocalDateTime now = LocalDateTime.now();
      LocationShare locationShare = LocationShare.builder()
          .user(userRepository.findById(userId).orElseThrow())
          .latitude(lat)
          .longitude(lng)
          .startTime(now)
          .endTime(now.plusHours(1))  // 1시간 후 만료
          .isActive(true)
          .build();

      locationShareRepository.save(locationShare);

      // Redis에도 캐싱 (TTL: 1시간)
      redisUtil.setDataExpire("location:" + userId, locationShare, 3600);
  }

  학습 자료

  - Spring @Scheduled: https://spring.io/guides/gs/scheduling-tasks/
  - Redis TTL 설정

  ---
  Phase 7: Shuttle 도메인 구현 (1일)

  목표: 셔틀 노선 및 경유지 관리

  작업 순서

  1. Entity: ShuttleRoute.java, ShuttleStop.java
  2. Repository: ShuttleRouteRepository.java, ShuttleStopRepository.java
  3. Service: ShuttleService.java
    - 모든 노선 조회
    - 특정 노선의 경유지 조회 (stopOrder 순서대로)
    - 노선 검색
  4. Controller: ShuttleController.java

  초기 데이터 삽입

  -- sql/init-data.sql
  INSERT INTO shuttle_route (name, description) VALUES
  ('1호차', 'SSAFY 광주 1호차'),
  ('2호차', 'SSAFY 광주 2호차');

  INSERT INTO shuttle_stop (route_id, name, latitude, longitude, stop_order) VALUES
  (1, '광주역', 35.1160, 126.9172, 1),
  (1, '광주송정역', 35.1390, 126.7938, 2),
  (1, 'SSAFY 광주캠퍼스', 35.2019, 126.8095, 3);

  학습 자료

  - JPA @OneToMany 관계 설정
  - SQL 초기 데이터 로드: data.sql

  ---
  Phase 8: Arrival 도메인 구현 (2-3일)

  목표: 카카오 모빌리티 API 연동 및 도착 시간 예측

  작업 순서

  1. ArrivalTimeService 구현
    - 카카오 모빌리티 API 호출 (WebClient 사용)
    - 친구 위치 → 경유지 → 내 위치 경로 계산
    - 도착 시간 예측
  2. Controller: ArrivalController.java
    - POST /api/shuttle/arrival-time

  카카오 API 호출 예시

  @Service
  @RequiredArgsConstructor
  public class ArrivalTimeService {

      private final WebClient kakaoWebClient;

      @Value("${kakao.mobility.api-key}")
      private String kakaoApiKey;

      public ArrivalTimeResponse calculateArrivalTime(
          Long friendId,
          Location myLocation,
          List<Long> stopIds
      ) {
          // 1. 친구 위치 조회
          LocationShare friendLocation = locationShareRepository
              .findActiveByUserId(friendId)
              .orElseThrow(() -> new BusinessException(ErrorCode.LOCATION_SHARE_NOT_ACTIVE));

          // 2. 경유지 좌표 조회
          List<ShuttleStop> stops = shuttleStopRepository.findAllById(stopIds);

          // 3. 카카오 API로 경로 및 시간 계산
          String origin = friendLocation.getLatitude() + "," + friendLocation.getLongitude();
          String destination = myLocation.getLat() + "," + myLocation.getLng();
          String waypoints = stops.stream()
              .map(s -> s.getLatitude() + "," + s.getLongitude())
              .collect(Collectors.joining("|"));

          KakaoRouteResponse kakaoResponse = kakaoWebClient.get()
              .uri(uriBuilder -> uriBuilder
                  .path("/v1/waypoints/directions")
                  .queryParam("origin", origin)
                  .queryParam("destination", destination)
                  .queryParam("waypoints", waypoints)
                  .build())
              .header("Authorization", "KakaoAK " + kakaoApiKey)
              .retrieve()
              .bodyToMono(KakaoRouteResponse.class)
              .block();

          // 4. 응답 가공
          int durationMinutes = kakaoResponse.getDuration() / 60;
          LocalDateTime estimatedArrival = LocalDateTime.now().plusMinutes(durationMinutes);

          return ArrivalTimeResponse.builder()
              .routeName(stops.get(0).getRoute().getName())
              .estimatedMinutes(durationMinutes)
              .estimatedArrivalTime(estimatedArrival)
              .routePath(kakaoResponse.getCoordinates())
              .build();
      }
  }

  학습 자료

  - Spring WebClient: https://docs.spring.io/spring-framework/reference/web/webflux-webclient.html
  - 카카오 모빌리티 API: https://developers.kakaomobility.com/

  ---
  Phase 9: CI/CD 구축 (1-2일)

  목표: GitHub Actions로 자동 빌드 및 배포

  GitHub Actions Workflow

  # .github/workflows/deploy.yml
  name: Deploy to Server

  on:
    push:
      branches: [ main ]

  jobs:
    build-and-deploy:
      runs-on: ubuntu-latest

      steps:
      - uses: actions/checkout@v3

      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build with Gradle
        run: ./gradlew clean build -x test

      - name: Build Docker image
        run: docker build -t shuttle-tracker-be .

      - name: Push to Docker Hub (선택)
        # Docker Hub에 푸시하는 단계

      - name: Deploy to Server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            cd /app/shuttle-tracker
            docker-compose down
            docker-compose pull
            docker-compose up -d

  Dockerfile

  FROM openjdk:21-jdk-slim
  ARG JAR_FILE=build/libs/*.jar
  COPY ${JAR_FILE} app.jar
  EXPOSE 8080
  ENTRYPOINT ["java", "-jar", "/app.jar"]

  학습 자료

  - GitHub Actions: https://docs.github.com/en/actions
  - Docker 이미지 빌드: https://docs.docker.com/engine/reference/builder/

  ---
  🎯 5. MVP에서 제외할 것 (과한 것들)

  ❌ 제외 추천

  1. WebSocket 실시간 업데이트
    - 이유: 프론트가 새로고침 방식 채택
    - 나중에 추가 가능
  2. Admin 기능
    - 이유: 초기에는 직접 DB 관리
    - 노선/경유지는 SQL로 직접 삽입
  3. 소셜 로그인 (OAuth2)
    - 이유: 이메일/비밀번호 방식으로 충분
    - 나중에 추가 가능
  4. 이메일 인증
    - 이유: 내부 서비스 (SSAFY 교육생 대상)
  5. 복잡한 로깅 시스템 (ELK Stack)
    - 이유: 초기에는 Spring Boot 기본 로깅으로 충분
  6. 다중 프로필 환경 분리 (dev/prod/local)
    - 이유: 초기에는 application.yml 하나로 시작
    - 필요시 application-prod.yml 추가
  7. 복잡한 테스트 코드
    - 이유: MVP는 핵심 기능 위주 단위 테스트만
    - 통합 테스트는 시간 여유 있을 때

  ✅ 꼭 포함해야 할 것

  1. JWT + Redis 인증 (보안 기본)
  2. GlobalExceptionHandler (에러 처리 통일)
  3. Validation (입력값 검증)
  4. CORS 설정 (프론트 연동 필수)
  5. Docker Compose (개발 환경 통일)
  6. 기본 CI/CD (자동 배포)

  ---
  📚 6. 학습 자료 총정리

  필수 학습

  1. Spring Boot 기본
    - 공식 문서: https://spring.io/projects/spring-boot
    - 인프런 - 김영한의 스프링 부트 (추천)
  2. Spring Data JPA
    - 공식 문서: https://spring.io/projects/spring-data-jpa
    - 연관관계 매핑, JPQL
  3. Spring Security + JWT
    - Spring Security 공식 문서
    - JWT.io 이해하기
    - 블로그: "Spring Boot 3 + JWT 인증 구현"
  4. Docker
    - Docker 공식 튜토리얼
    - Docker Compose 사용법
  5. Redis
    - Redis 공식 문서 - Getting Started
    - Spring Data Redis 사용법

  참고 자료

  - 우아한형제들 기술 블로그
  - 카카오 기술 블로그
  - Baeldung (Spring 관련 튜토리얼)

  ---
  🚀 7. 개발 일정 (예상)

  | Phase | 내용                    | 예상 소요 시간 |
  |-------|-----------------------|----------|
  | 0     | Docker 인프라 구축         | 1-2일     |
  | 1     | 프로젝트 기반 설정            | 1일       |
  | 2     | 예외 처리 시스템             | 1일       |
  | 3     | Spring Security + JWT | 2-3일     |
  | 4     | User 도메인              | 2일       |
  | 5     | Friend 도메인            | 1-2일     |
  | 6     | Location 도메인          | 2일       |
  | 7     | Shuttle 도메인           | 1일       |
  | 8     | Arrival 도메인 (카카오 API) | 2-3일     |
  | 9     | CI/CD 구축              | 1-2일     |
  | 총계    |                       | 약 2-3주   |

  ---
  💡 8. 개발 팁

  8.1 코딩 컨벤션

  - 클래스명: PascalCase (UserService)
  - 메서드명: camelCase (findUserById)
  - 상수: UPPER_SNAKE_CASE (MAX_LOGIN_ATTEMPTS)
  - 패키지: 소문자 (com.ssafy.shuttle_tracker)

  8.2 Git Commit 메시지

  feat: 새로운 기능 추가
  fix: 버그 수정
  refactor: 코드 리팩토링
  docs: 문서 수정
  test: 테스트 코드 추가
  chore: 빌드 설정 등

  예시: feat: User 도메인 회원가입 API 구현

  8.3 디버깅 팁

  - Postman으로 API 테스트
  - H2 Console로 개발 초기 DB 확인
  - Spring Boot Actuator (선택)

  ---
  ⎿  User rejected Claude's plan:
     ╭───────────────────────────────────────────────────────────────────────────────────╮
     │ SSAFY 셔틀 트래커 백엔드 개발 계획                                                │
     │                                                                                   │
     │ 📋 아키텍처 설계                                                                  │
     │                                                                                   │
     │ - 도메인 중심 계층 구조: User, Friend, Location, Shuttle, Arrival 도메인으로 분리 │
     │ - 이전 프로젝트와 유사한 구조: controller/dto/entity/repository/service 패턴 채택 │
     │ - MVP 원칙: 필수 기능만 구현 (WebSocket, Admin, OAuth2 제외)                      │
     │                                                                                   │
     │ 🛠️ 기술 스택                                                                     │
     │                                                                                   │
     │ - Spring Boot 3.5.7 + JPA + Spring Security                                       │
     │ - MySQL (Docker) + Redis (Docker)                                                 │
     │ - JWT 인증 (Access Token 1시간, Refresh Token 7일)                                │
     │ - 카카오 모빌리티 API (도착 시간 예측)                                            │
     │ - GitHub Actions (CI/CD)                                                          │
     │                                                                                   │
     │ 📝 개발 순서 (총 2-3주 예상)                                                      │
     │                                                                                   │
     │ Phase 0-2: 기반 구축 (3-4일)                                                      │
     │                                                                                   │
     │ 1. Docker Compose로 MySQL + Redis 구축                                            │
     │ 2. 패키지 구조 생성 (domain별 계층 분리)                                          │
     │ 3. GlobalExceptionHandler, ErrorCode, ApiResponse 등 공통 설정                    │
     │                                                                                   │
     │ Phase 3: 인증 시스템 (2-3일)                                                      │
     │                                                                                   │
     │ - Spring Security + JWT + Redis 구현                                              │
     │ - JwtTokenProvider, JwtAuthenticationFilter, SecurityConfig                       │
     │                                                                                   │
     │ Phase 4-7: 핵심 도메인 구현 (6-7일)                                               │
     │                                                                                   │
     │ - User: 회원가입, 로그인, 정보 수정                                               │
     │ - Friend: 친구 추가/수락/거절/삭제                                                │
     │ - Location: 위치 공유 시작/중지, 1시간 자동 만료                                  │
     │ - Shuttle: 노선 및 경유지 조회                                                    │
     │                                                                                   │
     │ Phase 8: 카카오 API 연동 (2-3일)                                                  │
     │                                                                                   │
     │ - WebClient로 카카오 모빌리티 API 호출                                            │
     │ - 도착 시간 예측 로직 구현                                                        │
     │                                                                                   │
     │ Phase 9: CI/CD (1-2일)                                                            │
     │                                                                                   │
     │ - GitHub Actions Workflow 설정                                                    │
     │ - Docker 이미지 빌드 및 자동 배포                                                 │
     │                                                                                   │
     │ 📚 학습 필요 항목                                                                 │
     │                                                                                   │
     │ - Docker & Docker Compose 기본                                                    │
     │ - Spring Security + JWT 인증 구조                                                 │
     │ - Spring Data JPA 연관관계 매핑                                                   │
     │ - Redis 기본 사용법 (TTL, 캐싱)                                                   │
     │ - WebClient를 통한 외부 API 호출                                                  │
     │                                                                                   │
     │ ✅ MVP에 포함                                                                      │
     │                                                                                   │
     │ - JWT + Redis 인증, 예외 처리, Validation, CORS, Docker, 기본 CI/CD               │
     │                                                                                   │
     │ ❌ MVP에서 제외                                                                    │
     │                                                                                   │
     │ - WebSocket, Admin 기능, 소셜 로그인, 이메일 인증, ELK Stack, 복잡한 테스트       │
     │                                                                                   │
     │ ---                                                                               │
     │ 이 계획으로 진행해도 될까요? 구체적인 질문이나 수정 사항이 있으면 말씀해주세요!   │
     ╰───────────────────────────────────────────────────────────────────────────────────╯

> 아 깜빡했다. 지금 세우고 있는 계획 Sequential Thinking MCP 사용해서 한 번 더 점검해줘.

● Sequential Thinking으로 계획을 점검하겠습니다.

● sequential-thinking - sequentialthinking (MCP)(thought: "SSAFY 셔틀 트래커 백엔드 프로젝트의 요구사항을
                                                정리해보자.\n\n핵심 기능:\n1. 사용자 인증 (회원가입, 로그인, JWT)\n2.
                                                친구 관리 (추가, 수락, 거절, 삭제)\n3. 위치 공유 (1시간 자동 만료,
                                                ON/OFF)\n4. 셔틀 노선 및 경유지 조회\n5. 도착 시간 예측 (카카오 API
                                                연동)\n\n기술 스택:\n- Spring Boot 3.5.7, JPA, Spring Security\n- MySQL
                                                + Redis (Docker)\n- JWT 인증\n- 카카오 모 il리티 API\n\n프로젝트
                                                특징:\n- MVP 프로젝트 (빠른 서비스 출시 필요)\n- 주니어 개발자 대상\n-
                                                이전 프로젝트 구조 참고 (domain별 계층 구조)\n\n계획 검증을 위해
                                                고려해야 할 관점:\n1. 개발 순서의 적절성\n2. 학습 곡선 고려\n3. MVP
                                                범위의 적절성\n4. 기술 스택의 타당성\n5. 놓친 요구사항은 없는지",
                                                thoughtNumber: 1, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 1,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Phase 0 (Docker 인프라 구축)부터 검토해보자.\n\n제안한 순서:
                                                Docker MySQL + Redis 구축 → application.yml 설정\n\n검토:\n✅ 장점: 개발
                                                 환경을 먼저 갖추는 것은 합리적\n⚠️ 우려: 주니어 개발자가 Docker를 처음
                                                접하면 1-2일로는 부족할 수 있음\n⚠️ 우려: Docker 없이도 로컬 MySQL로
                                                시작할 수 있는데, 필수로 Docker를 강제하는 것이 맞나?\n\n개선 방안:\n-
                                                Docker는 \"권장\"이지만 선택사항으로 두기\n- 또는 Docker Compose 파일을
                                                미리 완성해서 제공하고, `docker-compose up -d` 한 번만 실행하면
                                                되도록\n- 로컬 MySQL 설치 옵션도 함께 제시\n\n결론: Docker 구축 단계를
                                                더 명확하게 하거나, 대안 제시 필요", thoughtNumber: 2, totalThoughts:
                                                15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 2,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Phase 1-2 (프로젝트 기반 설정 + 예외 처리)를
                                                검토해보자.\n\n제안 순서:\n1. 패키지 구조 생성\n2. WebConfig, JpaConfig
                                                등 공통 설정\n3. ApiResponse, ErrorResponse\n4. BaseTimeEntity\n5.
                                                ErrorCode, BusinessException, GlobalExceptionHandler\n\n검토:\n✅ 장점:
                                                공통 인프라를 먼저 구축하는 것은 좋은 접근\n❌ 문제점: 주니어 개발자
                                                입장에서 \"추상적인 것\"부터 시작하면 동기부여가 떨어질 수 있음\n❌
                                                문제점: 예외 처리 시스템을 먼저 만들어도, 실제 도메인 로직이 없으면
                                                테스트할 수 없음\n\n대안:\n- 먼저 가장 단순한 도메인(User
                                                회원가입/로그인)을 만들어보고\n- 그 과정에서 필요한 예외 처리를
                                                점진적으로 추가하는 방식\n- \"동작하는 코드\"를 빨리 만들어보는 것이
                                                학습에 더 효과적\n\n이것은 \"Top-down vs Bottom-up\" 접근의 차이인데,
                                                주니어에게는 Bottom-up이 더 나을 수 있음", thoughtNumber: 3,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 3,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Phase 3 (Spring Security + JWT) 시점을 검토해보자.\n\n제안
                                                순서: User 도메인보다 먼저 Security + JWT를 구현\n\n검토:\n❌ 큰 문제:
                                                Spring Security와 JWT는 매우 복잡한 주제\n❌ 주니어가 User Entity도 없는
                                                 상태에서 CustomUserDetailsService를 만들 수 없음\n❌ 로그인 로직도
                                                없는데 JWT를 먼저 구현하면 테스트 불가능\n❌ 학습 곡선: Security는
                                                Spring에서 가장 어려운 부분 중 하나\n\n올바른 순서:\n1. 먼저 User
                                                도메인을 Security 없이 구현 (회원가입, 조회)\n2. 간단한 로그인 API를
                                                만들어보기 (Security 없이)\n3. 그 다음에 Spring Security를 적용하면서
                                                점진적으로 개선\n4. 마지막으로 JWT 추가\n\n이유:\n- \"동작하는 코드\"를
                                                먼저 만들고 점진적으로 보안을 강화하는 것이 학습에 효과적\n- Spring
                                                Security의 필요성을 체감한 후에 적용해야 이해도가 높아짐",
                                                thoughtNumber: 4, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 4,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "도메인 간 의존성을 검토해보자.\n\n제안된 도메인 구현 순서:
                                                User → Friend → Location → Shuttle → Arrival\n\n의존성 분석:\n- Friend는
                                                 User에 의존 (Friendship이 User를 참조)\n- Location은 User에 의존
                                                (LocationShare가 User를 참조)\n- Shuttle은 독립적 (ShuttleRoute,
                                                ShuttleStop)\n- Arrival은 Location + Shuttle + Friend에 모두
                                                의존\n\n검토:\n✅ User를 먼저 하는 것은 맞음\n⚠️ Friend와 Location은
                                                병렬로 개발 가능한데 순차적으로 제안됨\n⚠️ Shuttle은 다른 도메인과
                                                독립적이므로 더 일찍 할 수 있음\n\n개선된 순서:\n1. User (기본 CRUD)\n2.
                                                 Shuttle (독립적이므로 병렬 가능)\n3. Friend + Location (병렬 가능)\n4.
                                                Arrival (모든 도메인이 준비된 후)\n\n또는 학습 관점에서:\n1. Shuttle
                                                (가장 단순, JPA 연습용)\n2. User (인증 제외한 기본 기능)\n3. Friend
                                                (연관관계 학습)\n4. Location (스케줄러, Redis 학습)\n5. 인증 시스템
                                                (Security + JWT)\n6. Arrival (외부 API 연동)\n\n후자가 학습 곡선
                                                측면에서 더 나을 수 있음", thoughtNumber: 5, totalThoughts: 15,
                                                nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 5,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Redis 사용 시점을 검토해보자.\n\n제안에서 Redis 사용처:\n1.
                                                JWT Refresh Token 저장\n2. 로그아웃 토큰 Blacklist\n3. Location 데이터
                                                캐싱\n\n검토:\n⚠️ 문제: Redis를 Phase 0에 설치하지만, 실제 사용은 Phase
                                                3 (JWT), Phase 6 (Location)\n⚠️ 문제: 주니어가 Redis를 언제 왜 쓰는지
                                                모르는 채로 설치만 해두면 혼란\n⚠️ 문제: MVP에서 Redis가 정말
                                                필수인가?\n\n대안 검토:\n1. JWT Refresh Token → 초기에는 DB에 저장해도
                                                됨 (성능은 떨어지지만 동작함)\n2. Blacklist → 초기 MVP에서는 생략 가능
                                                (토큰 만료 시간만으로도 충분)\n3. Location 캐싱 → DB만으로도 충분히 빠름
                                                 (사용자 수가 많지 않으면)\n\n결론:\n- Redis는 \"성능 최적화\" 단계에서
                                                추가하는 것이 학습 관점에서 더 나을 수 있음\n- 또는 Redis를 쓴다면, 왜
                                                필요한지 명확히 설명하고 실제 사용 시점에 도입", thoughtNumber: 6,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 6,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "build.gradle의 의존성을 다시 확인해보자.\n\n현재 설정된
                                                의존성:\n- spring-boot-starter-validation ✅\n-
                                                spring-boot-starter-data-jpa ✅\n- spring-boot-starter-security ✅\n-
                                                spring-boot-starter-web ✅\n- lombok ✅\n- mysql-connector-j ✅\n- h2
                                                (테스트용) ✅\n\n제안에서 추가하려는 것:\n- JWT 라이브러리 (jjwt)\n-
                                                Redis (spring-boot-starter-data-redis)\n- WebFlux (카카오 API
                                                호출용)\n\n검토:\n✅ JWT는 필수\n⚠️ Redis는 앞서 검토했듯이 선택적\n✅
                                                WebFlux (WebClient)는 카카오 API 호출에 필요\n\n추가 고려사항:\n-
                                                RestTemplate vs WebClient: WebClient가 최신이지만 주니어에게는
                                                RestTemplate이 더 직관적일 수 있음\n- 하지만 RestTemplate은 deprecated
                                                예정이므로 WebClient 학습이 장기적으로 유리\n\n결론: 의존성 추가 계획은
                                                적절함", thoughtNumber: 7, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 7,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Location 도메인의 1시간 자동 만료 로직을
                                                검토해보자.\n\n제안된 구현:\n- LocationShare Entity에 startTime, endTime
                                                 저장\n- @Scheduled로 만료된 항목을 주기적으로 isActive = false로
                                                변경\n- Redis에도 TTL 1시간으로 캐싱\n\n검토:\n✅ startTime, endTime을
                                                DB에 저장하는 것은 좋음\n⚠️ @Scheduled로 배치 처리하는 방식의 문제점:\n
                                                 - 스케줄러가 5분마다 돌면, 만료 후 최대 5분 지연 발생\n  - 만료 시점이
                                                정확하지 않음\n  \n대안:\n1. 조회 시점에 endTime과 현재 시간을 비교
                                                (Lazy Evaluation)\n   - 장점: 정확함, 추가 스케줄러 불필요\n   - 단점:
                                                매번 시간 비교 필요\n   \n2. Redis TTL만 사용하고 DB는 로그용\n   -
                                                장점: Redis가 자동으로 만료 처리\n   - 단점: Redis 장애 시 데이터
                                                손실\n\nMVP 추천: \n- 방안 1 (조회 시점 검증)이 가장 단순하고 안정적\n-
                                                추가로 @Scheduled (1시간마다)로 정리하는 정도면 충분", thoughtNumber: 8,
                                                 totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 8,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "카카오 모빌리티 API 연동 부분을 검토해보자.\n\n제안된
                                                구현:\n- WebClient로 카카오 경로 API 호출\n- origin (친구 위치) →
                                                waypoints (경유지들) → destination (내 위치)\n- 결과로 소요 시간 및 경로
                                                 좌표 반환\n\n검토:\n✅ WebClient 사용은 적절함\n⚠️ 복잡도: 카카오 API는
                                                 여러 종류가 있고 문서가 복잡함\n⚠️ 비용: 카카오 모빌리티 API는 유료일
                                                수 있음\n\n확인 필요사항:\n1. 카카오 모빌리티 API vs 카카오맵 API
                                                차이\n2. 무료 티어 존재 여부\n3. Waypoints를 지원하는 API가
                                                맞는지\n\n대안:\n- 초기 MVP에서는 단순 직선거리 계산으로 시작\n- 나중에
                                                실제 API 연동\n- 또는 구글 Directions API 고려 (월 $200 무료
                                                크레딧)\n\n추천:\n- 일단 카카오 API 명세를 먼저 확인하고 계획 수정\n-
                                                MVP에서는 mock 데이터나 단순 계산으로 시작하는 것도 고려",
                                                thoughtNumber: 9, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 9,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "CI/CD 계획을 검토해보자.\n\n제안: GitHub Actions로 자동 빌드
                                                및 배포\n\n제안된 워크플로우:\n1. main 브랜치 push 시 트리거\n2. Gradle
                                                빌드\n3. Docker 이미지 빌드\n4. 서버로 SSH 접속하여 배포\n\n검토:\n⚠️
                                                문제: MVP 단계에서 CI/CD가 우선순위가 높은가?\n⚠️ 문제: SSH 키, 서버
                                                호스트 등의 인프라가 준비되어 있는가?\n⚠️ 문제: 주니어가 GitHub
                                                Actions를 처음 다룬다면 시간이 많이 소요될 수 있음\n\n대안:\n1. 초기에는
                                                 수동 배포 (jar 파일 빌드 후 서버에 업로드)\n2. 핵심 기능 완성 후 CI/CD
                                                추가\n3. 또는 더 간단한 방식: GitHub Actions로 빌드만 자동화 (배포는
                                                수동)\n\n우선순위 재조정:\n- Phase 1-8: 핵심 기능 구현\n- Phase 9: CI/CD
                                                 (선택사항, 시간 여유 있을 때)\n\n결론: CI/CD는 \"좋으면 하는 것\"이지
                                                MVP 필수는 아님", thoughtNumber: 10, totalThoughts: 15,
                                                nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 10,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "CLAUDE.md에서 프론트엔드 요구사항을 다시 확인해보자.\n\n핵심
                                                API 엔드포인트 (프론트에서 필요한 것):\n1. POST /api/auth/login,
                                                /api/auth/signup\n2. POST /api/location/start, /api/location/stop, PUT
                                                /api/location/update\n3. GET /api/friends, POST /api/friends/request,
                                                PUT /api/friends/:id/accept/reject\n4. GET /api/shuttle/routes, GET
                                                /api/shuttle/routes/:id/stops\n5. POST /api/shuttle/arrival-time\n6.
                                                검색 API: GET /api/shuttle/routes/search, GET
                                                /api/friends/search\n\n추가 필요한 API (제안에서 누락):\n❌ 친구 이름
                                                검색 API가 명시되어 있지만, 실제로는 \"이메일로 검색\"이 필요\n❌ GET
                                                /api/location/friends - 모든 친구들의 위치를 한번에 조회하는 API 필요\n
                                                  (현재는 GET /api/location/friend/:friendId로 한명씩만 조회
                                                가능)\n\n검토:\n- 프론트엔드 요구사항: \"친구 관계인 모든 유저의 위치
                                                마커 표시\"\n- 이를 위해서는 친구 목록 조회 → 각 친구의 위치 조회 (N+1
                                                문제 발생)\n- 더 나은 방법: GET /api/location/friends 엔드포인트로
                                                한번에 조회\n\n결론: Location API 설계에 보완 필요", thoughtNumber: 11,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 11,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Entity 설계를 다시 검토해보자.\n\nFriendship Entity:\n-
                                                requester (요청 보낸 사람)\n- receiver (요청 받은 사람)\n- status
                                                (PENDING, ACCEPTED, REJECTED)\n\n검토:\n✅ 기본 설계는 괜찮음\n⚠️ 쿼리
                                                복잡도: \"내 친구 목록\"을 조회하려면?\n  - WHERE (requester_id = 나 OR
                                                receiver_id = 나) AND status = ACCEPTED\n  - 양방향 관계 때문에 쿼리가
                                                복잡해짐\n\n대안:\n1. 현재 설계 유지 + Repository에서 복잡한 쿼리
                                                작성\n2. ACCEPTED 상태가 되면 양방향 레코드 2개 생성 (더 단순한 쿼리)\n
                                                  - (A→B, ACCEPTED), (B→A, ACCEPTED)\n   - 단점: 데이터 중복\n\n추천:\n-
                                                 방안 1 유지 (정규화)\n- JPA 쿼리 메서드 예시 제공 필요:\n  ```java\n
                                                @Query(\"SELECT f FROM Friendship f WHERE (f.requester.id = :userId OR
                                                f.receiver.id = :userId) AND f.status = 'ACCEPTED'\")\n
                                                List<Friendship> findMyFriends(@Param(\"userId\") Long userId);\n
                                                ```\n\n결론: Entity 설계는 괜찮지만 Repository 쿼리 예시 추가 필요",
                                                thoughtNumber: 12, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 12,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Validation 전략을 검토해보자.\n\n제안에서 Validation:\n-
                                                @Email, @NotBlank, @Pattern 등 Bean Validation 사용\n- SignUpRequest에서
                                                 비밀번호 정규식 검증\n\n검토:\n✅ Bean Validation 사용은 좋은 접근\n⚠️
                                                주의: 비밀번호 확인(password, passwordConfirm) 검증은?\n⚠️ 주의: 이메일
                                                중복 체크는 어디서?\n\n필요한 Validation 레이어:\n1. DTO 레벨: @Valid로
                                                기본 형식 검증\n2. Service 레벨: 비즈니스 로직 검증 (중복 체크 등)\n3.
                                                Custom Validator: 복잡한 검증 (비밀번호 일치 등)\n\n예시:\n```java\n//
                                                DTO\n@Getter\npublic class SignUpRequest {\n    @Email\n    private
                                                String email;\n    \n    @Pattern(regexp =
                                                \"^(?=.*[A-Za-z])(?=.*\\\\d)[A-Za-z\\\\d]{8,}$\")\n    private String
                                                password;\n    \n    private String passwordConfirm;\n}\n\n//
                                                Service\npublic void signUp(SignUpRequest request) {\n    // 비밀번호
                                                일치 검증\n    if
                                                (!request.getPassword().equals(request.getPasswordConfirm())) {\n
                                                 throw new BusinessException(ErrorCode.PASSWORD_NOT_MATCH);\n    }\n
                                                \n    // 이메일 중복 검증\n    if
                                                (userRepository.existsByEmail(request.getEmail())) {\n        throw new
                                                BusinessException(ErrorCode.DUPLICATE_EMAIL);\n    }\n
                                                ...\n}\n```\n\n결론: Validation 전략은 괜찮지만 더 구체적인 예시 필요",
                                                thoughtNumber: 13, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 13,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "학습 자료와 시간 예상을 검토해보자.\n\n제안된 총 소요 시간:
                                                2-3주\n\nPhase별 소요 시간:\n- Phase 0 (Docker): 1-2일\n- Phase 1
                                                (기반): 1일\n- Phase 2 (예외처리): 1일\n- Phase 3 (Security+JWT):
                                                2-3일\n- Phase 4-7 (도메인): 6-7일\n- Phase 8 (카카오 API): 2-3일\n-
                                                Phase 9 (CI/CD): 1-2일\n합계: 14-21일\n\n검토:\n⚠️ 문제: 주니어 개발자가
                                                 처음 Spring을 배우면서 진행한다면 2-3주는 매우 빡빡함\n⚠️ 문제: 학습
                                                시간이 고려되지 않음 (순수 개발 시간만 계산)\n⚠️ 문제: 디버깅, 오류 수정
                                                 시간 미포함\n\n현실적인 예상:\n- 학습하면서 개발: 3-4주\n- 오류 해결
                                                버퍼: +1주\n- 총 4-5주가 더 현실적\n\n또한:\n- 매일 풀타임으로 개발할 수
                                                 있는가?\n- SSAFY 교육 중이라면 병행해야 하므로 더 길어질 수
                                                있음\n\n결론: 시간 예상을 더 보수적으로 조정 필요", thoughtNumber: 14,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 14,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "전체 계획을 종합하여 개선안을 정리해보자.\n\n발견한 주요
                                                문제점:\n1. 개발 순서: 추상적인 것(예외처리, Security)을 먼저 하면 학습
                                                곡선이 가파름\n2. Redis: MVP에서 필수가 아닌데 초기부터 도입\n3.
                                                Security+JWT: User 도메인보다 먼저 구현할 수 없음\n4. API 누락: 친구들의
                                                 위치를 한번에 조회하는 API\n5. 시간 예상: 너무 낙관적 (학습 시간
                                                미포함)\n6. CI/CD: MVP 우선순위가 아님\n7. 카카오 API: 비용/복잡도 고려
                                                필요\n\n개선된 개발 순서 제안:\n1. **환경 설정** (1-2일): Docker MySQL
                                                (Redis는 나중에)\n2. **Shuttle 도메인** (1-2일): 가장 단순, JPA
                                                학습용\n3. **User 도메인 (인증 제외)** (2일): 기본 CRUD\n4. **공통
                                                인프라** (1일): 예외처리, Validation (필요성을 체감한 후)\n5. **Friend
                                                도메인** (2일): 연관관계 학습\n6. **Location 도메인** (2일): 위치 공유
                                                기본\n7. **Spring Security + JWT** (3-4일): 이제 적용\n8. **Arrival
                                                도메인** (2-3일): 카카오 API (또는 mock)\n9. **Redis 최적화** (1일):
                                                선택사항\n10. **CI/CD** (1-2일): 선택사항\n\n이 순서의 장점:\n- 단순한
                                                것부터 복잡한 것으로\n- 각 단계에서 동작하는 코드를 만들며 학습\n- 필수
                                                기능 우선, 최적화는 나중에", thoughtNumber: 15, totalThoughts: 15,
                                                nextThoughtNeeded: false)
  ⎿  {
       "thoughtNumber": 15,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● Sequential Thinking으로 계획을 점검한 결과, 몇 가지 중요한 문제점을 발견했습니다. 개선된 계획을 제시하겠습니다.

  ---
  🔍 Sequential Thinking 점검 결과

  ❌ 발견된 주요 문제점

  1. 개발 순서의 문제

  - 문제: 예외 처리, Security+JWT를 User 도메인보다 먼저 구현
  - 이유: 실제 도메인 로직 없이 추상적인 인프라만 만들면 테스트 불가능하고 학습 효과 낮음
  - 개선: 단순한 도메인부터 시작 → 필요성 체감 후 인프라 추가

  2. Redis의 시기상조

  - 문제: Phase 0에 Redis 설치하지만 실제 사용은 Phase 3, 6
  - 이유: MVP에서 Redis는 "성능 최적화"이지 필수가 아님
  - 개선: 일단 DB만으로 구현 → 나중에 Redis 추가 (또는 생략)

  3. 누락된 API

  - 문제: 프론트에서 "모든 친구의 위치"를 한번에 조회해야 하는데 API 없음
  - 개선: GET /api/location/friends 엔드포인트 추가 필요

  4. 비현실적인 일정

  - 문제: 2-3주 예상 (학습 시간 미포함, 디버깅 시간 미포함)
  - 개선: 현실적으로 4-5주 (주니어 + 학습 포함)

  5. CI/CD 우선순위

  - 문제: MVP 단계에서 CI/CD를 필수로 제안
  - 개선: 핵심 기능 완성 후 선택적으로 추가

  ---
  📋 개선된 개발 계획

  🎯 핵심 원칙 변경

  기존 계획 (Top-Down)

  인프라 구축 → 예외처리 → Security → 도메인

  개선된 계획 (Bottom-Up)

  단순 도메인 → 필요한 인프라 → 복잡한 기능 → 최적화

  이유: 주니어 개발자는 "동작하는 코드"를 빠르게 만들어보며 학습하는 것이 효과적

  ---
  🚀 새로운 개발 순서

  Phase 0: 환경 설정 (1-2일)

  목표: 최소한의 개발 환경 구축

  작업:
  1. Docker Compose로 MySQL만 구축 (Redis는 나중에)
  services:
    mysql:
      image: mysql:8.0
      ports: ["3306:3306"]
      environment:
        MYSQL_DATABASE: shuttle_tracker
  2. application.yml 기본 설정
  3. 프로젝트 실행 확인

  학습: Docker 기본, MySQL 연결

  ---
  Phase 1: Shuttle 도메인 (1-2일)

  목표: 가장 단순한 도메인으로 JPA 학습

  왜 먼저?
  - 다른 도메인과 독립적
  - 인증 불필요
  - CRUD 기본 학습에 최적

  작업:
  1. Entity 작성: ShuttleRoute, ShuttleStop
  2. Repository: @OneToMany 관계 학습
  3. Service: 기본 조회 로직
  4. Controller: REST API 작성
    - GET /api/shuttle/routes
    - GET /api/shuttle/routes/{id}/stops
    - GET /api/shuttle/routes/search?q={query}
  5. SQL로 초기 데이터 삽입

  학습:
  - JPA Entity, Repository 기본
  - @OneToMany 연관관계
  - Spring Web Controller
  - SQL 초기 데이터 로드

  결과: Postman으로 실제 동작하는 API 확인 가능!

  ---
  Phase 2: User 도메인 - 기본편 (2일)

  목표: 인증 없이 User CRUD 구현

  작업:
  1. Entity: User (email, password, name)
  2. Repository: 기본 메서드
  3. Service:
    - 회원가입 (비밀번호 BCrypt 암호화)
    - 이메일로 사용자 검색
    - 내 정보 조회
  4. Controller:
    - POST /api/users (회원가입)
    - GET /api/users/search?email={email} (검색)
    - GET /api/users/{id} (조회)

  학습:
  - BCryptPasswordEncoder
  - Bean Validation (@Email, @NotBlank)
  - DTO 패턴 (Request/Response 분리)

  보안은?: 일단 인증 없이 만들어봄 (학습용)

  ---
  Phase 3: 공통 인프라 구축 (1일)

  목표: 지금까지 개발하며 느낀 필요성을 해결

  작업:
  1. GlobalExceptionHandler
    - 지금까지 발생한 예외들을 한곳에서 처리
  2. ErrorCode Enum
  USER_NOT_FOUND(404, "U001", "사용자를 찾을 수 없습니다.")
  DUPLICATE_EMAIL(409, "U002", "이미 존재하는 이메일입니다.")
  3. ApiResponse 통일
  {
    "success": true,
    "data": {...},
    "error": null
  }
  4. BaseTimeEntity (createdAt, updatedAt)

  학습:
  - @ControllerAdvice
  - Custom Exception 설계

  왜 이제?: 실제 예외가 발생해봐야 필요성을 체감함

  ---
  Phase 4: Friend 도메인 (2일)

  목표: 연관관계 심화 학습

  작업:
  1. Entity: Friendship
    - @ManyToOne User requester
    - @ManyToOne User receiver
    - FriendshipStatus status
  2. Repository:
  @Query("SELECT f FROM Friendship f WHERE (f.requester.id = :userId OR f.receiver.id = :userId) AND f.status =
  'ACCEPTED'")
  List<Friendship> findMyFriends(@Param("userId") Long userId);
  3. Service: 친구 추가/수락/거절/삭제
  4. Controller:
    - GET /api/friends (내 친구 목록)
    - POST /api/friends/request
    - PUT /api/friends/{id}/accept
    - DELETE /api/friends/{id}

  학습:
  - 양방향 관계 처리
  - JPQL 작성
  - 복잡한 비즈니스 로직

  ---
  Phase 5: Location 도메인 (2일)

  목표: 위치 공유 로직 구현

  작업:
  1. Entity: LocationShare
  private LocalDateTime startTime;
  private LocalDateTime endTime; // startTime + 1시간
  private Boolean isActive;
  2. Service:
    - 위치 공유 시작/중지
    - 위치 업데이트
    - 중요: GET /api/location/friends (모든 친구 위치 한번에 조회)
    - 조회 시 endTime과 현재 시간 비교 (만료 검증)
  3. @Scheduled (1시간마다 만료된 데이터 정리)

  학습:
  - LocalDateTime 사용
  - @Scheduled 태스크
  - 효율적인 쿼리 (N+1 방지)

  ---
  Phase 6: Spring Security + JWT (3-4일)

  목표: 기존 API에 인증 추가

  왜 이제?:
  - User, Friend, Location이 모두 동작하는 상태
  - 이제 "보호"가 필요함을 체감

  작업:
  1. JWT 의존성 추가
  implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
  2. JwtTokenProvider 구현
  3. JwtAuthenticationFilter 구현
  4. SecurityConfig 작성
  .requestMatchers("/api/auth/**", "/api/shuttle/**").permitAll()
  .anyRequest().authenticated()
  5. 로그인 API 추가
    - POST /api/auth/login → JWT 발급
  6. 기존 API에 인증 적용

  학습:
  - Spring Security Architecture
  - JWT 토큰 생성/검증
  - Filter Chain

  Refresh Token은?:
  - 초기에는 Access Token만 (1일 TTL)
  - 나중에 필요하면 추가

  ---
  Phase 7: Arrival 도메인 (2-3일)

  목표: 도착 시간 예측

  작업:
  1. 카카오 API 조사
    - 비용 확인
    - API 명세 확인
    - 무료 대안 탐색
  2. WebClient 설정
  3. ArrivalTimeService 구현
  4. 대안: 초기에는 단순 거리 계산으로 mock
  // 하버사인 공식으로 직선거리 계산
  double distance = calculateDistance(friendLoc, myLoc);
  int estimatedMinutes = (int)(distance / 평균속도);

  학습:
  - WebClient 사용
  - 외부 API 연동
  - 에러 핸들링

  ---
  Phase 8: Redis 최적화 (선택, 1일)

  목표: 성능 개선

  Redis 도입 시점:
  - Refresh Token 저장
  - Location 데이터 캐싱 (TTL 1시간)

  작업:
  1. Docker Compose에 Redis 추가
  2. RedisUtil 구현
  3. LocationService에 캐싱 로직 추가

  왜 선택?: MVP에서 사용자가 많지 않으면 불필요

  ---
  Phase 9: CI/CD (선택, 1-2일)

  목표: 자동 배포

  작업:
  1. GitHub Actions 워크플로우
  2. Docker 이미지 빌드
  3. 서버 배포 자동화

  왜 선택?: 핵심 기능 완성이 우선

  ---
  📊 개선된 일정 예상

  | Phase | 내용             | 예상 소요 (주니어+학습) |
  |-------|----------------|----------------|
  | 0     | 환경 설정          | 1-2일           |
  | 1     | Shuttle 도메인    | 1-2일           |
  | 2     | User 도메인 기본    | 2일             |
  | 3     | 공통 인프라         | 1일             |
  | 4     | Friend 도메인     | 2일             |
  | 5     | Location 도메인   | 2일             |
  | 6     | Security + JWT | 3-4일           |
  | 7     | Arrival 도메인    | 2-3일           |
  | 8     | Redis (선택)     | 1일             |
  | 9     | CI/CD (선택)     | 1-2일           |
  | 버퍼    | 디버깅, 오류 수정     | 3-5일           |
  | 총계    |                | 4-5주 (현실적)     |

  ---
  ✅ MVP 필수 vs 선택

  필수 (3주 목표)

  - ✅ Phase 0-7 (Redis, CI/CD 제외)
  - ✅ JWT 인증
  - ✅ 핵심 도메인 기능
  - ✅ 예외 처리

  선택 (시간 여유 시)

  - ⭐ Redis 최적화
  - ⭐ CI/CD
  - ⭐ 실제 카카오 API 연동 (초기에는 mock 가능)
  - ⭐ WebSocket 실시간 업데이트

  ---
  📚 단계별 학습 자료

  Phase 1-2: JPA 기초

  - 김영한 - 자바 ORM 표준 JPA 프로그래밍 (인프런)
  - Spring Data JPA 공식 문서

  Phase 3: 예외 처리

  - Baeldung - Exception Handling in Spring
  - 우아한형제들 기술 블로그 - 예외 처리 전략

  Phase 4-5: JPA 심화

  - N+1 문제 해결
  - JPQL vs QueryDSL

  Phase 6: Spring Security

  - 김영한 - 스프링 시큐리티 (인프런)
  - JWT.io 공식 문서
  - Baeldung - Spring Security + JWT

  Phase 7: WebClient

  - Spring WebFlux 공식 문서
  - 카카오 모빌리티 API 문서

  ---
  💡 추가 개선 사항

  1. API 명세 보완

  // 추가 필요
  GET /api/location/friends          // 모든 친구 위치 한번에 조회
  GET /api/users/search?email={email} // 이메일로 사용자 검색

  2. Validation 강화

  // SignUpRequest에 추가
  private String passwordConfirm;

  // Service에서 검증
  if (!password.equals(passwordConfirm)) {
      throw new BusinessException(ErrorCode.PASSWORD_NOT_MATCH);
  }

  3. 위치 만료 로직 개선

  // 조회 시점에 검증 (Lazy Evaluation)
  public Optional<LocationShare> getActiveLocation(Long userId) {
      return locationShareRepository.findByUserId(userId)
          .filter(loc -> loc.getEndTime().isAfter(LocalDateTime.now()))
          .filter(LocationShare::getIsActive);
  }

  ---

╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Ready to code?                                                                                                       │
│                                                                                                                      │
│ Here is Claude's plan:                                                                                               │
│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │
│ │ Sequential Thinking 점검 완료 - 개선된 백엔드 개발 계획                                                          │ │
│ │                                                                                                                  │ │
│ │ 🔍 주요 개선 사항                                                                                                │ │
│ │                                                                                                                  │ │
│ │ 1. 개발 순서 대폭 수정 (Bottom-Up 접근)                                                                          │ │
│ │                                                                                                                  │ │
│ │ 기존: 인프라 → Security → 도메인개선: 단순 도메인 → 필요 인프라 → 복잡 기능                                      │ │
│ │                                                                                                                  │ │
│ │ 새로운 순서:                                                                                                     │ │
│ │ 1. Shuttle 도메인 (가장 단순, JPA 학습)                                                                          │ │
│ │ 2. User 도메인 기본 (인증 제외)                                                                                  │ │
│ │ 3. 공통 인프라 (필요성 체감 후)                                                                                  │ │
│ │ 4. Friend 도메인 (연관관계)                                                                                      │ │
│ │ 5. Location 도메인 (스케줄러)                                                                                    │ │
│ │ 6. Spring Security + JWT (이제 적용)                                                                             │ │
│ │ 7. Arrival 도메인 (카카오 API)                                                                                   │ │
│ │                                                                                                                  │ │
│ │ 이유: 주니어는 "동작하는 코드"를 빠르게 만들며 학습하는 것이 효과적                                              │ │
│ │                                                                                                                  │ │
│ │ 2. Redis를 선택사항으로 변경                                                                                     │ │
│ │                                                                                                                  │ │
│ │ - MVP에서 Redis는 "최적화"이지 필수 아님                                                                         │ │
│ │ - 초기에는 DB만으로 충분                                                                                         │ │
│ │ - Phase 8에서 선택적으로 추가                                                                                    │ │
│ │                                                                                                                  │ │
│ │ 3. CI/CD 우선순위 하향                                                                                           │ │
│ │                                                                                                                  │ │
│ │ - 핵심 기능 완성이 우선                                                                                          │ │
│ │ - Phase 9에서 선택사항으로                                                                                       │ │
│ │                                                                                                                  │ │
│ │ 4. 누락된 API 추가                                                                                               │ │
│ │                                                                                                                  │ │
│ │ - GET /api/location/friends (모든 친구 위치 한번에)                                                              │ │
│ │ - GET /api/users/search?email={email} (이메일 검색)                                                              │ │
│ │                                                                                                                  │ │
│ │ 5. 현실적인 일정 조정                                                                                            │ │
│ │                                                                                                                  │ │
│ │ 기존: 2-3주개선: 4-5주 (학습 시간 + 디버깅 버퍼 포함)                                                            │ │
│ │                                                                                                                  │ │
│ │ 📋 최종 개발 순서 (3주 MVP 목표)                                                                                 │ │
│ │                                                                                                                  │ │
│ │ Week 1: 기초 다지기                                                                                              │ │
│ │                                                                                                                  │ │
│ │ - Phase 0-2: 환경 + Shuttle + User 기본                                                                          │ │
│ │                                                                                                                  │ │
│ │ Week 2: 핵심 도메인                                                                                              │ │
│ │                                                                                                                  │ │
│ │ - Phase 3-5: 인프라 + Friend + Location                                                                          │ │
│ │                                                                                                                  │ │
│ │ Week 3: 인증 & 통합                                                                                              │ │
│ │                                                                                                                  │ │
│ │ - Phase 6-7: Security + JWT + Arrival                                                                            │ │
│ │                                                                                                                  │ │
│ │ Week 4-5: 여유분 (선택)                                                                                          │ │
│ │                                                                                                                  │ │
│ │ - Redis, CI/CD, 디버깅, 개선                                                                                     │ │
│ │                                                                                                                  │ │
│ │ 📚 학습 로드맵 명확화                                                                                            │ │
│ │                                                                                                                  │ │
│ │ 각 Phase마다 구체적인 학습 자료와 실습 목표 제시                                                                 │ │
│ │                                                                                                                  │ │
│ │ 이 개선된 계획으로 진행하시겠습니까?                                                                             │ │
│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │
│                                                                                                                      │
│ Would you like to proceed?                                                                                           │
│                                                                                                                      │
│   1. Yes, and auto-accept edits                                                                                      │
│ > 2. Yes, and manually approve edits                                                                                 │
│   3. No, keep planning                                                                                               │
│                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
ctrl-g to edit plan in start

╭─── Claude Code v2.0.26 ──────────────────────────────────────────────────────────────────────────────────────────────╮
│                                                    │ Tips for getting started                                        │
│               Welcome back jedo5000!               │ Run /install-github-app to tag @claude right from your Github … │
│                                                    │ √ Run /init to create a CLAUDE.md file with instructions for C… │
│                       ▐▛███▜▌                      │ ─────────────────────────────────────────────────────────────── │
│                      ▝▜█████▛▘                     │ Recent activity                                                 │
│                        ▘▘ ▝▝                       │ No recent activity                                              │
│                                                    │                                                                 │
│              Sonnet 4.5 · Claude Pro               │                                                                 │
│ C:\Users\SSAFY\projects\shuttle-tracker\shuttle-t… │                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

> # 백엔드

너는 java, Spring을 사용하는 우수기업의 10년차 시니어 백엔드 개발자야. 나는 아직 스프링에 대한 개념, 실력이 부족한
학생이고 프로젝트를 만들려해.

shuttle-tracker-be 프로젝트의 [CLAUDE.md](http://CLAUDE.md), DEVELOPMENT.md, FRONT_README.md, tree.txt를 읽고
프로젝트 파악을 해야함.

1. 프로젝트 세팅 → Springboot로 받고 gradle 설정했음. 코딩 컨벤션 숙지
2. Docker로 MySQL과 Redis Container 만들어서 사용하기, Docker 사용하는 법 공부해야함.
3. git action으로 CI/CD 구축하기
4. 구조 세팅 → domain 별 디렉토리 구조 채택 / 그리고 주니어 개발자로서 내가 백엔드를 어떤 순서대로 무엇을 설계하고
구현해야할지 잘 모르겠어. 알려줬으면 좋겠어.
    1. Entity 설계
    2. Spring security, redis + jwt 사용
    3. tree.txt의 과거 프로젝트 구조와 비슷한 구조로 프로젝트 진행 예정
    4. exceptionhandler, exception, validation 등등 필요한 것들을 넣고 학습할 예정(but MVP 프로젝트이고 바로
서비스해야하므로 과한건 빼고싶음. 추천 부탁함.)
    5. JPA 활용

너가 직접 코드를 짜는게 아닌 아키텍쳐를 어떻게 설계해야하는지, (너무 전 프로젝트를 무조건 따를 필요는 없어. ) 어떻게
 내가 이것들을 구현해 나가야하는지, 무엇을 공부하고 참고해야하는지를 계획 세운걸 받고싶어.

● 프로젝트 파악을 위해 관련 문서들을 먼저 읽어보겠습니다.

● Read(CLAUDE.md)
  ⎿  Read 141 lines

● Read(DEVELOPMENT.md)
  ⎿  Read 385 lines

● Read(FRONT_README.md)
  ⎿  Read 153 lines

● Read(tree.txt)
  ⎿  Read 138 lines

● 현재 프로젝트의 상태를 추가로 확인하겠습니다.

● Search(pattern: "**/*.gradle")
  ⎿  Found 2 files (ctrl+o to expand)

● Search(pattern: "**/application*.yml")
  ⎿  Found 2 files (ctrl+o to expand)

● Search(pattern: "**/application*.properties")
  ⎿  Found 0 files

● Read(build.gradle)
  ⎿  Read 45 lines

● Read(src\main\resources\application.yml)
  ⎿  Read 16 lines

● Search(pattern: "src/main/java/**/*.java")
  ⎿  Found 1 file (ctrl+o to expand)

● 좋습니다! 프로젝트 파악을 완료했습니다. 이제 SSAFY 셔틀 버스 위치 추적 서비스의 백엔드 아키텍처와 개발 계획을
  제시하겠습니다.

  ---
  🎯 SSAFY 셔틀 트래커 백엔드 아키텍처 & 개발 로드맵

  📊 프로젝트 현황 분석

  ✅ 완료된 것

  - Spring Boot 3.5.7 + Gradle 프로젝트 세팅
  - 기본 의존성: JPA, Security, Validation, MySQL, Lombok
  - application.yml 기본 구조 (주석 처리)

  🔧 진행 필요

  1. Docker를 통한 MySQL + Redis 인프라 구축
  2. 도메인별 계층 구조 설계 및 구현
  3. Spring Security + JWT + Redis 인증 시스템
  4. 핵심 비즈니스 로직 구현
  5. CI/CD (GitHub Actions)

  ---
  🏗️ 1. 아키텍처 설계

  1.1 계층 구조 (Layered Architecture)

  이전 프로젝트와 동일한 도메인 기반 구조를 채택하되, MVP에 맞게 단순화합니다.

  src/main/java/com/ssafy/shuttle_tracker/
  ├── domain/
  │   ├── user/                     # 사용자 도메인
  │   │   ├── controller/
  │   │   │   └── UserController.java
  │   │   ├── dto/
  │   │   │   ├── request/
  │   │   │   │   ├── SignUpRequest.java
  │   │   │   │   ├── LoginRequest.java
  │   │   │   │   └── PasswordChangeRequest.java
  │   │   │   └── response/
  │   │   │       └── UserInfoResponse.java
  │   │   ├── entity/
  │   │   │   └── User.java
  │   │   ├── repository/
  │   │   │   └── UserRepository.java
  │   │   └── service/
  │   │       └── UserService.java
  │   │
  │   ├── friend/                   # 친구 관계 도메인
  │   │   ├── controller/
  │   │   ├── dto/
  │   │   ├── entity/
  │   │   │   └── Friendship.java
  │   │   ├── repository/
  │   │   └── service/
  │   │
  │   ├── location/                 # 위치 공유 도메인
  │   │   ├── controller/
  │   │   ├── dto/
  │   │   ├── entity/
  │   │   │   └── LocationShare.java
  │   │   ├── repository/
  │   │   └── service/
  │   │
  │   ├── shuttle/                  # 셔틀 버스 도메인
  │   │   ├── controller/
  │   │   ├── dto/
  │   │   ├── entity/
  │   │   │   ├── ShuttleRoute.java
  │   │   │   └── ShuttleStop.java
  │   │   ├── repository/
  │   │   └── service/
  │   │
  │   └── arrival/                  # 도착 시간 예측 도메인
  │       ├── controller/
  │       ├── dto/
  │       └── service/
  │           └── ArrivalTimeService.java  # 카카오 API 호출
  │
  └── global/
      ├── config/
      │   ├── SecurityConfig.java
      │   ├── RedisConfig.java
      │   ├── WebConfig.java         # CORS 설정
      │   └── JpaConfig.java
      ├── security/
      │   ├── jwt/
      │   │   ├── JwtTokenProvider.java
      │   │   ├── JwtAuthenticationFilter.java
      │   │   └── JwtProperties.java
      │   └── auth/
      │       ├── CustomUserDetails.java
      │       └── CustomUserDetailsService.java
      ├── error/
      │   ├── exception/
      │   │   ├── BusinessException.java
      │   │   ├── ErrorCode.java
      │   │   └── (각 도메인별 커스텀 Exception)
      │   └── GlobalExceptionHandler.java
      ├── common/
      │   ├── response/
      │   │   ├── ApiResponse.java
      │   │   └── ErrorResponse.java
      │   └── constants/
      │       └── Constants.java
      └── util/
          └── RedisUtil.java

  1.2 핵심 설계 원칙

  1. 도메인 중심 설계: 각 도메인은 독립적으로 동작 가능
  2. 단방향 의존성: Controller → Service → Repository
  3. DTO 분리: Entity 직접 노출 금지, Request/Response DTO 사용
  4. 예외 처리 통일: GlobalExceptionHandler로 중앙 관리
  5. API 응답 통일: ApiResponse 래퍼 클래스 사용

  ---
  🗄️ 2. 데이터베이스 설계

  2.1 핵심 엔티티

  User (사용자)

  @Entity
  @Table(name = "users")
  public class User extends BaseTimeEntity {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(unique = true, nullable = false)
      private String email;

      @Column(nullable = false)
      private String password;  // BCrypt 암호화

      @Column(nullable = false)
      private String name;

      @Column(nullable = false)
      private Boolean locationShareAgree = false;

      @Enumerated(EnumType.STRING)
      private Role role;  // USER, ADMIN
  }

  Friendship (친구 관계)

  @Entity
  public class Friendship extends BaseTimeEntity {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "requester_id")
      private User requester;  // 요청 보낸 사람

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "receiver_id")
      private User receiver;  // 요청 받은 사람

      @Enumerated(EnumType.STRING)
      private FriendshipStatus status;  // PENDING, ACCEPTED, REJECTED
  }

  LocationShare (위치 공유)

  @Entity
  public class LocationShare {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "user_id")
      private User user;

      @Column(nullable = false)
      private Double latitude;

      @Column(nullable = false)
      private Double longitude;

      @Column(nullable = false)
      private LocalDateTime startTime;

      @Column(nullable = false)
      private LocalDateTime endTime;  // 1시간 후

      @Column(nullable = false)
      private Boolean isActive = true;
  }

  ShuttleRoute (셔틀 노선)

  @Entity
  public class ShuttleRoute extends BaseTimeEntity {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(nullable = false)
      private String name;  // "1호차", "2호차"

      @Column(length = 500)
      private String description;

      @OneToMany(mappedBy = "route", cascade = CascadeType.ALL)
      private List<ShuttleStop> stops = new ArrayList<>();
  }

  ShuttleStop (경유지)

  @Entity
  public class ShuttleStop {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "route_id")
      private ShuttleRoute route;

      @Column(nullable = false)
      private String name;  // "광주역", "광주송정역"

      @Column(nullable = false)
      private Double latitude;

      @Column(nullable = false)
      private Double longitude;

      @Column(nullable = false)
      private Integer stopOrder;  // 순서 (1, 2, 3...)
  }

  2.2 BaseTimeEntity (공통 시간 필드)

  @MappedSuperclass
  @EntityListeners(AuditingEntityListener.class)
  public abstract class BaseTimeEntity {
      @CreatedDate
      @Column(updatable = false)
      private LocalDateTime createdAt;

      @LastModifiedDate
      private LocalDateTime updatedAt;
  }

  ---
  🔐 3. Spring Security + JWT + Redis 인증 시스템

  3.1 JWT 기반 인증 플로우

  1. 로그인 → JWT Access Token (1시간) + Refresh Token (7일) 발급
  2. Access Token을 Authorization Header에 포함하여 요청
  3. JwtAuthenticationFilter에서 토큰 검증
  4. 토큰 만료 시 Refresh Token으로 재발급
  5. Refresh Token은 Redis에 저장 (TTL: 7일)

  3.2 필요한 의존성 추가

  dependencies {
      // JWT
      implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
      runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.3'
      runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.3'

      // Redis
      implementation 'org.springframework.boot:spring-boot-starter-data-redis'

      // 카카오 API 호출
      implementation 'org.springframework.boot:spring-boot-starter-webflux'

      // (선택) WebSocket (추후 실시간 위치 업데이트용)
      // implementation 'org.springframework.boot:spring-boot-starter-websocket'
  }

  3.3 SecurityConfig 구조

  @Configuration
  @EnableWebSecurity
  @EnableMethodSecurity
  public class SecurityConfig {

      @Bean
      public SecurityFilterChain filterChain(HttpSecurity http) {
          return http
              .csrf(csrf -> csrf.disable())
              .cors(cors -> cors.configurationSource(corsConfigurationSource()))
              .sessionManagement(session ->
                  session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
              .authorizeHttpRequests(auth -> auth
                  .requestMatchers("/api/auth/**").permitAll()
                  .anyRequest().authenticated()
              )
              .addFilterBefore(jwtAuthenticationFilter,
                  UsernamePasswordAuthenticationFilter.class)
              .exceptionHandling(exception -> exception
                  .authenticationEntryPoint(jwtAuthenticationEntryPoint)
              )
              .build();
      }
  }

  ---
  📝 4. 개발 순서 및 단계별 학습 가이드

  Phase 0: 인프라 구축 (1-2일)

  목표: Docker로 MySQL과 Redis 환경 구축

  작업 내용

  1. Docker Compose 작성
  # docker-compose.yml
  version: '3.8'
  services:
    mysql:
      image: mysql:8.0
      container_name: shuttle-mysql
      environment:
        MYSQL_ROOT_PASSWORD: root1234
        MYSQL_DATABASE: shuttle_tracker
      ports:
        - "3306:3306"
      volumes:
        - mysql-data:/var/lib/mysql

    redis:
      image: redis:7-alpine
      container_name: shuttle-redis
      ports:
        - "6379:6379"
      volumes:
        - redis-data:/data

  volumes:
    mysql-data:
    redis-data:

  2. application.yml 설정
  spring:
    datasource:
      url: jdbc:mysql://localhost:3306/shuttle_tracker
      username: root
      password: root1234
    jpa:
      hibernate:
        ddl-auto: create  # 개발: create, 운영: validate
      show-sql: true
      properties:
        hibernate:
          format_sql: true
    redis:
      host: localhost
      port: 6379

  학습 자료

  - Docker 기본 개념: https://docs.docker.com/get-started/
  - Docker Compose: https://docs.docker.com/compose/

  ---
  Phase 1: 프로젝트 기반 설정 (1일)

  목표: 공통 설정 및 구조 준비

  작업 내용

  1. 패키지 구조 생성 (위 1.1 구조 참고)
  2. Global 설정 클래스
    - WebConfig (CORS)
    - JpaConfig (Auditing)
  3. 공통 응답 DTO
    - ApiResponse
    - ErrorResponse
  4. BaseTimeEntity 작성

  학습 자료

  - Spring Boot 패키지 구조 Best Practice
  - JPA Auditing: https://docs.spring.io/spring-data/jpa/reference/auditing.html

  ---
  Phase 2: 예외 처리 시스템 구축 (1일)

  목표: 통일된 예외 처리 체계 구축

  작업 내용

  1. ErrorCode Enum
  @Getter
  @RequiredArgsConstructor
  public enum ErrorCode {
      // 공통
      INVALID_INPUT_VALUE(400, "C001", "잘못된 입력값입니다."),
      UNAUTHORIZED(401, "C002", "인증이 필요합니다."),

      // User
      USER_NOT_FOUND(404, "U001", "사용자를 찾을 수 없습니다."),
      DUPLICATE_EMAIL(409, "U002", "이미 존재하는 이메일입니다."),
      INVALID_PASSWORD(400, "U003", "비밀번호가 일치하지 않습니다."),

      // Friend
      FRIENDSHIP_NOT_FOUND(404, "F001", "친구 관계를 찾을 수 없습니다."),
      ALREADY_FRIENDS(409, "F002", "이미 친구 관계입니다."),

      // Location
      LOCATION_SHARE_NOT_ACTIVE(400, "L001", "위치 공유가 활성화되지 않았습니다.");

      private final int status;
      private final String code;
      private final String message;
  }

  2. BusinessException
  3. GlobalExceptionHandler

  학습 자료

  - Spring @ControllerAdvice: https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc
  - Custom Exception 설계 패턴

  ---
  Phase 3: Spring Security + JWT 구현 (2-3일)

  목표: 인증/인가 시스템 완성

  작업 순서

  1. JwtTokenProvider 구현
    - Access Token 생성 (1시간)
    - Refresh Token 생성 (7일)
    - 토큰 검증
    - 토큰에서 사용자 정보 추출
  2. RedisUtil 구현
    - Refresh Token 저장
    - Blacklist (로그아웃된 토큰) 관리
  3. JwtAuthenticationFilter 구현
    - Authorization 헤더에서 토큰 추출
    - 토큰 검증
    - SecurityContext에 인증 정보 저장
  4. CustomUserDetailsService 구현
  5. SecurityConfig 작성

  학습 자료

  - JWT 개념: https://jwt.io/introduction
  - Spring Security Architecture: https://spring.io/guides/topicals/spring-security-architecture
  - Redis 기본: https://redis.io/docs/getting-started/

  ---
  Phase 4: User 도메인 구현 (2일)

  목표: 회원가입, 로그인, 사용자 정보 관리

  작업 순서

  1. Entity 작성: User.java
  2. Repository 작성: UserRepository.java
  3. Service 작성: UserService.java
    - 회원가입 (비밀번호 BCrypt 암호화)
    - 로그인 (JWT 발급)
    - 내 정보 조회
    - 비밀번호 변경
    - 위치 공유 동의 설정
  4. Controller 작성: UserController.java
    - POST /api/auth/signup
    - POST /api/auth/login
    - GET /api/auth/me
    - PUT /api/auth/password
    - PUT /api/auth/location-share-agree

  DTO 예시

  // Request
  @Getter
  @NoArgsConstructor
  public class SignUpRequest {
      @Email(message = "이메일 형식이 올바르지 않습니다.")
      @NotBlank
      private String email;

      @NotBlank
      @Pattern(regexp = "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,}$",
               message = "비밀번호는 8자 이상, 영문과 숫자를 포함해야 합니다.")
      private String password;

      @NotBlank
      private String name;
  }

  // Response
  @Getter
  @Builder
  public class LoginResponse {
      private String accessToken;
      private String refreshToken;
      private UserInfoResponse user;
  }

  학습 자료

  - Spring Data JPA: https://spring.io/projects/spring-data-jpa
  - Bean Validation: https://beanvalidation.org/
  - BCrypt 암호화: BCryptPasswordEncoder

  ---
  Phase 5: Friend 도메인 구현 (1-2일)

  목표: 친구 추가, 수락, 거절, 삭제

  작업 순서

  1. Entity: Friendship.java
  2. Repository: FriendshipRepository.java
    - 쿼리 메서드: findByRequesterAndReceiver, findAllByStatus 등
  3. Service: FriendshipService.java
  4. Controller: FriendshipController.java
    - GET /api/friends (ACCEPTED만)
    - POST /api/friends/request
    - PUT /api/friends/{id}/accept
    - PUT /api/friends/{id}/reject
    - DELETE /api/friends/{id}
    - GET /api/friends/pending

  학습 자료

  - JPA 연관관계 매핑: @ManyToOne, @OneToMany
  - JPQL 쿼리 작성

  ---
  Phase 6: Location 도메인 구현 (2일)

  목표: 위치 공유 시작/중지, 실시간 위치 업데이트

  작업 순서

  1. Entity: LocationShare.java
  2. Repository: LocationShareRepository.java
  3. Service: LocationService.java
    - 위치 공유 시작 (1시간 TTL 설정)
    - 위치 공유 중지
    - 내 위치 업데이트 (Redis에도 캐싱)
    - 친구 위치 조회
    - 스케줄러: 만료된 위치 공유 자동 비활성화
  4. Controller: LocationController.java

  중요 로직

  // 위치 공유 시작
  public void startSharing(Long userId, Double lat, Double lng) {
      LocalDateTime now = LocalDateTime.now();
      LocationShare locationShare = LocationShare.builder()
          .user(userRepository.findById(userId).orElseThrow())
          .latitude(lat)
          .longitude(lng)
          .startTime(now)
          .endTime(now.plusHours(1))  // 1시간 후 만료
          .isActive(true)
          .build();

      locationShareRepository.save(locationShare);

      // Redis에도 캐싱 (TTL: 1시간)
      redisUtil.setDataExpire("location:" + userId, locationShare, 3600);
  }

  학습 자료

  - Spring @Scheduled: https://spring.io/guides/gs/scheduling-tasks/
  - Redis TTL 설정

  ---
  Phase 7: Shuttle 도메인 구현 (1일)

  목표: 셔틀 노선 및 경유지 관리

  작업 순서

  1. Entity: ShuttleRoute.java, ShuttleStop.java
  2. Repository: ShuttleRouteRepository.java, ShuttleStopRepository.java
  3. Service: ShuttleService.java
    - 모든 노선 조회
    - 특정 노선의 경유지 조회 (stopOrder 순서대로)
    - 노선 검색
  4. Controller: ShuttleController.java

  초기 데이터 삽입

  -- sql/init-data.sql
  INSERT INTO shuttle_route (name, description) VALUES
  ('1호차', 'SSAFY 광주 1호차'),
  ('2호차', 'SSAFY 광주 2호차');

  INSERT INTO shuttle_stop (route_id, name, latitude, longitude, stop_order) VALUES
  (1, '광주역', 35.1160, 126.9172, 1),
  (1, '광주송정역', 35.1390, 126.7938, 2),
  (1, 'SSAFY 광주캠퍼스', 35.2019, 126.8095, 3);

  학습 자료

  - JPA @OneToMany 관계 설정
  - SQL 초기 데이터 로드: data.sql

  ---
  Phase 8: Arrival 도메인 구현 (2-3일)

  목표: 카카오 모빌리티 API 연동 및 도착 시간 예측

  작업 순서

  1. ArrivalTimeService 구현
    - 카카오 모빌리티 API 호출 (WebClient 사용)
    - 친구 위치 → 경유지 → 내 위치 경로 계산
    - 도착 시간 예측
  2. Controller: ArrivalController.java
    - POST /api/shuttle/arrival-time

  카카오 API 호출 예시

  @Service
  @RequiredArgsConstructor
  public class ArrivalTimeService {

      private final WebClient kakaoWebClient;

      @Value("${kakao.mobility.api-key}")
      private String kakaoApiKey;

      public ArrivalTimeResponse calculateArrivalTime(
          Long friendId,
          Location myLocation,
          List<Long> stopIds
      ) {
          // 1. 친구 위치 조회
          LocationShare friendLocation = locationShareRepository
              .findActiveByUserId(friendId)
              .orElseThrow(() -> new BusinessException(ErrorCode.LOCATION_SHARE_NOT_ACTIVE));

          // 2. 경유지 좌표 조회
          List<ShuttleStop> stops = shuttleStopRepository.findAllById(stopIds);

          // 3. 카카오 API로 경로 및 시간 계산
          String origin = friendLocation.getLatitude() + "," + friendLocation.getLongitude();
          String destination = myLocation.getLat() + "," + myLocation.getLng();
          String waypoints = stops.stream()
              .map(s -> s.getLatitude() + "," + s.getLongitude())
              .collect(Collectors.joining("|"));

          KakaoRouteResponse kakaoResponse = kakaoWebClient.get()
              .uri(uriBuilder -> uriBuilder
                  .path("/v1/waypoints/directions")
                  .queryParam("origin", origin)
                  .queryParam("destination", destination)
                  .queryParam("waypoints", waypoints)
                  .build())
              .header("Authorization", "KakaoAK " + kakaoApiKey)
              .retrieve()
              .bodyToMono(KakaoRouteResponse.class)
              .block();

          // 4. 응답 가공
          int durationMinutes = kakaoResponse.getDuration() / 60;
          LocalDateTime estimatedArrival = LocalDateTime.now().plusMinutes(durationMinutes);

          return ArrivalTimeResponse.builder()
              .routeName(stops.get(0).getRoute().getName())
              .estimatedMinutes(durationMinutes)
              .estimatedArrivalTime(estimatedArrival)
              .routePath(kakaoResponse.getCoordinates())
              .build();
      }
  }

  학습 자료

  - Spring WebClient: https://docs.spring.io/spring-framework/reference/web/webflux-webclient.html
  - 카카오 모빌리티 API: https://developers.kakaomobility.com/

  ---
  Phase 9: CI/CD 구축 (1-2일)

  목표: GitHub Actions로 자동 빌드 및 배포

  GitHub Actions Workflow

  # .github/workflows/deploy.yml
  name: Deploy to Server

  on:
    push:
      branches: [ main ]

  jobs:
    build-and-deploy:
      runs-on: ubuntu-latest

      steps:
      - uses: actions/checkout@v3

      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build with Gradle
        run: ./gradlew clean build -x test

      - name: Build Docker image
        run: docker build -t shuttle-tracker-be .

      - name: Push to Docker Hub (선택)
        # Docker Hub에 푸시하는 단계

      - name: Deploy to Server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            cd /app/shuttle-tracker
            docker-compose down
            docker-compose pull
            docker-compose up -d

  Dockerfile

  FROM openjdk:21-jdk-slim
  ARG JAR_FILE=build/libs/*.jar
  COPY ${JAR_FILE} app.jar
  EXPOSE 8080
  ENTRYPOINT ["java", "-jar", "/app.jar"]

  학습 자료

  - GitHub Actions: https://docs.github.com/en/actions
  - Docker 이미지 빌드: https://docs.docker.com/engine/reference/builder/

  ---
  🎯 5. MVP에서 제외할 것 (과한 것들)

  ❌ 제외 추천

  1. WebSocket 실시간 업데이트
    - 이유: 프론트가 새로고침 방식 채택
    - 나중에 추가 가능
  2. Admin 기능
    - 이유: 초기에는 직접 DB 관리
    - 노선/경유지는 SQL로 직접 삽입
  3. 소셜 로그인 (OAuth2)
    - 이유: 이메일/비밀번호 방식으로 충분
    - 나중에 추가 가능
  4. 이메일 인증
    - 이유: 내부 서비스 (SSAFY 교육생 대상)
  5. 복잡한 로깅 시스템 (ELK Stack)
    - 이유: 초기에는 Spring Boot 기본 로깅으로 충분
  6. 다중 프로필 환경 분리 (dev/prod/local)
    - 이유: 초기에는 application.yml 하나로 시작
    - 필요시 application-prod.yml 추가
  7. 복잡한 테스트 코드
    - 이유: MVP는 핵심 기능 위주 단위 테스트만
    - 통합 테스트는 시간 여유 있을 때

  ✅ 꼭 포함해야 할 것

  1. JWT + Redis 인증 (보안 기본)
  2. GlobalExceptionHandler (에러 처리 통일)
  3. Validation (입력값 검증)
  4. CORS 설정 (프론트 연동 필수)
  5. Docker Compose (개발 환경 통일)
  6. 기본 CI/CD (자동 배포)

  ---
  📚 6. 학습 자료 총정리

  필수 학습

  1. Spring Boot 기본
    - 공식 문서: https://spring.io/projects/spring-boot
    - 인프런 - 김영한의 스프링 부트 (추천)
  2. Spring Data JPA
    - 공식 문서: https://spring.io/projects/spring-data-jpa
    - 연관관계 매핑, JPQL
  3. Spring Security + JWT
    - Spring Security 공식 문서
    - JWT.io 이해하기
    - 블로그: "Spring Boot 3 + JWT 인증 구현"
  4. Docker
    - Docker 공식 튜토리얼
    - Docker Compose 사용법
  5. Redis
    - Redis 공식 문서 - Getting Started
    - Spring Data Redis 사용법

  참고 자료

  - 우아한형제들 기술 블로그
  - 카카오 기술 블로그
  - Baeldung (Spring 관련 튜토리얼)

  ---
  🚀 7. 개발 일정 (예상)

  | Phase | 내용                    | 예상 소요 시간 |
  |-------|-----------------------|----------|
  | 0     | Docker 인프라 구축         | 1-2일     |
  | 1     | 프로젝트 기반 설정            | 1일       |
  | 2     | 예외 처리 시스템             | 1일       |
  | 3     | Spring Security + JWT | 2-3일     |
  | 4     | User 도메인              | 2일       |
  | 5     | Friend 도메인            | 1-2일     |
  | 6     | Location 도메인          | 2일       |
  | 7     | Shuttle 도메인           | 1일       |
  | 8     | Arrival 도메인 (카카오 API) | 2-3일     |
  | 9     | CI/CD 구축              | 1-2일     |
  | 총계    |                       | 약 2-3주   |

  ---
  💡 8. 개발 팁

  8.1 코딩 컨벤션

  - 클래스명: PascalCase (UserService)
  - 메서드명: camelCase (findUserById)
  - 상수: UPPER_SNAKE_CASE (MAX_LOGIN_ATTEMPTS)
  - 패키지: 소문자 (com.ssafy.shuttle_tracker)

  8.2 Git Commit 메시지

  feat: 새로운 기능 추가
  fix: 버그 수정
  refactor: 코드 리팩토링
  docs: 문서 수정
  test: 테스트 코드 추가
  chore: 빌드 설정 등

  예시: feat: User 도메인 회원가입 API 구현

  8.3 디버깅 팁

  - Postman으로 API 테스트
  - H2 Console로 개발 초기 DB 확인
  - Spring Boot Actuator (선택)

  ---
  ⎿  User rejected Claude's plan:
     ╭───────────────────────────────────────────────────────────────────────────────────╮
     │ SSAFY 셔틀 트래커 백엔드 개발 계획                                                │
     │                                                                                   │
     │ 📋 아키텍처 설계                                                                  │
     │                                                                                   │
     │ - 도메인 중심 계층 구조: User, Friend, Location, Shuttle, Arrival 도메인으로 분리 │
     │ - 이전 프로젝트와 유사한 구조: controller/dto/entity/repository/service 패턴 채택 │
     │ - MVP 원칙: 필수 기능만 구현 (WebSocket, Admin, OAuth2 제외)                      │
     │                                                                                   │
     │ 🛠️ 기술 스택                                                                     │
     │                                                                                   │
     │ - Spring Boot 3.5.7 + JPA + Spring Security                                       │
     │ - MySQL (Docker) + Redis (Docker)                                                 │
     │ - JWT 인증 (Access Token 1시간, Refresh Token 7일)                                │
     │ - 카카오 모빌리티 API (도착 시간 예측)                                            │
     │ - GitHub Actions (CI/CD)                                                          │
     │                                                                                   │
     │ 📝 개발 순서 (총 2-3주 예상)                                                      │
     │                                                                                   │
     │ Phase 0-2: 기반 구축 (3-4일)                                                      │
     │                                                                                   │
     │ 1. Docker Compose로 MySQL + Redis 구축                                            │
     │ 2. 패키지 구조 생성 (domain별 계층 분리)                                          │
     │ 3. GlobalExceptionHandler, ErrorCode, ApiResponse 등 공통 설정                    │
     │                                                                                   │
     │ Phase 3: 인증 시스템 (2-3일)                                                      │
     │                                                                                   │
     │ - Spring Security + JWT + Redis 구현                                              │
     │ - JwtTokenProvider, JwtAuthenticationFilter, SecurityConfig                       │
     │                                                                                   │
     │ Phase 4-7: 핵심 도메인 구현 (6-7일)                                               │
     │                                                                                   │
     │ - User: 회원가입, 로그인, 정보 수정                                               │
     │ - Friend: 친구 추가/수락/거절/삭제                                                │
     │ - Location: 위치 공유 시작/중지, 1시간 자동 만료                                  │
     │ - Shuttle: 노선 및 경유지 조회                                                    │
     │                                                                                   │
     │ Phase 8: 카카오 API 연동 (2-3일)                                                  │
     │                                                                                   │
     │ - WebClient로 카카오 모빌리티 API 호출                                            │
     │ - 도착 시간 예측 로직 구현                                                        │
     │                                                                                   │
     │ Phase 9: CI/CD (1-2일)                                                            │
     │                                                                                   │
     │ - GitHub Actions Workflow 설정                                                    │
     │ - Docker 이미지 빌드 및 자동 배포                                                 │
     │                                                                                   │
     │ 📚 학습 필요 항목                                                                 │
     │                                                                                   │
     │ - Docker & Docker Compose 기본                                                    │
     │ - Spring Security + JWT 인증 구조                                                 │
     │ - Spring Data JPA 연관관계 매핑                                                   │
     │ - Redis 기본 사용법 (TTL, 캐싱)                                                   │
     │ - WebClient를 통한 외부 API 호출                                                  │
     │                                                                                   │
     │ ✅ MVP에 포함                                                                      │
     │                                                                                   │
     │ - JWT + Redis 인증, 예외 처리, Validation, CORS, Docker, 기본 CI/CD               │
     │                                                                                   │
     │ ❌ MVP에서 제외                                                                    │
     │                                                                                   │
     │ - WebSocket, Admin 기능, 소셜 로그인, 이메일 인증, ELK Stack, 복잡한 테스트       │
     │                                                                                   │
     │ ---                                                                               │
     │ 이 계획으로 진행해도 될까요? 구체적인 질문이나 수정 사항이 있으면 말씀해주세요!   │
     ╰───────────────────────────────────────────────────────────────────────────────────╯

> 아 깜빡했다. 지금 세우고 있는 계획 Sequential Thinking MCP 사용해서 한 번 더 점검해줘.

● Sequential Thinking으로 계획을 점검하겠습니다.

● sequential-thinking - sequentialthinking (MCP)(thought: "SSAFY 셔틀 트래커 백엔드 프로젝트의 요구사항을
                                                정리해보자.\n\n핵심 기능:\n1. 사용자 인증 (회원가입, 로그인, JWT)\n2.
                                                친구 관리 (추가, 수락, 거절, 삭제)\n3. 위치 공유 (1시간 자동 만료,
                                                ON/OFF)\n4. 셔틀 노선 및 경유지 조회\n5. 도착 시간 예측 (카카오 API
                                                연동)\n\n기술 스택:\n- Spring Boot 3.5.7, JPA, Spring Security\n- MySQL
                                                + Redis (Docker)\n- JWT 인증\n- 카카오 모 il리티 API\n\n프로젝트
                                                특징:\n- MVP 프로젝트 (빠른 서비스 출시 필요)\n- 주니어 개발자 대상\n-
                                                이전 프로젝트 구조 참고 (domain별 계층 구조)\n\n계획 검증을 위해
                                                고려해야 할 관점:\n1. 개발 순서의 적절성\n2. 학습 곡선 고려\n3. MVP
                                                범위의 적절성\n4. 기술 스택의 타당성\n5. 놓친 요구사항은 없는지",
                                                thoughtNumber: 1, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 1,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Phase 0 (Docker 인프라 구축)부터 검토해보자.\n\n제안한 순서:
                                                Docker MySQL + Redis 구축 → application.yml 설정\n\n검토:\n✅ 장점: 개발
                                                 환경을 먼저 갖추는 것은 합리적\n⚠️ 우려: 주니어 개발자가 Docker를 처음
                                                접하면 1-2일로는 부족할 수 있음\n⚠️ 우려: Docker 없이도 로컬 MySQL로
                                                시작할 수 있는데, 필수로 Docker를 강제하는 것이 맞나?\n\n개선 방안:\n-
                                                Docker는 \"권장\"이지만 선택사항으로 두기\n- 또는 Docker Compose 파일을
                                                미리 완성해서 제공하고, `docker-compose up -d` 한 번만 실행하면
                                                되도록\n- 로컬 MySQL 설치 옵션도 함께 제시\n\n결론: Docker 구축 단계를
                                                더 명확하게 하거나, 대안 제시 필요", thoughtNumber: 2, totalThoughts:
                                                15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 2,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Phase 1-2 (프로젝트 기반 설정 + 예외 처리)를
                                                검토해보자.\n\n제안 순서:\n1. 패키지 구조 생성\n2. WebConfig, JpaConfig
                                                등 공통 설정\n3. ApiResponse, ErrorResponse\n4. BaseTimeEntity\n5.
                                                ErrorCode, BusinessException, GlobalExceptionHandler\n\n검토:\n✅ 장점:
                                                공통 인프라를 먼저 구축하는 것은 좋은 접근\n❌ 문제점: 주니어 개발자
                                                입장에서 \"추상적인 것\"부터 시작하면 동기부여가 떨어질 수 있음\n❌
                                                문제점: 예외 처리 시스템을 먼저 만들어도, 실제 도메인 로직이 없으면
                                                테스트할 수 없음\n\n대안:\n- 먼저 가장 단순한 도메인(User
                                                회원가입/로그인)을 만들어보고\n- 그 과정에서 필요한 예외 처리를
                                                점진적으로 추가하는 방식\n- \"동작하는 코드\"를 빨리 만들어보는 것이
                                                학습에 더 효과적\n\n이것은 \"Top-down vs Bottom-up\" 접근의 차이인데,
                                                주니어에게는 Bottom-up이 더 나을 수 있음", thoughtNumber: 3,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 3,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Phase 3 (Spring Security + JWT) 시점을 검토해보자.\n\n제안
                                                순서: User 도메인보다 먼저 Security + JWT를 구현\n\n검토:\n❌ 큰 문제:
                                                Spring Security와 JWT는 매우 복잡한 주제\n❌ 주니어가 User Entity도 없는
                                                 상태에서 CustomUserDetailsService를 만들 수 없음\n❌ 로그인 로직도
                                                없는데 JWT를 먼저 구현하면 테스트 불가능\n❌ 학습 곡선: Security는
                                                Spring에서 가장 어려운 부분 중 하나\n\n올바른 순서:\n1. 먼저 User
                                                도메인을 Security 없이 구현 (회원가입, 조회)\n2. 간단한 로그인 API를
                                                만들어보기 (Security 없이)\n3. 그 다음에 Spring Security를 적용하면서
                                                점진적으로 개선\n4. 마지막으로 JWT 추가\n\n이유:\n- \"동작하는 코드\"를
                                                먼저 만들고 점진적으로 보안을 강화하는 것이 학습에 효과적\n- Spring
                                                Security의 필요성을 체감한 후에 적용해야 이해도가 높아짐",
                                                thoughtNumber: 4, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 4,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "도메인 간 의존성을 검토해보자.\n\n제안된 도메인 구현 순서:
                                                User → Friend → Location → Shuttle → Arrival\n\n의존성 분석:\n- Friend는
                                                 User에 의존 (Friendship이 User를 참조)\n- Location은 User에 의존
                                                (LocationShare가 User를 참조)\n- Shuttle은 독립적 (ShuttleRoute,
                                                ShuttleStop)\n- Arrival은 Location + Shuttle + Friend에 모두
                                                의존\n\n검토:\n✅ User를 먼저 하는 것은 맞음\n⚠️ Friend와 Location은
                                                병렬로 개발 가능한데 순차적으로 제안됨\n⚠️ Shuttle은 다른 도메인과
                                                독립적이므로 더 일찍 할 수 있음\n\n개선된 순서:\n1. User (기본 CRUD)\n2.
                                                 Shuttle (독립적이므로 병렬 가능)\n3. Friend + Location (병렬 가능)\n4.
                                                Arrival (모든 도메인이 준비된 후)\n\n또는 학습 관점에서:\n1. Shuttle
                                                (가장 단순, JPA 연습용)\n2. User (인증 제외한 기본 기능)\n3. Friend
                                                (연관관계 학습)\n4. Location (스케줄러, Redis 학습)\n5. 인증 시스템
                                                (Security + JWT)\n6. Arrival (외부 API 연동)\n\n후자가 학습 곡선
                                                측면에서 더 나을 수 있음", thoughtNumber: 5, totalThoughts: 15,
                                                nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 5,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Redis 사용 시점을 검토해보자.\n\n제안에서 Redis 사용처:\n1.
                                                JWT Refresh Token 저장\n2. 로그아웃 토큰 Blacklist\n3. Location 데이터
                                                캐싱\n\n검토:\n⚠️ 문제: Redis를 Phase 0에 설치하지만, 실제 사용은 Phase
                                                3 (JWT), Phase 6 (Location)\n⚠️ 문제: 주니어가 Redis를 언제 왜 쓰는지
                                                모르는 채로 설치만 해두면 혼란\n⚠️ 문제: MVP에서 Redis가 정말
                                                필수인가?\n\n대안 검토:\n1. JWT Refresh Token → 초기에는 DB에 저장해도
                                                됨 (성능은 떨어지지만 동작함)\n2. Blacklist → 초기 MVP에서는 생략 가능
                                                (토큰 만료 시간만으로도 충분)\n3. Location 캐싱 → DB만으로도 충분히 빠름
                                                 (사용자 수가 많지 않으면)\n\n결론:\n- Redis는 \"성능 최적화\" 단계에서
                                                추가하는 것이 학습 관점에서 더 나을 수 있음\n- 또는 Redis를 쓴다면, 왜
                                                필요한지 명확히 설명하고 실제 사용 시점에 도입", thoughtNumber: 6,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 6,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "build.gradle의 의존성을 다시 확인해보자.\n\n현재 설정된
                                                의존성:\n- spring-boot-starter-validation ✅\n-
                                                spring-boot-starter-data-jpa ✅\n- spring-boot-starter-security ✅\n-
                                                spring-boot-starter-web ✅\n- lombok ✅\n- mysql-connector-j ✅\n- h2
                                                (테스트용) ✅\n\n제안에서 추가하려는 것:\n- JWT 라이브러리 (jjwt)\n-
                                                Redis (spring-boot-starter-data-redis)\n- WebFlux (카카오 API
                                                호출용)\n\n검토:\n✅ JWT는 필수\n⚠️ Redis는 앞서 검토했듯이 선택적\n✅
                                                WebFlux (WebClient)는 카카오 API 호출에 필요\n\n추가 고려사항:\n-
                                                RestTemplate vs WebClient: WebClient가 최신이지만 주니어에게는
                                                RestTemplate이 더 직관적일 수 있음\n- 하지만 RestTemplate은 deprecated
                                                예정이므로 WebClient 학습이 장기적으로 유리\n\n결론: 의존성 추가 계획은
                                                적절함", thoughtNumber: 7, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 7,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Location 도메인의 1시간 자동 만료 로직을
                                                검토해보자.\n\n제안된 구현:\n- LocationShare Entity에 startTime, endTime
                                                 저장\n- @Scheduled로 만료된 항목을 주기적으로 isActive = false로
                                                변경\n- Redis에도 TTL 1시간으로 캐싱\n\n검토:\n✅ startTime, endTime을
                                                DB에 저장하는 것은 좋음\n⚠️ @Scheduled로 배치 처리하는 방식의 문제점:\n
                                                 - 스케줄러가 5분마다 돌면, 만료 후 최대 5분 지연 발생\n  - 만료 시점이
                                                정확하지 않음\n  \n대안:\n1. 조회 시점에 endTime과 현재 시간을 비교
                                                (Lazy Evaluation)\n   - 장점: 정확함, 추가 스케줄러 불필요\n   - 단점:
                                                매번 시간 비교 필요\n   \n2. Redis TTL만 사용하고 DB는 로그용\n   -
                                                장점: Redis가 자동으로 만료 처리\n   - 단점: Redis 장애 시 데이터
                                                손실\n\nMVP 추천: \n- 방안 1 (조회 시점 검증)이 가장 단순하고 안정적\n-
                                                추가로 @Scheduled (1시간마다)로 정리하는 정도면 충분", thoughtNumber: 8,
                                                 totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 8,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "카카오 모빌리티 API 연동 부분을 검토해보자.\n\n제안된
                                                구현:\n- WebClient로 카카오 경로 API 호출\n- origin (친구 위치) →
                                                waypoints (경유지들) → destination (내 위치)\n- 결과로 소요 시간 및 경로
                                                 좌표 반환\n\n검토:\n✅ WebClient 사용은 적절함\n⚠️ 복잡도: 카카오 API는
                                                 여러 종류가 있고 문서가 복잡함\n⚠️ 비용: 카카오 모빌리티 API는 유료일
                                                수 있음\n\n확인 필요사항:\n1. 카카오 모빌리티 API vs 카카오맵 API
                                                차이\n2. 무료 티어 존재 여부\n3. Waypoints를 지원하는 API가
                                                맞는지\n\n대안:\n- 초기 MVP에서는 단순 직선거리 계산으로 시작\n- 나중에
                                                실제 API 연동\n- 또는 구글 Directions API 고려 (월 $200 무료
                                                크레딧)\n\n추천:\n- 일단 카카오 API 명세를 먼저 확인하고 계획 수정\n-
                                                MVP에서는 mock 데이터나 단순 계산으로 시작하는 것도 고려",
                                                thoughtNumber: 9, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 9,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "CI/CD 계획을 검토해보자.\n\n제안: GitHub Actions로 자동 빌드
                                                및 배포\n\n제안된 워크플로우:\n1. main 브랜치 push 시 트리거\n2. Gradle
                                                빌드\n3. Docker 이미지 빌드\n4. 서버로 SSH 접속하여 배포\n\n검토:\n⚠️
                                                문제: MVP 단계에서 CI/CD가 우선순위가 높은가?\n⚠️ 문제: SSH 키, 서버
                                                호스트 등의 인프라가 준비되어 있는가?\n⚠️ 문제: 주니어가 GitHub
                                                Actions를 처음 다룬다면 시간이 많이 소요될 수 있음\n\n대안:\n1. 초기에는
                                                 수동 배포 (jar 파일 빌드 후 서버에 업로드)\n2. 핵심 기능 완성 후 CI/CD
                                                추가\n3. 또는 더 간단한 방식: GitHub Actions로 빌드만 자동화 (배포는
                                                수동)\n\n우선순위 재조정:\n- Phase 1-8: 핵심 기능 구현\n- Phase 9: CI/CD
                                                 (선택사항, 시간 여유 있을 때)\n\n결론: CI/CD는 \"좋으면 하는 것\"이지
                                                MVP 필수는 아님", thoughtNumber: 10, totalThoughts: 15,
                                                nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 10,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "CLAUDE.md에서 프론트엔드 요구사항을 다시 확인해보자.\n\n핵심
                                                API 엔드포인트 (프론트에서 필요한 것):\n1. POST /api/auth/login,
                                                /api/auth/signup\n2. POST /api/location/start, /api/location/stop, PUT
                                                /api/location/update\n3. GET /api/friends, POST /api/friends/request,
                                                PUT /api/friends/:id/accept/reject\n4. GET /api/shuttle/routes, GET
                                                /api/shuttle/routes/:id/stops\n5. POST /api/shuttle/arrival-time\n6.
                                                검색 API: GET /api/shuttle/routes/search, GET
                                                /api/friends/search\n\n추가 필요한 API (제안에서 누락):\n❌ 친구 이름
                                                검색 API가 명시되어 있지만, 실제로는 \"이메일로 검색\"이 필요\n❌ GET
                                                /api/location/friends - 모든 친구들의 위치를 한번에 조회하는 API 필요\n
                                                  (현재는 GET /api/location/friend/:friendId로 한명씩만 조회
                                                가능)\n\n검토:\n- 프론트엔드 요구사항: \"친구 관계인 모든 유저의 위치
                                                마커 표시\"\n- 이를 위해서는 친구 목록 조회 → 각 친구의 위치 조회 (N+1
                                                문제 발생)\n- 더 나은 방법: GET /api/location/friends 엔드포인트로
                                                한번에 조회\n\n결론: Location API 설계에 보완 필요", thoughtNumber: 11,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 11,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Entity 설계를 다시 검토해보자.\n\nFriendship Entity:\n-
                                                requester (요청 보낸 사람)\n- receiver (요청 받은 사람)\n- status
                                                (PENDING, ACCEPTED, REJECTED)\n\n검토:\n✅ 기본 설계는 괜찮음\n⚠️ 쿼리
                                                복잡도: \"내 친구 목록\"을 조회하려면?\n  - WHERE (requester_id = 나 OR
                                                receiver_id = 나) AND status = ACCEPTED\n  - 양방향 관계 때문에 쿼리가
                                                복잡해짐\n\n대안:\n1. 현재 설계 유지 + Repository에서 복잡한 쿼리
                                                작성\n2. ACCEPTED 상태가 되면 양방향 레코드 2개 생성 (더 단순한 쿼리)\n
                                                  - (A→B, ACCEPTED), (B→A, ACCEPTED)\n   - 단점: 데이터 중복\n\n추천:\n-
                                                 방안 1 유지 (정규화)\n- JPA 쿼리 메서드 예시 제공 필요:\n  ```java\n
                                                @Query(\"SELECT f FROM Friendship f WHERE (f.requester.id = :userId OR
                                                f.receiver.id = :userId) AND f.status = 'ACCEPTED'\")\n
                                                List<Friendship> findMyFriends(@Param(\"userId\") Long userId);\n
                                                ```\n\n결론: Entity 설계는 괜찮지만 Repository 쿼리 예시 추가 필요",
                                                thoughtNumber: 12, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 12,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Validation 전략을 검토해보자.\n\n제안에서 Validation:\n-
                                                @Email, @NotBlank, @Pattern 등 Bean Validation 사용\n- SignUpRequest에서
                                                 비밀번호 정규식 검증\n\n검토:\n✅ Bean Validation 사용은 좋은 접근\n⚠️
                                                주의: 비밀번호 확인(password, passwordConfirm) 검증은?\n⚠️ 주의: 이메일
                                                중복 체크는 어디서?\n\n필요한 Validation 레이어:\n1. DTO 레벨: @Valid로
                                                기본 형식 검증\n2. Service 레벨: 비즈니스 로직 검증 (중복 체크 등)\n3.
                                                Custom Validator: 복잡한 검증 (비밀번호 일치 등)\n\n예시:\n```java\n//
                                                DTO\n@Getter\npublic class SignUpRequest {\n    @Email\n    private
                                                String email;\n    \n    @Pattern(regexp =
                                                \"^(?=.*[A-Za-z])(?=.*\\\\d)[A-Za-z\\\\d]{8,}$\")\n    private String
                                                password;\n    \n    private String passwordConfirm;\n}\n\n//
                                                Service\npublic void signUp(SignUpRequest request) {\n    // 비밀번호
                                                일치 검증\n    if
                                                (!request.getPassword().equals(request.getPasswordConfirm())) {\n
                                                 throw new BusinessException(ErrorCode.PASSWORD_NOT_MATCH);\n    }\n
                                                \n    // 이메일 중복 검증\n    if
                                                (userRepository.existsByEmail(request.getEmail())) {\n        throw new
                                                BusinessException(ErrorCode.DUPLICATE_EMAIL);\n    }\n
                                                ...\n}\n```\n\n결론: Validation 전략은 괜찮지만 더 구체적인 예시 필요",
                                                thoughtNumber: 13, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 13,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "학습 자료와 시간 예상을 검토해보자.\n\n제안된 총 소요 시간:
                                                2-3주\n\nPhase별 소요 시간:\n- Phase 0 (Docker): 1-2일\n- Phase 1
                                                (기반): 1일\n- Phase 2 (예외처리): 1일\n- Phase 3 (Security+JWT):
                                                2-3일\n- Phase 4-7 (도메인): 6-7일\n- Phase 8 (카카오 API): 2-3일\n-
                                                Phase 9 (CI/CD): 1-2일\n합계: 14-21일\n\n검토:\n⚠️ 문제: 주니어 개발자가
                                                 처음 Spring을 배우면서 진행한다면 2-3주는 매우 빡빡함\n⚠️ 문제: 학습
                                                시간이 고려되지 않음 (순수 개발 시간만 계산)\n⚠️ 문제: 디버깅, 오류 수정
                                                 시간 미포함\n\n현실적인 예상:\n- 학습하면서 개발: 3-4주\n- 오류 해결
                                                버퍼: +1주\n- 총 4-5주가 더 현실적\n\n또한:\n- 매일 풀타임으로 개발할 수
                                                 있는가?\n- SSAFY 교육 중이라면 병행해야 하므로 더 길어질 수
                                                있음\n\n결론: 시간 예상을 더 보수적으로 조정 필요", thoughtNumber: 14,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 14,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "전체 계획을 종합하여 개선안을 정리해보자.\n\n발견한 주요
                                                문제점:\n1. 개발 순서: 추상적인 것(예외처리, Security)을 먼저 하면 학습
                                                곡선이 가파름\n2. Redis: MVP에서 필수가 아닌데 초기부터 도입\n3.
                                                Security+JWT: User 도메인보다 먼저 구현할 수 없음\n4. API 누락: 친구들의
                                                 위치를 한번에 조회하는 API\n5. 시간 예상: 너무 낙관적 (학습 시간
                                                미포함)\n6. CI/CD: MVP 우선순위가 아님\n7. 카카오 API: 비용/복잡도 고려
                                                필요\n\n개선된 개발 순서 제안:\n1. **환경 설정** (1-2일): Docker MySQL
                                                (Redis는 나중에)\n2. **Shuttle 도메인** (1-2일): 가장 단순, JPA
                                                학습용\n3. **User 도메인 (인증 제외)** (2일): 기본 CRUD\n4. **공통
                                                인프라** (1일): 예외처리, Validation (필요성을 체감한 후)\n5. **Friend
                                                도메인** (2일): 연관관계 학습\n6. **Location 도메인** (2일): 위치 공유
                                                기본\n7. **Spring Security + JWT** (3-4일): 이제 적용\n8. **Arrival
                                                도메인** (2-3일): 카카오 API (또는 mock)\n9. **Redis 최적화** (1일):
                                                선택사항\n10. **CI/CD** (1-2일): 선택사항\n\n이 순서의 장점:\n- 단순한
                                                것부터 복잡한 것으로\n- 각 단계에서 동작하는 코드를 만들며 학습\n- 필수
                                                기능 우선, 최적화는 나중에", thoughtNumber: 15, totalThoughts: 15,
                                                nextThoughtNeeded: false)
  ⎿  {
       "thoughtNumber": 15,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● Sequential Thinking으로 계획을 점검한 결과, 몇 가지 중요한 문제점을 발견했습니다. 개선된 계획을 제시하겠습니다.

  ---
  🔍 Sequential Thinking 점검 결과

  ❌ 발견된 주요 문제점

  1. 개발 순서의 문제

  - 문제: 예외 처리, Security+JWT를 User 도메인보다 먼저 구현
  - 이유: 실제 도메인 로직 없이 추상적인 인프라만 만들면 테스트 불가능하고 학습 효과 낮음
  - 개선: 단순한 도메인부터 시작 → 필요성 체감 후 인프라 추가

  2. Redis의 시기상조

  - 문제: Phase 0에 Redis 설치하지만 실제 사용은 Phase 3, 6
  - 이유: MVP에서 Redis는 "성능 최적화"이지 필수가 아님
  - 개선: 일단 DB만으로 구현 → 나중에 Redis 추가 (또는 생략)

  3. 누락된 API

  - 문제: 프론트에서 "모든 친구의 위치"를 한번에 조회해야 하는데 API 없음
  - 개선: GET /api/location/friends 엔드포인트 추가 필요

  4. 비현실적인 일정

  - 문제: 2-3주 예상 (학습 시간 미포함, 디버깅 시간 미포함)
  - 개선: 현실적으로 4-5주 (주니어 + 학습 포함)

  5. CI/CD 우선순위

  - 문제: MVP 단계에서 CI/CD를 필수로 제안
  - 개선: 핵심 기능 완성 후 선택적으로 추가

  ---
  📋 개선된 개발 계획

  🎯 핵심 원칙 변경

  기존 계획 (Top-Down)

  인프라 구축 → 예외처리 → Security → 도메인

  개선된 계획 (Bottom-Up)

  단순 도메인 → 필요한 인프라 → 복잡한 기능 → 최적화

  이유: 주니어 개발자는 "동작하는 코드"를 빠르게 만들어보며 학습하는 것이 효과적

  ---
  🚀 새로운 개발 순서

  Phase 0: 환경 설정 (1-2일)

  목표: 최소한의 개발 환경 구축

  작업:
  1. Docker Compose로 MySQL만 구축 (Redis는 나중에)
  services:
    mysql:
      image: mysql:8.0
      ports: ["3306:3306"]
      environment:
        MYSQL_DATABASE: shuttle_tracker
  2. application.yml 기본 설정
  3. 프로젝트 실행 확인

  학습: Docker 기본, MySQL 연결

  ---
  Phase 1: Shuttle 도메인 (1-2일)

  목표: 가장 단순한 도메인으로 JPA 학습

  왜 먼저?
  - 다른 도메인과 독립적
  - 인증 불필요
  - CRUD 기본 학습에 최적

  작업:
  1. Entity 작성: ShuttleRoute, ShuttleStop
  2. Repository: @OneToMany 관계 학습
  3. Service: 기본 조회 로직
  4. Controller: REST API 작성
    - GET /api/shuttle/routes
    - GET /api/shuttle/routes/{id}/stops
    - GET /api/shuttle/routes/search?q={query}
  5. SQL로 초기 데이터 삽입

  학습:
  - JPA Entity, Repository 기본
  - @OneToMany 연관관계
  - Spring Web Controller
  - SQL 초기 데이터 로드

  결과: Postman으로 실제 동작하는 API 확인 가능!

  ---
  Phase 2: User 도메인 - 기본편 (2일)

  목표: 인증 없이 User CRUD 구현

  작업:
  1. Entity: User (email, password, name)
  2. Repository: 기본 메서드
  3. Service:
    - 회원가입 (비밀번호 BCrypt 암호화)
    - 이메일로 사용자 검색
    - 내 정보 조회
  4. Controller:
    - POST /api/users (회원가입)
    - GET /api/users/search?email={email} (검색)
    - GET /api/users/{id} (조회)

  학습:
  - BCryptPasswordEncoder
  - Bean Validation (@Email, @NotBlank)
  - DTO 패턴 (Request/Response 분리)

  보안은?: 일단 인증 없이 만들어봄 (학습용)

  ---
  Phase 3: 공통 인프라 구축 (1일)

  목표: 지금까지 개발하며 느낀 필요성을 해결

  작업:
  1. GlobalExceptionHandler
    - 지금까지 발생한 예외들을 한곳에서 처리
  2. ErrorCode Enum
  USER_NOT_FOUND(404, "U001", "사용자를 찾을 수 없습니다.")
  DUPLICATE_EMAIL(409, "U002", "이미 존재하는 이메일입니다.")
  3. ApiResponse 통일
  {
    "success": true,
    "data": {...},
    "error": null
  }
  4. BaseTimeEntity (createdAt, updatedAt)

  학습:
  - @ControllerAdvice
  - Custom Exception 설계

  왜 이제?: 실제 예외가 발생해봐야 필요성을 체감함

  ---
  Phase 4: Friend 도메인 (2일)

  목표: 연관관계 심화 학습

  작업:
  1. Entity: Friendship
    - @ManyToOne User requester
    - @ManyToOne User receiver
    - FriendshipStatus status
  2. Repository:
  @Query("SELECT f FROM Friendship f WHERE (f.requester.id = :userId OR f.receiver.id = :userId) AND f.status =
  'ACCEPTED'")
  List<Friendship> findMyFriends(@Param("userId") Long userId);
  3. Service: 친구 추가/수락/거절/삭제
  4. Controller:
    - GET /api/friends (내 친구 목록)
    - POST /api/friends/request
    - PUT /api/friends/{id}/accept
    - DELETE /api/friends/{id}

  학습:
  - 양방향 관계 처리
  - JPQL 작성
  - 복잡한 비즈니스 로직

  ---
  Phase 5: Location 도메인 (2일)

  목표: 위치 공유 로직 구현

  작업:
  1. Entity: LocationShare
  private LocalDateTime startTime;
  private LocalDateTime endTime; // startTime + 1시간
  private Boolean isActive;
  2. Service:
    - 위치 공유 시작/중지
    - 위치 업데이트
    - 중요: GET /api/location/friends (모든 친구 위치 한번에 조회)
    - 조회 시 endTime과 현재 시간 비교 (만료 검증)
  3. @Scheduled (1시간마다 만료된 데이터 정리)

  학습:
  - LocalDateTime 사용
  - @Scheduled 태스크
  - 효율적인 쿼리 (N+1 방지)

  ---
  Phase 6: Spring Security + JWT (3-4일)

  목표: 기존 API에 인증 추가

  왜 이제?:
  - User, Friend, Location이 모두 동작하는 상태
  - 이제 "보호"가 필요함을 체감

  작업:
  1. JWT 의존성 추가
  implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
  2. JwtTokenProvider 구현
  3. JwtAuthenticationFilter 구현
  4. SecurityConfig 작성
  .requestMatchers("/api/auth/**", "/api/shuttle/**").permitAll()
  .anyRequest().authenticated()
  5. 로그인 API 추가
    - POST /api/auth/login → JWT 발급
  6. 기존 API에 인증 적용

  학습:
  - Spring Security Architecture
  - JWT 토큰 생성/검증
  - Filter Chain

  Refresh Token은?:
  - 초기에는 Access Token만 (1일 TTL)
  - 나중에 필요하면 추가

  ---
  Phase 7: Arrival 도메인 (2-3일)

  목표: 도착 시간 예측

  작업:
  1. 카카오 API 조사
    - 비용 확인
    - API 명세 확인
    - 무료 대안 탐색
  2. WebClient 설정
  3. ArrivalTimeService 구현
  4. 대안: 초기에는 단순 거리 계산으로 mock
  // 하버사인 공식으로 직선거리 계산
  double distance = calculateDistance(friendLoc, myLoc);
  int estimatedMinutes = (int)(distance / 평균속도);

  학습:
  - WebClient 사용
  - 외부 API 연동
  - 에러 핸들링

  ---
  Phase 8: Redis 최적화 (선택, 1일)

  목표: 성능 개선

  Redis 도입 시점:
  - Refresh Token 저장
  - Location 데이터 캐싱 (TTL 1시간)

  작업:
  1. Docker Compose에 Redis 추가
  2. RedisUtil 구현
  3. LocationService에 캐싱 로직 추가

  왜 선택?: MVP에서 사용자가 많지 않으면 불필요

  ---
  Phase 9: CI/CD (선택, 1-2일)

  목표: 자동 배포

  작업:
  1. GitHub Actions 워크플로우
  2. Docker 이미지 빌드
  3. 서버 배포 자동화

  왜 선택?: 핵심 기능 완성이 우선

  ---
  📊 개선된 일정 예상

  | Phase | 내용             | 예상 소요 (주니어+학습) |
  |-------|----------------|----------------|
  | 0     | 환경 설정          | 1-2일           |
  | 1     | Shuttle 도메인    | 1-2일           |
  | 2     | User 도메인 기본    | 2일             |
  | 3     | 공통 인프라         | 1일             |
  | 4     | Friend 도메인     | 2일             |
  | 5     | Location 도메인   | 2일             |
  | 6     | Security + JWT | 3-4일           |
  | 7     | Arrival 도메인    | 2-3일           |
  | 8     | Redis (선택)     | 1일             |
  | 9     | CI/CD (선택)     | 1-2일           |
  | 버퍼    | 디버깅, 오류 수정     | 3-5일           |
  | 총계    |                | 4-5주 (현실적)     |

  ---
  ✅ MVP 필수 vs 선택

  필수 (3주 목표)

  - ✅ Phase 0-7 (Redis, CI/CD 제외)
  - ✅ JWT 인증
  - ✅ 핵심 도메인 기능
  - ✅ 예외 처리

  선택 (시간 여유 시)

  - ⭐ Redis 최적화
  - ⭐ CI/CD
  - ⭐ 실제 카카오 API 연동 (초기에는 mock 가능)
  - ⭐ WebSocket 실시간 업데이트

  ---
  📚 단계별 학습 자료

  Phase 1-2: JPA 기초

  - 김영한 - 자바 ORM 표준 JPA 프로그래밍 (인프런)
  - Spring Data JPA 공식 문서

  Phase 3: 예외 처리

  - Baeldung - Exception Handling in Spring
  - 우아한형제들 기술 블로그 - 예외 처리 전략

  Phase 4-5: JPA 심화

  - N+1 문제 해결
  - JPQL vs QueryDSL

  Phase 6: Spring Security

  - 김영한 - 스프링 시큐리티 (인프런)
  - JWT.io 공식 문서
  - Baeldung - Spring Security + JWT

  Phase 7: WebClient

  - Spring WebFlux 공식 문서
  - 카카오 모빌리티 API 문서

  ---
  💡 추가 개선 사항

  1. API 명세 보완

  // 추가 필요
  GET /api/location/friends          // 모든 친구 위치 한번에 조회
  GET /api/users/search?email={email} // 이메일로 사용자 검색

  2. Validation 강화

  // SignUpRequest에 추가
  private String passwordConfirm;

  // Service에서 검증
  if (!password.equals(passwordConfirm)) {
      throw new BusinessException(ErrorCode.PASSWORD_NOT_MATCH);
  }

  3. 위치 만료 로직 개선

  // 조회 시점에 검증 (Lazy Evaluation)
  public Optional<LocationShare> getActiveLocation(Long userId) {
      return locationShareRepository.findByUserId(userId)
          .filter(loc -> loc.getEndTime().isAfter(LocalDateTime.now()))
          .filter(LocationShare::getIsActive);
  }

  ---

╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Ready to code?                                                                                                       │
│                                                                                                                      │
│ Here is Claude's plan:                                                                                               │
│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │
│ │ Sequential Thinking 점검 완료 - 개선된 백엔드 개발 계획                                                          │ │
│ │                                                                                                                  │ │
│ │ 🔍 주요 개선 사항                                                                                                │ │
│ │                                                                                                                  │ │
│ │ 1. 개발 순서 대폭 수정 (Bottom-Up 접근)                                                                          │ │
│ │                                                                                                                  │ │
│ │ 기존: 인프라 → Security → 도메인개선: 단순 도메인 → 필요 인프라 → 복잡 기능                                      │ │
│ │                                                                                                                  │ │
│ │ 새로운 순서:                                                                                                     │ │
│ │ 1. Shuttle 도메인 (가장 단순, JPA 학습)                                                                          │ │
│ │ 2. User 도메인 기본 (인증 제외)                                                                                  │ │
│ │ 3. 공통 인프라 (필요성 체감 후)                                                                                  │ │
│ │ 4. Friend 도메인 (연관관계)                                                                                      │ │
│ │ 5. Location 도메인 (스케줄러)                                                                                    │ │
│ │ 6. Spring Security + JWT (이제 적용)                                                                             │ │
│ │ 7. Arrival 도메인 (카카오 API)                                                                                   │ │
│ │                                                                                                                  │ │
│ │ 이유: 주니어는 "동작하는 코드"를 빠르게 만들며 학습하는 것이 효과적                                              │ │
│ │                                                                                                                  │ │
│ │ 2. Redis를 선택사항으로 변경                                                                                     │ │
│ │                                                                                                                  │ │
│ │ - MVP에서 Redis는 "최적화"이지 필수 아님                                                                         │ │
│ │ - 초기에는 DB만으로 충분                                                                                         │ │
│ │ - Phase 8에서 선택적으로 추가                                                                                    │ │
│ │                                                                                                                  │ │
│ │ 3. CI/CD 우선순위 하향                                                                                           │ │
│ │                                                                                                                  │ │
│ │ - 핵심 기능 완성이 우선                                                                                          │ │
│ │ - Phase 9에서 선택사항으로                                                                                       │ │
│ │                                                                                                                  │ │
│ │ 4. 누락된 API 추가                                                                                               │ │
│ │                                                                                                                  │ │
│ │ - GET /api/location/friends (모든 친구 위치 한번에)                                                              │ │
│ │ - GET /api/users/search?email={email} (이메일 검색)                                                              │ │
│ │                                                                                                                  │ │
│ │ 5. 현실적인 일정 조정                                                                                            │ │
│ │                                                                                                                  │ │
│ │ 기존: 2-3주개선: 4-5주 (학습 시간 + 디버깅 버퍼 포함)                                                            │ │
│ │                                                                                                                  │ │
│ │ 📋 최종 개발 순서 (3주 MVP 목표)                                                                                 │ │
│ │                                                                                                                  │ │
│ │ Week 1: 기초 다지기                                                                                              │ │
│ │                                                                                                                  │ │
│ │ - Phase 0-2: 환경 + Shuttle + User 기본                                                                          │ │
│ │                                                                                                                  │ │
│ │ Week 2: 핵심 도메인                                                                                              │ │
│ │                                                                                                                  │ │
│ │ - Phase 3-5: 인프라 + Friend + Location                                                                          │ │
│ │                                                                                                                  │ │
│ │ Week 3: 인증 & 통합                                                                                              │ │
│ │                                                                                                                  │ │
│ │ - Phase 6-7: Security + JWT + Arrival                                                                            │ │
│ │                                                                                                                  │ │
│ │ Week 4-5: 여유분 (선택)                                                                                          │ │
│ │                                                                                                                  │ │
│ │ - Redis, CI/CD, 디버깅, 개선                                                                                     │ │
│ │                                                                                                                  │ │
│ │ 📚 학습 로드맵 명확화                                                                                            │ │
│ │                                                                                                                  │ │
│ │ 각 Phase마다 구체적인 학습 자료와 실습 목표 제시                                                                 │ │
│ │                                                                                                                  │ │
│ │ 이 개선된 계획으로 진행하시겠습니까?                                                                             │ │
│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │
│                                                                                                                      │
│ Would you like to proceed?                                                                                           │
│                                                                                                                      │
│   1. Yes, and auto-accept edits                                                                                      │
│   2. Yes, and manually approve edits                                                                                 │
│ > 3. No, keep planning                                                                                               │
│                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
ctrl-g to edit plan in start

╭─── Claude Code v2.0.26 ──────────────────────────────────────────────────────────────────────────────────────────────╮
│                                                    │ Tips for getting started                                        │
│               Welcome back jedo5000!               │ Run /install-github-app to tag @claude right from your Github … │
│                                                    │ √ Run /init to create a CLAUDE.md file with instructions for C… │
│                       ▐▛███▜▌                      │ ─────────────────────────────────────────────────────────────── │
│                      ▝▜█████▛▘                     │ Recent activity                                                 │
│                        ▘▘ ▝▝                       │ No recent activity                                              │
│                                                    │                                                                 │
│              Sonnet 4.5 · Claude Pro               │                                                                 │
│ C:\Users\SSAFY\projects\shuttle-tracker\shuttle-t… │                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

> # 백엔드

너는 java, Spring을 사용하는 우수기업의 10년차 시니어 백엔드 개발자야. 나는 아직 스프링에 대한 개념, 실력이 부족한
학생이고 프로젝트를 만들려해.

shuttle-tracker-be 프로젝트의 [CLAUDE.md](http://CLAUDE.md), DEVELOPMENT.md, FRONT_README.md, tree.txt를 읽고
프로젝트 파악을 해야함.

1. 프로젝트 세팅 → Springboot로 받고 gradle 설정했음. 코딩 컨벤션 숙지
2. Docker로 MySQL과 Redis Container 만들어서 사용하기, Docker 사용하는 법 공부해야함.
3. git action으로 CI/CD 구축하기
4. 구조 세팅 → domain 별 디렉토리 구조 채택 / 그리고 주니어 개발자로서 내가 백엔드를 어떤 순서대로 무엇을 설계하고
구현해야할지 잘 모르겠어. 알려줬으면 좋겠어.
    1. Entity 설계
    2. Spring security, redis + jwt 사용
    3. tree.txt의 과거 프로젝트 구조와 비슷한 구조로 프로젝트 진행 예정
    4. exceptionhandler, exception, validation 등등 필요한 것들을 넣고 학습할 예정(but MVP 프로젝트이고 바로
서비스해야하므로 과한건 빼고싶음. 추천 부탁함.)
    5. JPA 활용

너가 직접 코드를 짜는게 아닌 아키텍쳐를 어떻게 설계해야하는지, (너무 전 프로젝트를 무조건 따를 필요는 없어. ) 어떻게
 내가 이것들을 구현해 나가야하는지, 무엇을 공부하고 참고해야하는지를 계획 세운걸 받고싶어.

● 프로젝트 파악을 위해 관련 문서들을 먼저 읽어보겠습니다.

● Read(CLAUDE.md)
  ⎿  Read 141 lines

● Read(DEVELOPMENT.md)
  ⎿  Read 385 lines

● Read(FRONT_README.md)
  ⎿  Read 153 lines

● Read(tree.txt)
  ⎿  Read 138 lines

● 현재 프로젝트의 상태를 추가로 확인하겠습니다.

● Search(pattern: "**/*.gradle")
  ⎿  Found 2 files (ctrl+o to expand)

● Search(pattern: "**/application*.yml")
  ⎿  Found 2 files (ctrl+o to expand)

● Search(pattern: "**/application*.properties")
  ⎿  Found 0 files

● Read(build.gradle)
  ⎿  Read 45 lines

● Read(src\main\resources\application.yml)
  ⎿  Read 16 lines

● Search(pattern: "src/main/java/**/*.java")
  ⎿  Found 1 file (ctrl+o to expand)

● 좋습니다! 프로젝트 파악을 완료했습니다. 이제 SSAFY 셔틀 버스 위치 추적 서비스의 백엔드 아키텍처와 개발 계획을
  제시하겠습니다.

  ---
  🎯 SSAFY 셔틀 트래커 백엔드 아키텍처 & 개발 로드맵

  📊 프로젝트 현황 분석

  ✅ 완료된 것

  - Spring Boot 3.5.7 + Gradle 프로젝트 세팅
  - 기본 의존성: JPA, Security, Validation, MySQL, Lombok
  - application.yml 기본 구조 (주석 처리)

  🔧 진행 필요

  1. Docker를 통한 MySQL + Redis 인프라 구축
  2. 도메인별 계층 구조 설계 및 구현
  3. Spring Security + JWT + Redis 인증 시스템
  4. 핵심 비즈니스 로직 구현
  5. CI/CD (GitHub Actions)

  ---
  🏗️ 1. 아키텍처 설계

  1.1 계층 구조 (Layered Architecture)

  이전 프로젝트와 동일한 도메인 기반 구조를 채택하되, MVP에 맞게 단순화합니다.

  src/main/java/com/ssafy/shuttle_tracker/
  ├── domain/
  │   ├── user/                     # 사용자 도메인
  │   │   ├── controller/
  │   │   │   └── UserController.java
  │   │   ├── dto/
  │   │   │   ├── request/
  │   │   │   │   ├── SignUpRequest.java
  │   │   │   │   ├── LoginRequest.java
  │   │   │   │   └── PasswordChangeRequest.java
  │   │   │   └── response/
  │   │   │       └── UserInfoResponse.java
  │   │   ├── entity/
  │   │   │   └── User.java
  │   │   ├── repository/
  │   │   │   └── UserRepository.java
  │   │   └── service/
  │   │       └── UserService.java
  │   │
  │   ├── friend/                   # 친구 관계 도메인
  │   │   ├── controller/
  │   │   ├── dto/
  │   │   ├── entity/
  │   │   │   └── Friendship.java
  │   │   ├── repository/
  │   │   └── service/
  │   │
  │   ├── location/                 # 위치 공유 도메인
  │   │   ├── controller/
  │   │   ├── dto/
  │   │   ├── entity/
  │   │   │   └── LocationShare.java
  │   │   ├── repository/
  │   │   └── service/
  │   │
  │   ├── shuttle/                  # 셔틀 버스 도메인
  │   │   ├── controller/
  │   │   ├── dto/
  │   │   ├── entity/
  │   │   │   ├── ShuttleRoute.java
  │   │   │   └── ShuttleStop.java
  │   │   ├── repository/
  │   │   └── service/
  │   │
  │   └── arrival/                  # 도착 시간 예측 도메인
  │       ├── controller/
  │       ├── dto/
  │       └── service/
  │           └── ArrivalTimeService.java  # 카카오 API 호출
  │
  └── global/
      ├── config/
      │   ├── SecurityConfig.java
      │   ├── RedisConfig.java
      │   ├── WebConfig.java         # CORS 설정
      │   └── JpaConfig.java
      ├── security/
      │   ├── jwt/
      │   │   ├── JwtTokenProvider.java
      │   │   ├── JwtAuthenticationFilter.java
      │   │   └── JwtProperties.java
      │   └── auth/
      │       ├── CustomUserDetails.java
      │       └── CustomUserDetailsService.java
      ├── error/
      │   ├── exception/
      │   │   ├── BusinessException.java
      │   │   ├── ErrorCode.java
      │   │   └── (각 도메인별 커스텀 Exception)
      │   └── GlobalExceptionHandler.java
      ├── common/
      │   ├── response/
      │   │   ├── ApiResponse.java
      │   │   └── ErrorResponse.java
      │   └── constants/
      │       └── Constants.java
      └── util/
          └── RedisUtil.java

  1.2 핵심 설계 원칙

  1. 도메인 중심 설계: 각 도메인은 독립적으로 동작 가능
  2. 단방향 의존성: Controller → Service → Repository
  3. DTO 분리: Entity 직접 노출 금지, Request/Response DTO 사용
  4. 예외 처리 통일: GlobalExceptionHandler로 중앙 관리
  5. API 응답 통일: ApiResponse 래퍼 클래스 사용

  ---
  🗄️ 2. 데이터베이스 설계

  2.1 핵심 엔티티

  User (사용자)

  @Entity
  @Table(name = "users")
  public class User extends BaseTimeEntity {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(unique = true, nullable = false)
      private String email;

      @Column(nullable = false)
      private String password;  // BCrypt 암호화

      @Column(nullable = false)
      private String name;

      @Column(nullable = false)
      private Boolean locationShareAgree = false;

      @Enumerated(EnumType.STRING)
      private Role role;  // USER, ADMIN
  }

  Friendship (친구 관계)

  @Entity
  public class Friendship extends BaseTimeEntity {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "requester_id")
      private User requester;  // 요청 보낸 사람

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "receiver_id")
      private User receiver;  // 요청 받은 사람

      @Enumerated(EnumType.STRING)
      private FriendshipStatus status;  // PENDING, ACCEPTED, REJECTED
  }

  LocationShare (위치 공유)

  @Entity
  public class LocationShare {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "user_id")
      private User user;

      @Column(nullable = false)
      private Double latitude;

      @Column(nullable = false)
      private Double longitude;

      @Column(nullable = false)
      private LocalDateTime startTime;

      @Column(nullable = false)
      private LocalDateTime endTime;  // 1시간 후

      @Column(nullable = false)
      private Boolean isActive = true;
  }

  ShuttleRoute (셔틀 노선)

  @Entity
  public class ShuttleRoute extends BaseTimeEntity {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(nullable = false)
      private String name;  // "1호차", "2호차"

      @Column(length = 500)
      private String description;

      @OneToMany(mappedBy = "route", cascade = CascadeType.ALL)
      private List<ShuttleStop> stops = new ArrayList<>();
  }

  ShuttleStop (경유지)

  @Entity
  public class ShuttleStop {
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "route_id")
      private ShuttleRoute route;

      @Column(nullable = false)
      private String name;  // "광주역", "광주송정역"

      @Column(nullable = false)
      private Double latitude;

      @Column(nullable = false)
      private Double longitude;

      @Column(nullable = false)
      private Integer stopOrder;  // 순서 (1, 2, 3...)
  }

  2.2 BaseTimeEntity (공통 시간 필드)

  @MappedSuperclass
  @EntityListeners(AuditingEntityListener.class)
  public abstract class BaseTimeEntity {
      @CreatedDate
      @Column(updatable = false)
      private LocalDateTime createdAt;

      @LastModifiedDate
      private LocalDateTime updatedAt;
  }

  ---
  🔐 3. Spring Security + JWT + Redis 인증 시스템

  3.1 JWT 기반 인증 플로우

  1. 로그인 → JWT Access Token (1시간) + Refresh Token (7일) 발급
  2. Access Token을 Authorization Header에 포함하여 요청
  3. JwtAuthenticationFilter에서 토큰 검증
  4. 토큰 만료 시 Refresh Token으로 재발급
  5. Refresh Token은 Redis에 저장 (TTL: 7일)

  3.2 필요한 의존성 추가

  dependencies {
      // JWT
      implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
      runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.3'
      runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.3'

      // Redis
      implementation 'org.springframework.boot:spring-boot-starter-data-redis'

      // 카카오 API 호출
      implementation 'org.springframework.boot:spring-boot-starter-webflux'

      // (선택) WebSocket (추후 실시간 위치 업데이트용)
      // implementation 'org.springframework.boot:spring-boot-starter-websocket'
  }

  3.3 SecurityConfig 구조

  @Configuration
  @EnableWebSecurity
  @EnableMethodSecurity
  public class SecurityConfig {

      @Bean
      public SecurityFilterChain filterChain(HttpSecurity http) {
          return http
              .csrf(csrf -> csrf.disable())
              .cors(cors -> cors.configurationSource(corsConfigurationSource()))
              .sessionManagement(session ->
                  session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
              .authorizeHttpRequests(auth -> auth
                  .requestMatchers("/api/auth/**").permitAll()
                  .anyRequest().authenticated()
              )
              .addFilterBefore(jwtAuthenticationFilter,
                  UsernamePasswordAuthenticationFilter.class)
              .exceptionHandling(exception -> exception
                  .authenticationEntryPoint(jwtAuthenticationEntryPoint)
              )
              .build();
      }
  }

  ---
  📝 4. 개발 순서 및 단계별 학습 가이드

  Phase 0: 인프라 구축 (1-2일)

  목표: Docker로 MySQL과 Redis 환경 구축

  작업 내용

  1. Docker Compose 작성
  # docker-compose.yml
  version: '3.8'
  services:
    mysql:
      image: mysql:8.0
      container_name: shuttle-mysql
      environment:
        MYSQL_ROOT_PASSWORD: root1234
        MYSQL_DATABASE: shuttle_tracker
      ports:
        - "3306:3306"
      volumes:
        - mysql-data:/var/lib/mysql

    redis:
      image: redis:7-alpine
      container_name: shuttle-redis
      ports:
        - "6379:6379"
      volumes:
        - redis-data:/data

  volumes:
    mysql-data:
    redis-data:

  2. application.yml 설정
  spring:
    datasource:
      url: jdbc:mysql://localhost:3306/shuttle_tracker
      username: root
      password: root1234
    jpa:
      hibernate:
        ddl-auto: create  # 개발: create, 운영: validate
      show-sql: true
      properties:
        hibernate:
          format_sql: true
    redis:
      host: localhost
      port: 6379

  학습 자료

  - Docker 기본 개념: https://docs.docker.com/get-started/
  - Docker Compose: https://docs.docker.com/compose/

  ---
  Phase 1: 프로젝트 기반 설정 (1일)

  목표: 공통 설정 및 구조 준비

  작업 내용

  1. 패키지 구조 생성 (위 1.1 구조 참고)
  2. Global 설정 클래스
    - WebConfig (CORS)
    - JpaConfig (Auditing)
  3. 공통 응답 DTO
    - ApiResponse
    - ErrorResponse
  4. BaseTimeEntity 작성

  학습 자료

  - Spring Boot 패키지 구조 Best Practice
  - JPA Auditing: https://docs.spring.io/spring-data/jpa/reference/auditing.html

  ---
  Phase 2: 예외 처리 시스템 구축 (1일)

  목표: 통일된 예외 처리 체계 구축

  작업 내용

  1. ErrorCode Enum
  @Getter
  @RequiredArgsConstructor
  public enum ErrorCode {
      // 공통
      INVALID_INPUT_VALUE(400, "C001", "잘못된 입력값입니다."),
      UNAUTHORIZED(401, "C002", "인증이 필요합니다."),

      // User
      USER_NOT_FOUND(404, "U001", "사용자를 찾을 수 없습니다."),
      DUPLICATE_EMAIL(409, "U002", "이미 존재하는 이메일입니다."),
      INVALID_PASSWORD(400, "U003", "비밀번호가 일치하지 않습니다."),

      // Friend
      FRIENDSHIP_NOT_FOUND(404, "F001", "친구 관계를 찾을 수 없습니다."),
      ALREADY_FRIENDS(409, "F002", "이미 친구 관계입니다."),

      // Location
      LOCATION_SHARE_NOT_ACTIVE(400, "L001", "위치 공유가 활성화되지 않았습니다.");

      private final int status;
      private final String code;
      private final String message;
  }

  2. BusinessException
  3. GlobalExceptionHandler

  학습 자료

  - Spring @ControllerAdvice: https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc
  - Custom Exception 설계 패턴

  ---
  Phase 3: Spring Security + JWT 구현 (2-3일)

  목표: 인증/인가 시스템 완성

  작업 순서

  1. JwtTokenProvider 구현
    - Access Token 생성 (1시간)
    - Refresh Token 생성 (7일)
    - 토큰 검증
    - 토큰에서 사용자 정보 추출
  2. RedisUtil 구현
    - Refresh Token 저장
    - Blacklist (로그아웃된 토큰) 관리
  3. JwtAuthenticationFilter 구현
    - Authorization 헤더에서 토큰 추출
    - 토큰 검증
    - SecurityContext에 인증 정보 저장
  4. CustomUserDetailsService 구현
  5. SecurityConfig 작성

  학습 자료

  - JWT 개념: https://jwt.io/introduction
  - Spring Security Architecture: https://spring.io/guides/topicals/spring-security-architecture
  - Redis 기본: https://redis.io/docs/getting-started/

  ---
  Phase 4: User 도메인 구현 (2일)

  목표: 회원가입, 로그인, 사용자 정보 관리

  작업 순서

  1. Entity 작성: User.java
  2. Repository 작성: UserRepository.java
  3. Service 작성: UserService.java
    - 회원가입 (비밀번호 BCrypt 암호화)
    - 로그인 (JWT 발급)
    - 내 정보 조회
    - 비밀번호 변경
    - 위치 공유 동의 설정
  4. Controller 작성: UserController.java
    - POST /api/auth/signup
    - POST /api/auth/login
    - GET /api/auth/me
    - PUT /api/auth/password
    - PUT /api/auth/location-share-agree

  DTO 예시

  // Request
  @Getter
  @NoArgsConstructor
  public class SignUpRequest {
      @Email(message = "이메일 형식이 올바르지 않습니다.")
      @NotBlank
      private String email;

      @NotBlank
      @Pattern(regexp = "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,}$",
               message = "비밀번호는 8자 이상, 영문과 숫자를 포함해야 합니다.")
      private String password;

      @NotBlank
      private String name;
  }

  // Response
  @Getter
  @Builder
  public class LoginResponse {
      private String accessToken;
      private String refreshToken;
      private UserInfoResponse user;
  }

  학습 자료

  - Spring Data JPA: https://spring.io/projects/spring-data-jpa
  - Bean Validation: https://beanvalidation.org/
  - BCrypt 암호화: BCryptPasswordEncoder

  ---
  Phase 5: Friend 도메인 구현 (1-2일)

  목표: 친구 추가, 수락, 거절, 삭제

  작업 순서

  1. Entity: Friendship.java
  2. Repository: FriendshipRepository.java
    - 쿼리 메서드: findByRequesterAndReceiver, findAllByStatus 등
  3. Service: FriendshipService.java
  4. Controller: FriendshipController.java
    - GET /api/friends (ACCEPTED만)
    - POST /api/friends/request
    - PUT /api/friends/{id}/accept
    - PUT /api/friends/{id}/reject
    - DELETE /api/friends/{id}
    - GET /api/friends/pending

  학습 자료

  - JPA 연관관계 매핑: @ManyToOne, @OneToMany
  - JPQL 쿼리 작성

  ---
  Phase 6: Location 도메인 구현 (2일)

  목표: 위치 공유 시작/중지, 실시간 위치 업데이트

  작업 순서

  1. Entity: LocationShare.java
  2. Repository: LocationShareRepository.java
  3. Service: LocationService.java
    - 위치 공유 시작 (1시간 TTL 설정)
    - 위치 공유 중지
    - 내 위치 업데이트 (Redis에도 캐싱)
    - 친구 위치 조회
    - 스케줄러: 만료된 위치 공유 자동 비활성화
  4. Controller: LocationController.java

  중요 로직

  // 위치 공유 시작
  public void startSharing(Long userId, Double lat, Double lng) {
      LocalDateTime now = LocalDateTime.now();
      LocationShare locationShare = LocationShare.builder()
          .user(userRepository.findById(userId).orElseThrow())
          .latitude(lat)
          .longitude(lng)
          .startTime(now)
          .endTime(now.plusHours(1))  // 1시간 후 만료
          .isActive(true)
          .build();

      locationShareRepository.save(locationShare);

      // Redis에도 캐싱 (TTL: 1시간)
      redisUtil.setDataExpire("location:" + userId, locationShare, 3600);
  }

  학습 자료

  - Spring @Scheduled: https://spring.io/guides/gs/scheduling-tasks/
  - Redis TTL 설정

  ---
  Phase 7: Shuttle 도메인 구현 (1일)

  목표: 셔틀 노선 및 경유지 관리

  작업 순서

  1. Entity: ShuttleRoute.java, ShuttleStop.java
  2. Repository: ShuttleRouteRepository.java, ShuttleStopRepository.java
  3. Service: ShuttleService.java
    - 모든 노선 조회
    - 특정 노선의 경유지 조회 (stopOrder 순서대로)
    - 노선 검색
  4. Controller: ShuttleController.java

  초기 데이터 삽입

  -- sql/init-data.sql
  INSERT INTO shuttle_route (name, description) VALUES
  ('1호차', 'SSAFY 광주 1호차'),
  ('2호차', 'SSAFY 광주 2호차');

  INSERT INTO shuttle_stop (route_id, name, latitude, longitude, stop_order) VALUES
  (1, '광주역', 35.1160, 126.9172, 1),
  (1, '광주송정역', 35.1390, 126.7938, 2),
  (1, 'SSAFY 광주캠퍼스', 35.2019, 126.8095, 3);

  학습 자료

  - JPA @OneToMany 관계 설정
  - SQL 초기 데이터 로드: data.sql

  ---
  Phase 8: Arrival 도메인 구현 (2-3일)

  목표: 카카오 모빌리티 API 연동 및 도착 시간 예측

  작업 순서

  1. ArrivalTimeService 구현
    - 카카오 모빌리티 API 호출 (WebClient 사용)
    - 친구 위치 → 경유지 → 내 위치 경로 계산
    - 도착 시간 예측
  2. Controller: ArrivalController.java
    - POST /api/shuttle/arrival-time

  카카오 API 호출 예시

  @Service
  @RequiredArgsConstructor
  public class ArrivalTimeService {

      private final WebClient kakaoWebClient;

      @Value("${kakao.mobility.api-key}")
      private String kakaoApiKey;

      public ArrivalTimeResponse calculateArrivalTime(
          Long friendId,
          Location myLocation,
          List<Long> stopIds
      ) {
          // 1. 친구 위치 조회
          LocationShare friendLocation = locationShareRepository
              .findActiveByUserId(friendId)
              .orElseThrow(() -> new BusinessException(ErrorCode.LOCATION_SHARE_NOT_ACTIVE));

          // 2. 경유지 좌표 조회
          List<ShuttleStop> stops = shuttleStopRepository.findAllById(stopIds);

          // 3. 카카오 API로 경로 및 시간 계산
          String origin = friendLocation.getLatitude() + "," + friendLocation.getLongitude();
          String destination = myLocation.getLat() + "," + myLocation.getLng();
          String waypoints = stops.stream()
              .map(s -> s.getLatitude() + "," + s.getLongitude())
              .collect(Collectors.joining("|"));

          KakaoRouteResponse kakaoResponse = kakaoWebClient.get()
              .uri(uriBuilder -> uriBuilder
                  .path("/v1/waypoints/directions")
                  .queryParam("origin", origin)
                  .queryParam("destination", destination)
                  .queryParam("waypoints", waypoints)
                  .build())
              .header("Authorization", "KakaoAK " + kakaoApiKey)
              .retrieve()
              .bodyToMono(KakaoRouteResponse.class)
              .block();

          // 4. 응답 가공
          int durationMinutes = kakaoResponse.getDuration() / 60;
          LocalDateTime estimatedArrival = LocalDateTime.now().plusMinutes(durationMinutes);

          return ArrivalTimeResponse.builder()
              .routeName(stops.get(0).getRoute().getName())
              .estimatedMinutes(durationMinutes)
              .estimatedArrivalTime(estimatedArrival)
              .routePath(kakaoResponse.getCoordinates())
              .build();
      }
  }

  학습 자료

  - Spring WebClient: https://docs.spring.io/spring-framework/reference/web/webflux-webclient.html
  - 카카오 모빌리티 API: https://developers.kakaomobility.com/

  ---
  Phase 9: CI/CD 구축 (1-2일)

  목표: GitHub Actions로 자동 빌드 및 배포

  GitHub Actions Workflow

  # .github/workflows/deploy.yml
  name: Deploy to Server

  on:
    push:
      branches: [ main ]

  jobs:
    build-and-deploy:
      runs-on: ubuntu-latest

      steps:
      - uses: actions/checkout@v3

      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build with Gradle
        run: ./gradlew clean build -x test

      - name: Build Docker image
        run: docker build -t shuttle-tracker-be .

      - name: Push to Docker Hub (선택)
        # Docker Hub에 푸시하는 단계

      - name: Deploy to Server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            cd /app/shuttle-tracker
            docker-compose down
            docker-compose pull
            docker-compose up -d

  Dockerfile

  FROM openjdk:21-jdk-slim
  ARG JAR_FILE=build/libs/*.jar
  COPY ${JAR_FILE} app.jar
  EXPOSE 8080
  ENTRYPOINT ["java", "-jar", "/app.jar"]

  학습 자료

  - GitHub Actions: https://docs.github.com/en/actions
  - Docker 이미지 빌드: https://docs.docker.com/engine/reference/builder/

  ---
  🎯 5. MVP에서 제외할 것 (과한 것들)

  ❌ 제외 추천

  1. WebSocket 실시간 업데이트
    - 이유: 프론트가 새로고침 방식 채택
    - 나중에 추가 가능
  2. Admin 기능
    - 이유: 초기에는 직접 DB 관리
    - 노선/경유지는 SQL로 직접 삽입
  3. 소셜 로그인 (OAuth2)
    - 이유: 이메일/비밀번호 방식으로 충분
    - 나중에 추가 가능
  4. 이메일 인증
    - 이유: 내부 서비스 (SSAFY 교육생 대상)
  5. 복잡한 로깅 시스템 (ELK Stack)
    - 이유: 초기에는 Spring Boot 기본 로깅으로 충분
  6. 다중 프로필 환경 분리 (dev/prod/local)
    - 이유: 초기에는 application.yml 하나로 시작
    - 필요시 application-prod.yml 추가
  7. 복잡한 테스트 코드
    - 이유: MVP는 핵심 기능 위주 단위 테스트만
    - 통합 테스트는 시간 여유 있을 때

  ✅ 꼭 포함해야 할 것

  1. JWT + Redis 인증 (보안 기본)
  2. GlobalExceptionHandler (에러 처리 통일)
  3. Validation (입력값 검증)
  4. CORS 설정 (프론트 연동 필수)
  5. Docker Compose (개발 환경 통일)
  6. 기본 CI/CD (자동 배포)

  ---
  📚 6. 학습 자료 총정리

  필수 학습

  1. Spring Boot 기본
    - 공식 문서: https://spring.io/projects/spring-boot
    - 인프런 - 김영한의 스프링 부트 (추천)
  2. Spring Data JPA
    - 공식 문서: https://spring.io/projects/spring-data-jpa
    - 연관관계 매핑, JPQL
  3. Spring Security + JWT
    - Spring Security 공식 문서
    - JWT.io 이해하기
    - 블로그: "Spring Boot 3 + JWT 인증 구현"
  4. Docker
    - Docker 공식 튜토리얼
    - Docker Compose 사용법
  5. Redis
    - Redis 공식 문서 - Getting Started
    - Spring Data Redis 사용법

  참고 자료

  - 우아한형제들 기술 블로그
  - 카카오 기술 블로그
  - Baeldung (Spring 관련 튜토리얼)

  ---
  🚀 7. 개발 일정 (예상)

  | Phase | 내용                    | 예상 소요 시간 |
  |-------|-----------------------|----------|
  | 0     | Docker 인프라 구축         | 1-2일     |
  | 1     | 프로젝트 기반 설정            | 1일       |
  | 2     | 예외 처리 시스템             | 1일       |
  | 3     | Spring Security + JWT | 2-3일     |
  | 4     | User 도메인              | 2일       |
  | 5     | Friend 도메인            | 1-2일     |
  | 6     | Location 도메인          | 2일       |
  | 7     | Shuttle 도메인           | 1일       |
  | 8     | Arrival 도메인 (카카오 API) | 2-3일     |
  | 9     | CI/CD 구축              | 1-2일     |
  | 총계    |                       | 약 2-3주   |

  ---
  💡 8. 개발 팁

  8.1 코딩 컨벤션

  - 클래스명: PascalCase (UserService)
  - 메서드명: camelCase (findUserById)
  - 상수: UPPER_SNAKE_CASE (MAX_LOGIN_ATTEMPTS)
  - 패키지: 소문자 (com.ssafy.shuttle_tracker)

  8.2 Git Commit 메시지

  feat: 새로운 기능 추가
  fix: 버그 수정
  refactor: 코드 리팩토링
  docs: 문서 수정
  test: 테스트 코드 추가
  chore: 빌드 설정 등

  예시: feat: User 도메인 회원가입 API 구현

  8.3 디버깅 팁

  - Postman으로 API 테스트
  - H2 Console로 개발 초기 DB 확인
  - Spring Boot Actuator (선택)

  ---
  ⎿  User rejected Claude's plan:
     ╭───────────────────────────────────────────────────────────────────────────────────╮
     │ SSAFY 셔틀 트래커 백엔드 개발 계획                                                │
     │                                                                                   │
     │ 📋 아키텍처 설계                                                                  │
     │                                                                                   │
     │ - 도메인 중심 계층 구조: User, Friend, Location, Shuttle, Arrival 도메인으로 분리 │
     │ - 이전 프로젝트와 유사한 구조: controller/dto/entity/repository/service 패턴 채택 │
     │ - MVP 원칙: 필수 기능만 구현 (WebSocket, Admin, OAuth2 제외)                      │
     │                                                                                   │
     │ 🛠️ 기술 스택                                                                     │
     │                                                                                   │
     │ - Spring Boot 3.5.7 + JPA + Spring Security                                       │
     │ - MySQL (Docker) + Redis (Docker)                                                 │
     │ - JWT 인증 (Access Token 1시간, Refresh Token 7일)                                │
     │ - 카카오 모빌리티 API (도착 시간 예측)                                            │
     │ - GitHub Actions (CI/CD)                                                          │
     │                                                                                   │
     │ 📝 개발 순서 (총 2-3주 예상)                                                      │
     │                                                                                   │
     │ Phase 0-2: 기반 구축 (3-4일)                                                      │
     │                                                                                   │
     │ 1. Docker Compose로 MySQL + Redis 구축                                            │
     │ 2. 패키지 구조 생성 (domain별 계층 분리)                                          │
     │ 3. GlobalExceptionHandler, ErrorCode, ApiResponse 등 공통 설정                    │
     │                                                                                   │
     │ Phase 3: 인증 시스템 (2-3일)                                                      │
     │                                                                                   │
     │ - Spring Security + JWT + Redis 구현                                              │
     │ - JwtTokenProvider, JwtAuthenticationFilter, SecurityConfig                       │
     │                                                                                   │
     │ Phase 4-7: 핵심 도메인 구현 (6-7일)                                               │
     │                                                                                   │
     │ - User: 회원가입, 로그인, 정보 수정                                               │
     │ - Friend: 친구 추가/수락/거절/삭제                                                │
     │ - Location: 위치 공유 시작/중지, 1시간 자동 만료                                  │
     │ - Shuttle: 노선 및 경유지 조회                                                    │
     │                                                                                   │
     │ Phase 8: 카카오 API 연동 (2-3일)                                                  │
     │                                                                                   │
     │ - WebClient로 카카오 모빌리티 API 호출                                            │
     │ - 도착 시간 예측 로직 구현                                                        │
     │                                                                                   │
     │ Phase 9: CI/CD (1-2일)                                                            │
     │                                                                                   │
     │ - GitHub Actions Workflow 설정                                                    │
     │ - Docker 이미지 빌드 및 자동 배포                                                 │
     │                                                                                   │
     │ 📚 학습 필요 항목                                                                 │
     │                                                                                   │
     │ - Docker & Docker Compose 기본                                                    │
     │ - Spring Security + JWT 인증 구조                                                 │
     │ - Spring Data JPA 연관관계 매핑                                                   │
     │ - Redis 기본 사용법 (TTL, 캐싱)                                                   │
     │ - WebClient를 통한 외부 API 호출                                                  │
     │                                                                                   │
     │ ✅ MVP에 포함                                                                      │
     │                                                                                   │
     │ - JWT + Redis 인증, 예외 처리, Validation, CORS, Docker, 기본 CI/CD               │
     │                                                                                   │
     │ ❌ MVP에서 제외                                                                    │
     │                                                                                   │
     │ - WebSocket, Admin 기능, 소셜 로그인, 이메일 인증, ELK Stack, 복잡한 테스트       │
     │                                                                                   │
     │ ---                                                                               │
     │ 이 계획으로 진행해도 될까요? 구체적인 질문이나 수정 사항이 있으면 말씀해주세요!   │
     ╰───────────────────────────────────────────────────────────────────────────────────╯

> 아 깜빡했다. 지금 세우고 있는 계획 Sequential Thinking MCP 사용해서 한 번 더 점검해줘.

● Sequential Thinking으로 계획을 점검하겠습니다.

● sequential-thinking - sequentialthinking (MCP)(thought: "SSAFY 셔틀 트래커 백엔드 프로젝트의 요구사항을
                                                정리해보자.\n\n핵심 기능:\n1. 사용자 인증 (회원가입, 로그인, JWT)\n2.
                                                친구 관리 (추가, 수락, 거절, 삭제)\n3. 위치 공유 (1시간 자동 만료,
                                                ON/OFF)\n4. 셔틀 노선 및 경유지 조회\n5. 도착 시간 예측 (카카오 API
                                                연동)\n\n기술 스택:\n- Spring Boot 3.5.7, JPA, Spring Security\n- MySQL
                                                + Redis (Docker)\n- JWT 인증\n- 카카오 모 il리티 API\n\n프로젝트
                                                특징:\n- MVP 프로젝트 (빠른 서비스 출시 필요)\n- 주니어 개발자 대상\n-
                                                이전 프로젝트 구조 참고 (domain별 계층 구조)\n\n계획 검증을 위해
                                                고려해야 할 관점:\n1. 개발 순서의 적절성\n2. 학습 곡선 고려\n3. MVP
                                                범위의 적절성\n4. 기술 스택의 타당성\n5. 놓친 요구사항은 없는지",
                                                thoughtNumber: 1, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 1,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Phase 0 (Docker 인프라 구축)부터 검토해보자.\n\n제안한 순서:
                                                Docker MySQL + Redis 구축 → application.yml 설정\n\n검토:\n✅ 장점: 개발
                                                 환경을 먼저 갖추는 것은 합리적\n⚠️ 우려: 주니어 개발자가 Docker를 처음
                                                접하면 1-2일로는 부족할 수 있음\n⚠️ 우려: Docker 없이도 로컬 MySQL로
                                                시작할 수 있는데, 필수로 Docker를 강제하는 것이 맞나?\n\n개선 방안:\n-
                                                Docker는 \"권장\"이지만 선택사항으로 두기\n- 또는 Docker Compose 파일을
                                                미리 완성해서 제공하고, `docker-compose up -d` 한 번만 실행하면
                                                되도록\n- 로컬 MySQL 설치 옵션도 함께 제시\n\n결론: Docker 구축 단계를
                                                더 명확하게 하거나, 대안 제시 필요", thoughtNumber: 2, totalThoughts:
                                                15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 2,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Phase 1-2 (프로젝트 기반 설정 + 예외 처리)를
                                                검토해보자.\n\n제안 순서:\n1. 패키지 구조 생성\n2. WebConfig, JpaConfig
                                                등 공통 설정\n3. ApiResponse, ErrorResponse\n4. BaseTimeEntity\n5.
                                                ErrorCode, BusinessException, GlobalExceptionHandler\n\n검토:\n✅ 장점:
                                                공통 인프라를 먼저 구축하는 것은 좋은 접근\n❌ 문제점: 주니어 개발자
                                                입장에서 \"추상적인 것\"부터 시작하면 동기부여가 떨어질 수 있음\n❌
                                                문제점: 예외 처리 시스템을 먼저 만들어도, 실제 도메인 로직이 없으면
                                                테스트할 수 없음\n\n대안:\n- 먼저 가장 단순한 도메인(User
                                                회원가입/로그인)을 만들어보고\n- 그 과정에서 필요한 예외 처리를
                                                점진적으로 추가하는 방식\n- \"동작하는 코드\"를 빨리 만들어보는 것이
                                                학습에 더 효과적\n\n이것은 \"Top-down vs Bottom-up\" 접근의 차이인데,
                                                주니어에게는 Bottom-up이 더 나을 수 있음", thoughtNumber: 3,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 3,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Phase 3 (Spring Security + JWT) 시점을 검토해보자.\n\n제안
                                                순서: User 도메인보다 먼저 Security + JWT를 구현\n\n검토:\n❌ 큰 문제:
                                                Spring Security와 JWT는 매우 복잡한 주제\n❌ 주니어가 User Entity도 없는
                                                 상태에서 CustomUserDetailsService를 만들 수 없음\n❌ 로그인 로직도
                                                없는데 JWT를 먼저 구현하면 테스트 불가능\n❌ 학습 곡선: Security는
                                                Spring에서 가장 어려운 부분 중 하나\n\n올바른 순서:\n1. 먼저 User
                                                도메인을 Security 없이 구현 (회원가입, 조회)\n2. 간단한 로그인 API를
                                                만들어보기 (Security 없이)\n3. 그 다음에 Spring Security를 적용하면서
                                                점진적으로 개선\n4. 마지막으로 JWT 추가\n\n이유:\n- \"동작하는 코드\"를
                                                먼저 만들고 점진적으로 보안을 강화하는 것이 학습에 효과적\n- Spring
                                                Security의 필요성을 체감한 후에 적용해야 이해도가 높아짐",
                                                thoughtNumber: 4, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 4,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "도메인 간 의존성을 검토해보자.\n\n제안된 도메인 구현 순서:
                                                User → Friend → Location → Shuttle → Arrival\n\n의존성 분석:\n- Friend는
                                                 User에 의존 (Friendship이 User를 참조)\n- Location은 User에 의존
                                                (LocationShare가 User를 참조)\n- Shuttle은 독립적 (ShuttleRoute,
                                                ShuttleStop)\n- Arrival은 Location + Shuttle + Friend에 모두
                                                의존\n\n검토:\n✅ User를 먼저 하는 것은 맞음\n⚠️ Friend와 Location은
                                                병렬로 개발 가능한데 순차적으로 제안됨\n⚠️ Shuttle은 다른 도메인과
                                                독립적이므로 더 일찍 할 수 있음\n\n개선된 순서:\n1. User (기본 CRUD)\n2.
                                                 Shuttle (독립적이므로 병렬 가능)\n3. Friend + Location (병렬 가능)\n4.
                                                Arrival (모든 도메인이 준비된 후)\n\n또는 학습 관점에서:\n1. Shuttle
                                                (가장 단순, JPA 연습용)\n2. User (인증 제외한 기본 기능)\n3. Friend
                                                (연관관계 학습)\n4. Location (스케줄러, Redis 학습)\n5. 인증 시스템
                                                (Security + JWT)\n6. Arrival (외부 API 연동)\n\n후자가 학습 곡선
                                                측면에서 더 나을 수 있음", thoughtNumber: 5, totalThoughts: 15,
                                                nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 5,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Redis 사용 시점을 검토해보자.\n\n제안에서 Redis 사용처:\n1.
                                                JWT Refresh Token 저장\n2. 로그아웃 토큰 Blacklist\n3. Location 데이터
                                                캐싱\n\n검토:\n⚠️ 문제: Redis를 Phase 0에 설치하지만, 실제 사용은 Phase
                                                3 (JWT), Phase 6 (Location)\n⚠️ 문제: 주니어가 Redis를 언제 왜 쓰는지
                                                모르는 채로 설치만 해두면 혼란\n⚠️ 문제: MVP에서 Redis가 정말
                                                필수인가?\n\n대안 검토:\n1. JWT Refresh Token → 초기에는 DB에 저장해도
                                                됨 (성능은 떨어지지만 동작함)\n2. Blacklist → 초기 MVP에서는 생략 가능
                                                (토큰 만료 시간만으로도 충분)\n3. Location 캐싱 → DB만으로도 충분히 빠름
                                                 (사용자 수가 많지 않으면)\n\n결론:\n- Redis는 \"성능 최적화\" 단계에서
                                                추가하는 것이 학습 관점에서 더 나을 수 있음\n- 또는 Redis를 쓴다면, 왜
                                                필요한지 명확히 설명하고 실제 사용 시점에 도입", thoughtNumber: 6,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 6,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "build.gradle의 의존성을 다시 확인해보자.\n\n현재 설정된
                                                의존성:\n- spring-boot-starter-validation ✅\n-
                                                spring-boot-starter-data-jpa ✅\n- spring-boot-starter-security ✅\n-
                                                spring-boot-starter-web ✅\n- lombok ✅\n- mysql-connector-j ✅\n- h2
                                                (테스트용) ✅\n\n제안에서 추가하려는 것:\n- JWT 라이브러리 (jjwt)\n-
                                                Redis (spring-boot-starter-data-redis)\n- WebFlux (카카오 API
                                                호출용)\n\n검토:\n✅ JWT는 필수\n⚠️ Redis는 앞서 검토했듯이 선택적\n✅
                                                WebFlux (WebClient)는 카카오 API 호출에 필요\n\n추가 고려사항:\n-
                                                RestTemplate vs WebClient: WebClient가 최신이지만 주니어에게는
                                                RestTemplate이 더 직관적일 수 있음\n- 하지만 RestTemplate은 deprecated
                                                예정이므로 WebClient 학습이 장기적으로 유리\n\n결론: 의존성 추가 계획은
                                                적절함", thoughtNumber: 7, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 7,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Location 도메인의 1시간 자동 만료 로직을
                                                검토해보자.\n\n제안된 구현:\n- LocationShare Entity에 startTime, endTime
                                                 저장\n- @Scheduled로 만료된 항목을 주기적으로 isActive = false로
                                                변경\n- Redis에도 TTL 1시간으로 캐싱\n\n검토:\n✅ startTime, endTime을
                                                DB에 저장하는 것은 좋음\n⚠️ @Scheduled로 배치 처리하는 방식의 문제점:\n
                                                 - 스케줄러가 5분마다 돌면, 만료 후 최대 5분 지연 발생\n  - 만료 시점이
                                                정확하지 않음\n  \n대안:\n1. 조회 시점에 endTime과 현재 시간을 비교
                                                (Lazy Evaluation)\n   - 장점: 정확함, 추가 스케줄러 불필요\n   - 단점:
                                                매번 시간 비교 필요\n   \n2. Redis TTL만 사용하고 DB는 로그용\n   -
                                                장점: Redis가 자동으로 만료 처리\n   - 단점: Redis 장애 시 데이터
                                                손실\n\nMVP 추천: \n- 방안 1 (조회 시점 검증)이 가장 단순하고 안정적\n-
                                                추가로 @Scheduled (1시간마다)로 정리하는 정도면 충분", thoughtNumber: 8,
                                                 totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 8,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "카카오 모빌리티 API 연동 부분을 검토해보자.\n\n제안된
                                                구현:\n- WebClient로 카카오 경로 API 호출\n- origin (친구 위치) →
                                                waypoints (경유지들) → destination (내 위치)\n- 결과로 소요 시간 및 경로
                                                 좌표 반환\n\n검토:\n✅ WebClient 사용은 적절함\n⚠️ 복잡도: 카카오 API는
                                                 여러 종류가 있고 문서가 복잡함\n⚠️ 비용: 카카오 모빌리티 API는 유료일
                                                수 있음\n\n확인 필요사항:\n1. 카카오 모빌리티 API vs 카카오맵 API
                                                차이\n2. 무료 티어 존재 여부\n3. Waypoints를 지원하는 API가
                                                맞는지\n\n대안:\n- 초기 MVP에서는 단순 직선거리 계산으로 시작\n- 나중에
                                                실제 API 연동\n- 또는 구글 Directions API 고려 (월 $200 무료
                                                크레딧)\n\n추천:\n- 일단 카카오 API 명세를 먼저 확인하고 계획 수정\n-
                                                MVP에서는 mock 데이터나 단순 계산으로 시작하는 것도 고려",
                                                thoughtNumber: 9, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 9,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "CI/CD 계획을 검토해보자.\n\n제안: GitHub Actions로 자동 빌드
                                                및 배포\n\n제안된 워크플로우:\n1. main 브랜치 push 시 트리거\n2. Gradle
                                                빌드\n3. Docker 이미지 빌드\n4. 서버로 SSH 접속하여 배포\n\n검토:\n⚠️
                                                문제: MVP 단계에서 CI/CD가 우선순위가 높은가?\n⚠️ 문제: SSH 키, 서버
                                                호스트 등의 인프라가 준비되어 있는가?\n⚠️ 문제: 주니어가 GitHub
                                                Actions를 처음 다룬다면 시간이 많이 소요될 수 있음\n\n대안:\n1. 초기에는
                                                 수동 배포 (jar 파일 빌드 후 서버에 업로드)\n2. 핵심 기능 완성 후 CI/CD
                                                추가\n3. 또는 더 간단한 방식: GitHub Actions로 빌드만 자동화 (배포는
                                                수동)\n\n우선순위 재조정:\n- Phase 1-8: 핵심 기능 구현\n- Phase 9: CI/CD
                                                 (선택사항, 시간 여유 있을 때)\n\n결론: CI/CD는 \"좋으면 하는 것\"이지
                                                MVP 필수는 아님", thoughtNumber: 10, totalThoughts: 15,
                                                nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 10,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "CLAUDE.md에서 프론트엔드 요구사항을 다시 확인해보자.\n\n핵심
                                                API 엔드포인트 (프론트에서 필요한 것):\n1. POST /api/auth/login,
                                                /api/auth/signup\n2. POST /api/location/start, /api/location/stop, PUT
                                                /api/location/update\n3. GET /api/friends, POST /api/friends/request,
                                                PUT /api/friends/:id/accept/reject\n4. GET /api/shuttle/routes, GET
                                                /api/shuttle/routes/:id/stops\n5. POST /api/shuttle/arrival-time\n6.
                                                검색 API: GET /api/shuttle/routes/search, GET
                                                /api/friends/search\n\n추가 필요한 API (제안에서 누락):\n❌ 친구 이름
                                                검색 API가 명시되어 있지만, 실제로는 \"이메일로 검색\"이 필요\n❌ GET
                                                /api/location/friends - 모든 친구들의 위치를 한번에 조회하는 API 필요\n
                                                  (현재는 GET /api/location/friend/:friendId로 한명씩만 조회
                                                가능)\n\n검토:\n- 프론트엔드 요구사항: \"친구 관계인 모든 유저의 위치
                                                마커 표시\"\n- 이를 위해서는 친구 목록 조회 → 각 친구의 위치 조회 (N+1
                                                문제 발생)\n- 더 나은 방법: GET /api/location/friends 엔드포인트로
                                                한번에 조회\n\n결론: Location API 설계에 보완 필요", thoughtNumber: 11,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 11,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Entity 설계를 다시 검토해보자.\n\nFriendship Entity:\n-
                                                requester (요청 보낸 사람)\n- receiver (요청 받은 사람)\n- status
                                                (PENDING, ACCEPTED, REJECTED)\n\n검토:\n✅ 기본 설계는 괜찮음\n⚠️ 쿼리
                                                복잡도: \"내 친구 목록\"을 조회하려면?\n  - WHERE (requester_id = 나 OR
                                                receiver_id = 나) AND status = ACCEPTED\n  - 양방향 관계 때문에 쿼리가
                                                복잡해짐\n\n대안:\n1. 현재 설계 유지 + Repository에서 복잡한 쿼리
                                                작성\n2. ACCEPTED 상태가 되면 양방향 레코드 2개 생성 (더 단순한 쿼리)\n
                                                  - (A→B, ACCEPTED), (B→A, ACCEPTED)\n   - 단점: 데이터 중복\n\n추천:\n-
                                                 방안 1 유지 (정규화)\n- JPA 쿼리 메서드 예시 제공 필요:\n  ```java\n
                                                @Query(\"SELECT f FROM Friendship f WHERE (f.requester.id = :userId OR
                                                f.receiver.id = :userId) AND f.status = 'ACCEPTED'\")\n
                                                List<Friendship> findMyFriends(@Param(\"userId\") Long userId);\n
                                                ```\n\n결론: Entity 설계는 괜찮지만 Repository 쿼리 예시 추가 필요",
                                                thoughtNumber: 12, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 12,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "Validation 전략을 검토해보자.\n\n제안에서 Validation:\n-
                                                @Email, @NotBlank, @Pattern 등 Bean Validation 사용\n- SignUpRequest에서
                                                 비밀번호 정규식 검증\n\n검토:\n✅ Bean Validation 사용은 좋은 접근\n⚠️
                                                주의: 비밀번호 확인(password, passwordConfirm) 검증은?\n⚠️ 주의: 이메일
                                                중복 체크는 어디서?\n\n필요한 Validation 레이어:\n1. DTO 레벨: @Valid로
                                                기본 형식 검증\n2. Service 레벨: 비즈니스 로직 검증 (중복 체크 등)\n3.
                                                Custom Validator: 복잡한 검증 (비밀번호 일치 등)\n\n예시:\n```java\n//
                                                DTO\n@Getter\npublic class SignUpRequest {\n    @Email\n    private
                                                String email;\n    \n    @Pattern(regexp =
                                                \"^(?=.*[A-Za-z])(?=.*\\\\d)[A-Za-z\\\\d]{8,}$\")\n    private String
                                                password;\n    \n    private String passwordConfirm;\n}\n\n//
                                                Service\npublic void signUp(SignUpRequest request) {\n    // 비밀번호
                                                일치 검증\n    if
                                                (!request.getPassword().equals(request.getPasswordConfirm())) {\n
                                                 throw new BusinessException(ErrorCode.PASSWORD_NOT_MATCH);\n    }\n
                                                \n    // 이메일 중복 검증\n    if
                                                (userRepository.existsByEmail(request.getEmail())) {\n        throw new
                                                BusinessException(ErrorCode.DUPLICATE_EMAIL);\n    }\n
                                                ...\n}\n```\n\n결론: Validation 전략은 괜찮지만 더 구체적인 예시 필요",
                                                thoughtNumber: 13, totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 13,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "학습 자료와 시간 예상을 검토해보자.\n\n제안된 총 소요 시간:
                                                2-3주\n\nPhase별 소요 시간:\n- Phase 0 (Docker): 1-2일\n- Phase 1
                                                (기반): 1일\n- Phase 2 (예외처리): 1일\n- Phase 3 (Security+JWT):
                                                2-3일\n- Phase 4-7 (도메인): 6-7일\n- Phase 8 (카카오 API): 2-3일\n-
                                                Phase 9 (CI/CD): 1-2일\n합계: 14-21일\n\n검토:\n⚠️ 문제: 주니어 개발자가
                                                 처음 Spring을 배우면서 진행한다면 2-3주는 매우 빡빡함\n⚠️ 문제: 학습
                                                시간이 고려되지 않음 (순수 개발 시간만 계산)\n⚠️ 문제: 디버깅, 오류 수정
                                                 시간 미포함\n\n현실적인 예상:\n- 학습하면서 개발: 3-4주\n- 오류 해결
                                                버퍼: +1주\n- 총 4-5주가 더 현실적\n\n또한:\n- 매일 풀타임으로 개발할 수
                                                 있는가?\n- SSAFY 교육 중이라면 병행해야 하므로 더 길어질 수
                                                있음\n\n결론: 시간 예상을 더 보수적으로 조정 필요", thoughtNumber: 14,
                                                totalThoughts: 15, nextThoughtNeeded: true)
  ⎿  {
       "thoughtNumber": 14,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● sequential-thinking - sequentialthinking (MCP)(thought: "전체 계획을 종합하여 개선안을 정리해보자.\n\n발견한 주요
                                                문제점:\n1. 개발 순서: 추상적인 것(예외처리, Security)을 먼저 하면 학습
                                                곡선이 가파름\n2. Redis: MVP에서 필수가 아닌데 초기부터 도입\n3.
                                                Security+JWT: User 도메인보다 먼저 구현할 수 없음\n4. API 누락: 친구들의
                                                 위치를 한번에 조회하는 API\n5. 시간 예상: 너무 낙관적 (학습 시간
                                                미포함)\n6. CI/CD: MVP 우선순위가 아님\n7. 카카오 API: 비용/복잡도 고려
                                                필요\n\n개선된 개발 순서 제안:\n1. **환경 설정** (1-2일): Docker MySQL
                                                (Redis는 나중에)\n2. **Shuttle 도메인** (1-2일): 가장 단순, JPA
                                                학습용\n3. **User 도메인 (인증 제외)** (2일): 기본 CRUD\n4. **공통
                                                인프라** (1일): 예외처리, Validation (필요성을 체감한 후)\n5. **Friend
                                                도메인** (2일): 연관관계 학습\n6. **Location 도메인** (2일): 위치 공유
                                                기본\n7. **Spring Security + JWT** (3-4일): 이제 적용\n8. **Arrival
                                                도메인** (2-3일): 카카오 API (또는 mock)\n9. **Redis 최적화** (1일):
                                                선택사항\n10. **CI/CD** (1-2일): 선택사항\n\n이 순서의 장점:\n- 단순한
                                                것부터 복잡한 것으로\n- 각 단계에서 동작하는 코드를 만들며 학습\n- 필수
                                                기능 우선, 최적화는 나중에", thoughtNumber: 15, totalThoughts: 15,
                                                nextThoughtNeeded: false)
  ⎿  {
       "thoughtNumber": 15,
       "totalThoughts": 15,
     … +4 lines (ctrl+o to expand)

● Sequential Thinking으로 계획을 점검한 결과, 몇 가지 중요한 문제점을 발견했습니다. 개선된 계획을 제시하겠습니다.

  ---
  🔍 Sequential Thinking 점검 결과

  ❌ 발견된 주요 문제점

  1. 개발 순서의 문제

  - 문제: 예외 처리, Security+JWT를 User 도메인보다 먼저 구현
  - 이유: 실제 도메인 로직 없이 추상적인 인프라만 만들면 테스트 불가능하고 학습 효과 낮음
  - 개선: 단순한 도메인부터 시작 → 필요성 체감 후 인프라 추가

  2. Redis의 시기상조

  - 문제: Phase 0에 Redis 설치하지만 실제 사용은 Phase 3, 6
  - 이유: MVP에서 Redis는 "성능 최적화"이지 필수가 아님
  - 개선: 일단 DB만으로 구현 → 나중에 Redis 추가 (또는 생략)

  3. 누락된 API

  - 문제: 프론트에서 "모든 친구의 위치"를 한번에 조회해야 하는데 API 없음
  - 개선: GET /api/location/friends 엔드포인트 추가 필요

  4. 비현실적인 일정

  - 문제: 2-3주 예상 (학습 시간 미포함, 디버깅 시간 미포함)
  - 개선: 현실적으로 4-5주 (주니어 + 학습 포함)

  5. CI/CD 우선순위

  - 문제: MVP 단계에서 CI/CD를 필수로 제안
  - 개선: 핵심 기능 완성 후 선택적으로 추가

  ---
  📋 개선된 개발 계획

  🎯 핵심 원칙 변경

  기존 계획 (Top-Down)

  인프라 구축 → 예외처리 → Security → 도메인

  개선된 계획 (Bottom-Up)

  단순 도메인 → 필요한 인프라 → 복잡한 기능 → 최적화

  이유: 주니어 개발자는 "동작하는 코드"를 빠르게 만들어보며 학습하는 것이 효과적

  ---
  🚀 새로운 개발 순서

  Phase 0: 환경 설정 (1-2일)

  목표: 최소한의 개발 환경 구축

  작업:
  1. Docker Compose로 MySQL만 구축 (Redis는 나중에)
  services:
    mysql:
      image: mysql:8.0
      ports: ["3306:3306"]
      environment:
        MYSQL_DATABASE: shuttle_tracker
  2. application.yml 기본 설정
  3. 프로젝트 실행 확인

  학습: Docker 기본, MySQL 연결

  ---
  Phase 1: Shuttle 도메인 (1-2일)

  목표: 가장 단순한 도메인으로 JPA 학습

  왜 먼저?
  - 다른 도메인과 독립적
  - 인증 불필요
  - CRUD 기본 학습에 최적

  작업:
  1. Entity 작성: ShuttleRoute, ShuttleStop
  2. Repository: @OneToMany 관계 학습
  3. Service: 기본 조회 로직
  4. Controller: REST API 작성
    - GET /api/shuttle/routes
    - GET /api/shuttle/routes/{id}/stops
    - GET /api/shuttle/routes/search?q={query}
  5. SQL로 초기 데이터 삽입

  학습:
  - JPA Entity, Repository 기본
  - @OneToMany 연관관계
  - Spring Web Controller
  - SQL 초기 데이터 로드

  결과: Postman으로 실제 동작하는 API 확인 가능!

  ---
  Phase 2: User 도메인 - 기본편 (2일)

  목표: 인증 없이 User CRUD 구현

  작업:
  1. Entity: User (email, password, name)
  2. Repository: 기본 메서드
  3. Service:
    - 회원가입 (비밀번호 BCrypt 암호화)
    - 이메일로 사용자 검색
    - 내 정보 조회
  4. Controller:
    - POST /api/users (회원가입)
    - GET /api/users/search?email={email} (검색)
    - GET /api/users/{id} (조회)

  학습:
  - BCryptPasswordEncoder
  - Bean Validation (@Email, @NotBlank)
  - DTO 패턴 (Request/Response 분리)

  보안은?: 일단 인증 없이 만들어봄 (학습용)

  ---
  Phase 3: 공통 인프라 구축 (1일)

  목표: 지금까지 개발하며 느낀 필요성을 해결

  작업:
  1. GlobalExceptionHandler
    - 지금까지 발생한 예외들을 한곳에서 처리
  2. ErrorCode Enum
  USER_NOT_FOUND(404, "U001", "사용자를 찾을 수 없습니다.")
  DUPLICATE_EMAIL(409, "U002", "이미 존재하는 이메일입니다.")
  3. ApiResponse 통일
  {
    "success": true,
    "data": {...},
    "error": null
  }
  4. BaseTimeEntity (createdAt, updatedAt)

  학습:
  - @ControllerAdvice
  - Custom Exception 설계

  왜 이제?: 실제 예외가 발생해봐야 필요성을 체감함

  ---
  Phase 4: Friend 도메인 (2일)

  목표: 연관관계 심화 학습

  작업:
  1. Entity: Friendship
    - @ManyToOne User requester
    - @ManyToOne User receiver
    - FriendshipStatus status
  2. Repository:
  @Query("SELECT f FROM Friendship f WHERE (f.requester.id = :userId OR f.receiver.id = :userId) AND f.status =
  'ACCEPTED'")
  List<Friendship> findMyFriends(@Param("userId") Long userId);
  3. Service: 친구 추가/수락/거절/삭제
  4. Controller:
    - GET /api/friends (내 친구 목록)
    - POST /api/friends/request
    - PUT /api/friends/{id}/accept
    - DELETE /api/friends/{id}

  학습:
  - 양방향 관계 처리
  - JPQL 작성
  - 복잡한 비즈니스 로직

  ---
  Phase 5: Location 도메인 (2일)

  목표: 위치 공유 로직 구현

  작업:
  1. Entity: LocationShare
  private LocalDateTime startTime;
  private LocalDateTime endTime; // startTime + 1시간
  private Boolean isActive;
  2. Service:
    - 위치 공유 시작/중지
    - 위치 업데이트
    - 중요: GET /api/location/friends (모든 친구 위치 한번에 조회)
    - 조회 시 endTime과 현재 시간 비교 (만료 검증)
  3. @Scheduled (1시간마다 만료된 데이터 정리)

  학습:
  - LocalDateTime 사용
  - @Scheduled 태스크
  - 효율적인 쿼리 (N+1 방지)

  ---
  Phase 6: Spring Security + JWT (3-4일)

  목표: 기존 API에 인증 추가

  왜 이제?:
  - User, Friend, Location이 모두 동작하는 상태
  - 이제 "보호"가 필요함을 체감

  작업:
  1. JWT 의존성 추가
  implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
  2. JwtTokenProvider 구현
  3. JwtAuthenticationFilter 구현
  4. SecurityConfig 작성
  .requestMatchers("/api/auth/**", "/api/shuttle/**").permitAll()
  .anyRequest().authenticated()
  5. 로그인 API 추가
    - POST /api/auth/login → JWT 발급
  6. 기존 API에 인증 적용

  학습:
  - Spring Security Architecture
  - JWT 토큰 생성/검증
  - Filter Chain

  Refresh Token은?:
  - 초기에는 Access Token만 (1일 TTL)
  - 나중에 필요하면 추가

  ---
  Phase 7: Arrival 도메인 (2-3일)

  목표: 도착 시간 예측

  작업:
  1. 카카오 API 조사
    - 비용 확인
    - API 명세 확인
    - 무료 대안 탐색
  2. WebClient 설정
  3. ArrivalTimeService 구현
  4. 대안: 초기에는 단순 거리 계산으로 mock
  // 하버사인 공식으로 직선거리 계산
  double distance = calculateDistance(friendLoc, myLoc);
  int estimatedMinutes = (int)(distance / 평균속도);

  학습:
  - WebClient 사용
  - 외부 API 연동
  - 에러 핸들링

  ---
  Phase 8: Redis 최적화 (선택, 1일)

  목표: 성능 개선

  Redis 도입 시점:
  - Refresh Token 저장
  - Location 데이터 캐싱 (TTL 1시간)

  작업:
  1. Docker Compose에 Redis 추가
  2. RedisUtil 구현
  3. LocationService에 캐싱 로직 추가

  왜 선택?: MVP에서 사용자가 많지 않으면 불필요

  ---
  Phase 9: CI/CD (선택, 1-2일)

  목표: 자동 배포

  작업:
  1. GitHub Actions 워크플로우
  2. Docker 이미지 빌드
  3. 서버 배포 자동화

  왜 선택?: 핵심 기능 완성이 우선

  ---
  📊 개선된 일정 예상

  | Phase | 내용             | 예상 소요 (주니어+학습) |
  |-------|----------------|----------------|
  | 0     | 환경 설정          | 1-2일           |
  | 1     | Shuttle 도메인    | 1-2일           |
  | 2     | User 도메인 기본    | 2일             |
  | 3     | 공통 인프라         | 1일             |
  | 4     | Friend 도메인     | 2일             |
  | 5     | Location 도메인   | 2일             |
  | 6     | Security + JWT | 3-4일           |
  | 7     | Arrival 도메인    | 2-3일           |
  | 8     | Redis (선택)     | 1일             |
  | 9     | CI/CD (선택)     | 1-2일           |
  | 버퍼    | 디버깅, 오류 수정     | 3-5일           |
  | 총계    |                | 4-5주 (현실적)     |

  ---
  ✅ MVP 필수 vs 선택

  필수 (3주 목표)

  - ✅ Phase 0-7 (Redis, CI/CD 제외)
  - ✅ JWT 인증
  - ✅ 핵심 도메인 기능
  - ✅ 예외 처리

  선택 (시간 여유 시)

  - ⭐ Redis 최적화
  - ⭐ CI/CD
  - ⭐ 실제 카카오 API 연동 (초기에는 mock 가능)
  - ⭐ WebSocket 실시간 업데이트

  ---
  📚 단계별 학습 자료

  Phase 1-2: JPA 기초

  - 김영한 - 자바 ORM 표준 JPA 프로그래밍 (인프런)
  - Spring Data JPA 공식 문서

  Phase 3: 예외 처리

  - Baeldung - Exception Handling in Spring
  - 우아한형제들 기술 블로그 - 예외 처리 전략

  Phase 4-5: JPA 심화

  - N+1 문제 해결
  - JPQL vs QueryDSL

  Phase 6: Spring Security

  - 김영한 - 스프링 시큐리티 (인프런)
  - JWT.io 공식 문서
  - Baeldung - Spring Security + JWT

  Phase 7: WebClient

  - Spring WebFlux 공식 문서
  - 카카오 모빌리티 API 문서

  ---
  💡 추가 개선 사항

  1. API 명세 보완

  // 추가 필요
  GET /api/location/friends          // 모든 친구 위치 한번에 조회
  GET /api/users/search?email={email} // 이메일로 사용자 검색

  2. Validation 강화

  // SignUpRequest에 추가
  private String passwordConfirm;

  // Service에서 검증
  if (!password.equals(passwordConfirm)) {
      throw new BusinessException(ErrorCode.PASSWORD_NOT_MATCH);
  }

  3. 위치 만료 로직 개선

  // 조회 시점에 검증 (Lazy Evaluation)
  public Optional<LocationShare> getActiveLocation(Long userId) {
      return locationShareRepository.findByUserId(userId)
          .filter(loc -> loc.getEndTime().isAfter(LocalDateTime.now()))
          .filter(LocationShare::getIsActive);
  }

  ---
  ⎿  User rejected Claude's plan:
     ╭─────────────────────────────────────────────────────────────────────────────╮
     │ Sequential Thinking 점검 완료 - 개선된 백엔드 개발 계획                     │
     │                                                                             │
     │ 🔍 주요 개선 사항                                                           │
     │                                                                             │
     │ 1. 개발 순서 대폭 수정 (Bottom-Up 접근)                                     │
     │                                                                             │
     │ 기존: 인프라 → Security → 도메인개선: 단순 도메인 → 필요 인프라 → 복잡 기능 │
     │                                                                             │
     │ 새로운 순서:                                                                │
     │ 1. Shuttle 도메인 (가장 단순, JPA 학습)                                     │
     │ 2. User 도메인 기본 (인증 제외)                                             │
     │ 3. 공통 인프라 (필요성 체감 후)                                             │
     │ 4. Friend 도메인 (연관관계)                                                 │
     │ 5. Location 도메인 (스케줄러)                                               │
     │ 6. Spring Security + JWT (이제 적용)                                        │
     │ 7. Arrival 도메인 (카카오 API)                                              │
     │                                                                             │
     │ 이유: 주니어는 "동작하는 코드"를 빠르게 만들며 학습하는 것이 효과적         │
     │                                                                             │
     │ 2. Redis를 선택사항으로 변경                                                │
     │                                                                             │
     │ - MVP에서 Redis는 "최적화"이지 필수 아님                                    │
     │ - 초기에는 DB만으로 충분                                                    │
     │ - Phase 8에서 선택적으로 추가                                               │
     │                                                                             │
     │ 3. CI/CD 우선순위 하향                                                      │
     │                                                                             │
     │ - 핵심 기능 완성이 우선                                                     │
     │ - Phase 9에서 선택사항으로                                                  │
     │                                                                             │
     │ 4. 누락된 API 추가                                                          │
     │                                                                             │
     │ - GET /api/location/friends (모든 친구 위치 한번에)                         │
     │ - GET /api/users/search?email={email} (이메일 검색)                         │
     │                                                                             │
     │ 5. 현실적인 일정 조정                                                       │
     │                                                                             │
     │ 기존: 2-3주개선: 4-5주 (학습 시간 + 디버깅 버퍼 포함)                       │
     │                                                                             │
     │ 📋 최종 개발 순서 (3주 MVP 목표)                                            │
     │                                                                             │
     │ Week 1: 기초 다지기                                                         │
     │                                                                             │
     │ - Phase 0-2: 환경 + Shuttle + User 기본                                     │
     │                                                                             │
     │ Week 2: 핵심 도메인                                                         │
     │                                                                             │
     │ - Phase 3-5: 인프라 + Friend + Location                                     │
     │                                                                             │
     │ Week 3: 인증 & 통합                                                         │
     │                                                                             │
     │ - Phase 6-7: Security + JWT + Arrival                                       │
     │                                                                             │
     │ Week 4-5: 여유분 (선택)                                                     │
     │                                                                             │
     │ - Redis, CI/CD, 디버깅, 개선                                                │
     │                                                                             │
     │ 📚 학습 로드맵 명확화                                                       │
     │                                                                             │
     │ 각 Phase마다 구체적인 학습 자료와 실습 목표 제시                            │
     │                                                                             │
     │ 이 개선된 계획으로 진행하시겠습니까?     